
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>msprime.ancestry &#8212; Msprime manual</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=9c3e77be" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=1ae7504c"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/msprime/ancestry';</script>
    <link rel="icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <script data-goatcounter="https://tskit.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/msprime_logo.svg" class="logo__image only-light" alt=""/>
    <script>document.write(`<img src="../../_static/msprime_logo.svg" class="logo__image only-dark" alt=""/>`);</script>
  
  
    <p class="title logo__title">Version 1.4.0</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Running simulations</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../ancestry.html">Ancestry simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mutations.html">Mutation simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../demography.html">Demographic models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../replication.html">Randomness and replication</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Interfaces</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli.html">Command line interface</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Utilities</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../rate_maps.html">Rate Maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pedigrees.html">Pedigrees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../likelihoods.html">Computing likelihoods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../logging.html">Logging</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Miscellaneous</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../legacy.html">Legacy (version 0.x) APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../switch_from_other_simulators.html">Switching from other simulators</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CITATION.html">Citing msprime</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CHANGELOG.html">Changelog</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for msprime.ancestry</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Copyright (C) 2015-2025 University of Oxford</span>
<span class="c1">#</span>
<span class="c1"># This file is part of msprime.</span>
<span class="c1">#</span>
<span class="c1"># msprime is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># msprime is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with msprime.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module responsible for defining and running ancestry simulations.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">collections.abc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dataclasses</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">enum</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tempfile</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ClassVar</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">demography</span> <span class="k">as</span> <span class="n">demog</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">intervals</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">mutations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">provenance</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">msprime</span><span class="w"> </span><span class="kn">import</span> <span class="n">_msprime</span>

<span class="n">logger</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">TIME_UNITS_GENERATIONS</span> <span class="o">=</span> <span class="s2">&quot;generations&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TimeUnitsMismatchWarning</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Warning raise when the time units specified in different parts of a</span>
<span class="sd">    simulation do not match.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_model_factory</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">AncestryModel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AncestryModel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an AncestryModel corresponding to the specified model</span>
<span class="sd">    description.</span>
<span class="sd">    - If model is None, the default simulation model is returned.</span>
<span class="sd">    - If model is a string, return the corresponding model instance.</span>
<span class="sd">    - If model is an instance of AncestryModel, return it unchanged.</span>
<span class="sd">    - Otherwise raise a type error.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;hudson&quot;</span><span class="p">:</span> <span class="n">StandardCoalescent</span><span class="p">(),</span>
        <span class="s2">&quot;smc&quot;</span><span class="p">:</span> <span class="n">SmcApproxCoalescent</span><span class="p">(),</span>
        <span class="s2">&quot;smc_prime&quot;</span><span class="p">:</span> <span class="n">SmcPrimeApproxCoalescent</span><span class="p">(),</span>
        <span class="s2">&quot;dtwf&quot;</span><span class="p">:</span> <span class="n">DiscreteTimeWrightFisher</span><span class="p">(),</span>
        <span class="s2">&quot;fixed_pedigree&quot;</span><span class="p">:</span> <span class="n">FixedPedigree</span><span class="p">(),</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">model_instance</span> <span class="o">=</span> <span class="n">StandardCoalescent</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">lower_model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">lower_model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">model_map</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Model &#39;</span><span class="si">{}</span><span class="s2">&#39; unknown. Choose from </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">model</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">model_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">model_instance</span> <span class="o">=</span> <span class="n">model_map</span><span class="p">[</span><span class="n">lower_model</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">AncestryModel</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Ancestry model must be a string or an instance of AncestryModel&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">model_instance</span> <span class="o">=</span> <span class="n">model</span>
    <span class="k">return</span> <span class="n">model_instance</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_model_arg</span><span class="p">(</span><span class="n">model_arg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses the specified model argument from the sim_ancestry function,</span>
<span class="sd">    returning the list of models.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO be more lenient about what we accept as input here. Ideally</span>
    <span class="c1"># we&#39;d like to support generators and consume them during the</span>
    <span class="c1"># actual simulation, but that would raise complications for how</span>
    <span class="c1"># to deal with replication.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model_arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">model_arg</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must specify at least one AncestryModel&quot;</span><span class="p">)</span>
        <span class="n">models</span> <span class="o">=</span> <span class="p">[</span><span class="n">_model_factory</span><span class="p">(</span><span class="n">model_desc</span><span class="p">)</span> <span class="k">for</span> <span class="n">model_desc</span> <span class="ow">in</span> <span class="n">model_arg</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">models</span> <span class="o">=</span> <span class="p">[</span><span class="n">_model_factory</span><span class="p">(</span><span class="n">model_arg</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">models</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_resolve_models</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
    <span class="n">model_change_events</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">SimulationModelChange</span><span class="p">)</span>
        <span class="c1"># We don&#39;t want to modify our inputs, so take a deep copy.</span>
        <span class="n">event</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="n">event</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">_model_factory</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="n">model_change_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model_change_events</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_filter_events</span><span class="p">(</span><span class="n">demographic_events</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tuple (demographic_events, model_change_events) which separates</span>
<span class="sd">    out the SimulationModelChange events from the list. This is to support the</span>
<span class="sd">    pre-1.0 syntax for model changes, where they were included in the</span>
<span class="sd">    demographic_events parameter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filtered_events</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">model_change_events</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">demographic_events</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">SimulationModelChange</span><span class="p">):</span>
            <span class="n">model_change_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filtered_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
    <span class="n">model_change_events</span> <span class="o">=</span> <span class="n">_resolve_models</span><span class="p">(</span><span class="n">model_change_events</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">filtered_events</span><span class="p">,</span> <span class="n">model_change_events</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_population_configurations</span><span class="p">(</span><span class="n">population_configurations</span><span class="p">):</span>
    <span class="n">err</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;Population configurations must be a list of PopulationConfiguration instances&quot;</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">config</span> <span class="ow">in</span> <span class="n">population_configurations</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">demog</span><span class="o">.</span><span class="n">PopulationConfiguration</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>


<span class="c1"># This class is only used in the 0.x interface.</span>
<span class="n">Sample</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Sample&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;population&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">])</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_samples_factory</span><span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">population_configurations</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of Sample objects, given the specified inputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">the_samples</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">sample_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify sample size and samples simultaneously.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">population_configurations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify sample size and population_configurations &quot;</span>
                <span class="s2">&quot;simultaneously.&quot;</span>
            <span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Sample</span><span class="p">(</span><span class="n">population</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
        <span class="n">the_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sample_size</span><span class="p">)]</span>
    <span class="c1"># If we have population configurations we may have embedded sample_size</span>
    <span class="c1"># values telling us how many samples to take from each population.</span>
    <span class="k">if</span> <span class="n">population_configurations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_check_population_configurations</span><span class="p">(</span><span class="n">population_configurations</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">the_samples</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">conf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">population_configurations</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">conf</span><span class="o">.</span><span class="n">sample_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">the_samples</span> <span class="o">+=</span> <span class="p">[</span><span class="n">Sample</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">conf</span><span class="o">.</span><span class="n">sample_size</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">conf</span> <span class="ow">in</span> <span class="n">population_configurations</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">conf</span><span class="o">.</span><span class="n">sample_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot specify population configuration sample size&quot;</span>
                        <span class="s2">&quot; and samples simultaneously&quot;</span>
                    <span class="p">)</span>
            <span class="n">the_samples</span> <span class="o">=</span> <span class="n">samples</span>
    <span class="k">elif</span> <span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">the_samples</span> <span class="o">=</span> <span class="n">samples</span>
    <span class="k">return</span> <span class="n">the_samples</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_demography_factory</span><span class="p">(</span>
    <span class="n">Ne</span><span class="p">,</span> <span class="n">population_configurations</span><span class="p">,</span> <span class="n">migration_matrix</span><span class="p">,</span> <span class="n">demographic_events</span>
<span class="p">):</span>
    <span class="n">demography</span> <span class="o">=</span> <span class="n">demog</span><span class="o">.</span><span class="n">Demography</span><span class="o">.</span><span class="n">from_old_style</span><span class="p">(</span>
        <span class="n">population_configurations</span><span class="p">,</span>
        <span class="n">migration_matrix</span><span class="o">=</span><span class="n">migration_matrix</span><span class="p">,</span>
        <span class="n">demographic_events</span><span class="o">=</span><span class="n">demographic_events</span><span class="p">,</span>
        <span class="n">Ne</span><span class="o">=</span><span class="n">Ne</span><span class="p">,</span>
        <span class="n">ignore_sample_size</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">demography</span><span class="o">.</span><span class="n">validate</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_build_initial_tables</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">ploidy</span><span class="p">,</span> <span class="n">demography</span><span class="p">):</span>
    <span class="c1"># NOTE: this is only used in the simulate() codepath.</span>
    <span class="n">tables</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">)</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">time_units</span> <span class="o">=</span> <span class="n">TIME_UNITS_GENERATIONS</span>

    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
            <span class="n">flags</span><span class="o">=</span><span class="n">tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">population</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Negative population ID in sample at index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">population</span> <span class="o">&gt;=</span> <span class="n">demography</span><span class="o">.</span><span class="n">num_populations</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid population reference &#39;</span><span class="si">{</span><span class="n">population</span><span class="si">}</span><span class="s2">&#39; in sample &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;at index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="c1"># This is for the simulate() code path so we don&#39;t add metadata schemas</span>
    <span class="c1"># and insert the user metadata in directly as encoded JSON, as before.</span>
    <span class="k">for</span> <span class="n">population</span> <span class="ow">in</span> <span class="n">demography</span><span class="o">.</span><span class="n">populations</span><span class="p">:</span>
        <span class="n">encoded_metadata</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">population</span><span class="o">.</span><span class="n">extra_metadata</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">encoded_metadata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">population</span><span class="o">.</span><span class="n">extra_metadata</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">encoded_metadata</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tables</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_simulate</span><span class="p">(</span>
    <span class="n">sample_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">Ne</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">population_configurations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">migration_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">demographic_events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_migrations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">from_ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_full_arg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">num_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Argument parser for the simulate frontend. Interprets all the parameters</span>
<span class="sd">    and returns an appropriate instance of Simulator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Ne</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Population size must be positive&quot;</span><span class="p">)</span>

    <span class="n">samples_specified</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">sample_size</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">population_configurations</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">from_ts</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">samples_specified</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Either sample_size, samples, population_configurations or from_ts must &quot;</span>
            <span class="s2">&quot;be specified&quot;</span>
        <span class="p">)</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">_samples_factory</span><span class="p">(</span><span class="n">sample_size</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">population_configurations</span><span class="p">)</span>

    <span class="n">models</span> <span class="o">=</span> <span class="p">[</span><span class="n">_model_factory</span><span class="p">(</span><span class="n">model</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">demographic_events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">demographic_events</span><span class="p">,</span> <span class="n">model_change_events</span> <span class="o">=</span> <span class="n">_filter_events</span><span class="p">(</span><span class="n">demographic_events</span><span class="p">)</span>
        <span class="n">current_time</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">start_time</span>
        <span class="k">for</span> <span class="n">mce</span> <span class="ow">in</span> <span class="n">model_change_events</span><span class="p">:</span>
            <span class="n">models</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">mce</span><span class="o">.</span><span class="n">time</span> <span class="o">-</span> <span class="n">current_time</span>
            <span class="n">models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mce</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
            <span class="n">current_time</span> <span class="o">=</span> <span class="n">mce</span><span class="o">.</span><span class="n">time</span>
    <span class="n">is_dtwf</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">models</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DiscreteTimeWrightFisher</span><span class="p">)</span>
    <span class="n">is_pedigree</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">FixedPedigree</span><span class="p">)</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">)</span>

    <span class="n">demography</span> <span class="o">=</span> <span class="n">_demography_factory</span><span class="p">(</span>
        <span class="n">Ne</span><span class="p">,</span> <span class="n">population_configurations</span><span class="p">,</span> <span class="n">migration_matrix</span><span class="p">,</span> <span class="n">demographic_events</span>
    <span class="p">)</span>

    <span class="c1"># The logic for checking from_ts and recombination map is bound together</span>
    <span class="c1"># in a complicated way, so we can factor them out into separate functions.</span>
    <span class="k">if</span> <span class="n">from_ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample size must be &gt;= 2&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify samples with from_ts&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">from_ts</span><span class="p">,</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TreeSequence</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;from_ts must be a TreeSequence instance.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">demography</span><span class="o">.</span><span class="n">num_populations</span> <span class="o">!=</span> <span class="n">from_ts</span><span class="o">.</span><span class="n">num_populations</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Mismatch in the number of populations in from_ts and simulation &quot;</span>
                <span class="s2">&quot;parameters. The number of populations in the simulation must be &quot;</span>
                <span class="s2">&quot;equal to the number of populations in from_ts&quot;</span>
            <span class="p">)</span>

    <span class="n">discrete_genome</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">recombination_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Default to 1 if no from_ts; otherwise default to the sequence length</span>
        <span class="c1"># of from_ts</span>
        <span class="k">if</span> <span class="n">from_ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">the_length</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">the_length</span> <span class="o">=</span> <span class="n">from_ts</span><span class="o">.</span><span class="n">sequence_length</span> <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">length</span>
        <span class="n">the_rate</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">recombination_rate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">recombination_rate</span>
        <span class="k">if</span> <span class="n">the_length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot provide non-positive sequence length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">the_rate</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot provide negative recombination rate&quot;</span><span class="p">)</span>
        <span class="n">recombination_map</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">the_length</span><span class="p">,</span> <span class="n">the_rate</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recombination_map</span><span class="p">,</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RecombinationMap</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">recombination_map</span><span class="o">.</span><span class="n">_is_discrete</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Emulating v0.x discrete sites simulation&quot;</span><span class="p">)</span>
                <span class="n">discrete_genome</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># Convert from the legacy RecombinationMap class</span>
            <span class="n">recombination_map</span> <span class="o">=</span> <span class="n">recombination_map</span><span class="o">.</span><span class="n">map</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recombination_map</span><span class="p">,</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;RateMap instance required.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">recombination_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify length/recombination_rate along with &quot;</span>
                <span class="s2">&quot;a recombination map&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">from_ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">recombination_map</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">from_ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Recombination map and from_ts must have identical &quot;</span> <span class="s2">&quot;sequence_length&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">num_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">num_labels</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have at least one structured coalescent label&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">from_ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">_build_initial_tables</span><span class="p">(</span>
            <span class="n">sequence_length</span><span class="o">=</span><span class="n">recombination_map</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
            <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">from_ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">record_full_arg</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_dtwf</span> <span class="ow">or</span> <span class="n">is_pedigree</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Full ARG recording not supported in FixedPedigree and DTWF simulation&quot;</span>
            <span class="p">)</span>
        <span class="n">coalescing_segments_only</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">additional_nodes</span> <span class="o">=</span> <span class="n">NodeType</span><span class="p">(</span>
            <span class="n">NodeType</span><span class="o">.</span><span class="n">RECOMBINANT</span>
            <span class="o">|</span> <span class="n">NodeType</span><span class="o">.</span><span class="n">COMMON_ANCESTOR</span>
            <span class="o">|</span> <span class="n">NodeType</span><span class="o">.</span><span class="n">MIGRANT</span>
            <span class="o">|</span> <span class="n">NodeType</span><span class="o">.</span><span class="n">GENE_CONVERSION</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coalescing_segments_only</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">additional_nodes</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># It&#39;s useful to call _parse_simulate outside the context of the main</span>
    <span class="c1"># entry point - so we want to get good seeds in this case too.</span>
    <span class="n">random_seed</span> <span class="o">=</span> <span class="n">_parse_random_seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="n">random_generator</span> <span class="o">=</span> <span class="n">_msprime</span><span class="o">.</span><span class="n">RandomGenerator</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

    <span class="n">sim</span> <span class="o">=</span> <span class="n">Simulator</span><span class="p">(</span>
        <span class="n">tables</span><span class="o">=</span><span class="n">tables</span><span class="p">,</span>
        <span class="n">recombination_map</span><span class="o">=</span><span class="n">recombination_map</span><span class="p">,</span>
        <span class="n">models</span><span class="o">=</span><span class="n">models</span><span class="p">,</span>
        <span class="n">store_migrations</span><span class="o">=</span><span class="n">record_migrations</span><span class="p">,</span>
        <span class="n">additional_nodes</span><span class="o">=</span><span class="n">additional_nodes</span><span class="p">,</span>
        <span class="n">coalescing_segments_only</span><span class="o">=</span><span class="n">coalescing_segments_only</span><span class="p">,</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
        <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span><span class="p">,</span>
        <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">,</span>
        <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
        <span class="c1"># Defaults for the values that are not supported through simulate()</span>
        <span class="n">gene_conversion_map</span><span class="o">=</span><span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
            <span class="n">recombination_map</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span> <span class="mi">0</span>
        <span class="p">),</span>
        <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">discrete_genome</span><span class="o">=</span><span class="n">discrete_genome</span><span class="p">,</span>
        <span class="n">ploidy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">random_generator</span><span class="o">=</span><span class="n">random_generator</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">sim</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_random_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified random seed value. If no seed is provided, generate a</span>
<span class="sd">    high-quality random seed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_random_seed</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">seed</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">seed</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_replicate_index</span><span class="p">(</span><span class="o">*</span><span class="p">,</span> <span class="n">replicate_index</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">,</span> <span class="n">num_replicates</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the replicate_index value, and ensure that its value makes sense</span>
<span class="sd">    in the context of the other parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">replicate_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">random_seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify the replicate_index without a random_seed&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_replicates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify the replicate_index as well as num_replicates&quot;</span><span class="p">)</span>
    <span class="n">replicate_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">replicate_index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">replicate_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify negative replicate_index.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">replicate_index</span>


<div class="viewcode-block" id="simulate">
<a class="viewcode-back" href="../../legacy.html#msprime.simulate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">simulate</span><span class="p">(</span>
    <span class="n">sample_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">Ne</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mutation_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">population_configurations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">migration_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">demographic_events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_migrations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">replicate_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mutation_generator</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_replicates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">from_ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_full_arg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">num_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates the coalescent with recombination under the specified model</span>
<span class="sd">    parameters and returns the resulting :class:`tskit.TreeSequence`. Note that</span>
<span class="sd">    Ne is the effective diploid population size (so the effective number</span>
<span class="sd">    of genomes in the population is 2*Ne), but ``sample_size`` is the</span>
<span class="sd">    number of (monoploid) genomes sampled.</span>

<span class="sd">    .. important::</span>
<span class="sd">        This function is deprecated (but supported indefinitely);</span>
<span class="sd">        please use :func:`.sim_ancestry` in new code.</span>

<span class="sd">    :param int sample_size: The number of sampled monoploid genomes.  If not</span>
<span class="sd">        specified or None, this defaults to the sum of the subpopulation sample</span>
<span class="sd">        sizes. Either ``sample_size``, ``population_configurations`` or</span>
<span class="sd">        ``samples`` must be specified.</span>
<span class="sd">    :param float Ne: The effective (diploid) population size. This defaults to</span>
<span class="sd">        1 if not specified.</span>
<span class="sd">    :param float length: The length of the simulated region in bases.</span>
<span class="sd">        This parameter cannot be used along with ``recombination_map``.</span>
<span class="sd">        Defaults to 1 if not specified.</span>
<span class="sd">    :param float recombination_rate: The rate of recombination per base</span>
<span class="sd">        per generation. This parameter cannot be used along with</span>
<span class="sd">        ``recombination_map``. Defaults to 0 if not specified.</span>
<span class="sd">    :param recombination_map: The map</span>
<span class="sd">        describing the changing rates of recombination along the simulated</span>
<span class="sd">        chromosome. This parameter cannot be used along with the</span>
<span class="sd">        ``recombination_rate`` or ``length`` parameters, as these</span>
<span class="sd">        values are encoded within the map. Defaults to a uniform rate as</span>
<span class="sd">        described in the ``recombination_rate`` parameter if not specified.</span>
<span class="sd">    :type recombination_map: :class:`.RecombinationMap`</span>
<span class="sd">    :param float mutation_rate: The rate of infinite sites</span>
<span class="sd">        mutations per unit of sequence length per generation.</span>
<span class="sd">        If not specified, no mutations are generated. This option only</span>
<span class="sd">        allows for infinite sites mutations with a binary (i.e., 0/1)</span>
<span class="sd">        alphabet. For more control over the mutational process, please</span>
<span class="sd">        use the :func:`.mutate` function.</span>
<span class="sd">    :param list population_configurations: The list of</span>
<span class="sd">        :class:`.PopulationConfiguration` instances describing the</span>
<span class="sd">        sampling configuration, relative sizes and growth rates of</span>
<span class="sd">        the populations to be simulated. If this is not specified,</span>
<span class="sd">        a single population with a sample of size ``sample_size``</span>
<span class="sd">        is assumed.</span>
<span class="sd">    :type population_configurations: list or None</span>
<span class="sd">    :param list migration_matrix: The matrix describing the rates of migration</span>
<span class="sd">        between all pairs of populations. If :math:`N` populations are defined</span>
<span class="sd">        in the ``population_configurations`` parameter, then the migration</span>
<span class="sd">        matrix must be an :math:`N \\times N` matrix with 0 on the diagonal,</span>
<span class="sd">        consisting of :math:`N` lists of length :math:`N` or an :math:`N</span>
<span class="sd">        \\times N` numpy array. The :math:`[j, k]^{th}` element of the</span>
<span class="sd">        migration matrix gives the expected number of migrants moving from</span>
<span class="sd">        population :math:`k` to population :math:`j` per generation, divided by</span>
<span class="sd">        the size of population :math:`j`.  When simulating from the</span>
<span class="sd">        discrete-time Wright-Fisher model (``model = &quot;dtwf&quot;``), the row sums of</span>
<span class="sd">        the migration matrix must not exceed 1. There are no sum constraints for</span>
<span class="sd">        migration rates in continuous-time models.</span>
<span class="sd">    :param list demographic_events: The list of demographic events to</span>
<span class="sd">        simulate. Demographic events describe changes to the populations</span>
<span class="sd">        in the past. Events should be supplied in non-decreasing</span>
<span class="sd">        order of time in the past. Events with the same time value will be</span>
<span class="sd">        applied sequentially in the order that they were supplied before the</span>
<span class="sd">        simulation algorithm continues with the next time step.</span>
<span class="sd">    :param list samples: The list specifying the location and time of</span>
<span class="sd">        all samples. This parameter may be used to specify historical</span>
<span class="sd">        samples, and cannot be used in conjunction with the ``sample_size``</span>
<span class="sd">        parameter. Each sample is a (``population``, ``time``) pair</span>
<span class="sd">        such that the sample in position ``j`` in the list of samples</span>
<span class="sd">        is drawn in the specified population at the specified time. Time</span>
<span class="sd">        is measured in generations ago, as elsewhere.</span>
<span class="sd">    :param int random_seed: The random seed. If this is `None`, a</span>
<span class="sd">        random seed will be automatically generated. Valid random</span>
<span class="sd">        seeds must be between 1 and :math:`2^{32} - 1`.</span>
<span class="sd">    :param int num_replicates: The number of replicates of the specified</span>
<span class="sd">        parameters to simulate. If this is not specified or None,</span>
<span class="sd">        no replication is performed and a :class:`tskit.TreeSequence` object</span>
<span class="sd">        returned. If `num_replicates` is provided, the specified</span>
<span class="sd">        number of replicates is performed, and an iterator over the</span>
<span class="sd">        resulting :class:`tskit.TreeSequence` objects returned.</span>
<span class="sd">    :param tskit.TreeSequence from_ts: If specified, initialise the simulation</span>
<span class="sd">        from the root segments of this tree sequence and return the</span>
<span class="sd">        updated tree sequence. Please see :ref:`here</span>
<span class="sd">        &lt;sec_ancestry_initial_state&gt;` for details on the required properties</span>
<span class="sd">        of this tree sequence and its interactions with other parameters.</span>
<span class="sd">        (Default: None).</span>
<span class="sd">    :param float start_time: If specified, set the initial time that the</span>
<span class="sd">        simulation starts to this value. If not specified, the start</span>
<span class="sd">        time is zero if performing a simulation of a set of samples,</span>
<span class="sd">        or is the time of the oldest node if simulating from an</span>
<span class="sd">        existing tree sequence (see the ``from_ts`` parameter).</span>
<span class="sd">    :param float end_time: If specified, terminate the simulation at the</span>
<span class="sd">        specified time. In the returned tree sequence, all rootward paths from</span>
<span class="sd">        samples with time &lt;= end_time will end in a node with one child with</span>
<span class="sd">        time equal to end_time. Sample nodes with time &gt; end_time will</span>
<span class="sd">        also be present in the output tree sequence. If not specified or ``None``,</span>
<span class="sd">        run the simulation until all samples have an MRCA at all positions in</span>
<span class="sd">        the genome.</span>
<span class="sd">    :param bool record_full_arg: If True, record all intermediate nodes</span>
<span class="sd">        arising from common ancestor and recombination events in the output</span>
<span class="sd">        tree sequence. This will result in unary nodes (i.e., nodes in marginal</span>
<span class="sd">        trees that have only one child). Defaults to False.</span>
<span class="sd">    :param model: The simulation model to use.</span>
<span class="sd">        This can either be a string (e.g., ``&quot;smc_prime&quot;``) or an instance of</span>
<span class="sd">        a ancestry model class (e.g, ``msprime.DiscreteTimeWrightFisher()``.</span>
<span class="sd">    :type model: str or AncestryModel</span>
<span class="sd">    :param bool record_provenance: If True, record all input parameters</span>
<span class="sd">        in the tree sequence :ref:`tskit:sec_provenance`.</span>
<span class="sd">    :return: The :class:`tskit.TreeSequence` object representing the results</span>
<span class="sd">        of the simulation if no replication is performed, or an</span>
<span class="sd">        iterator over the independent replicates simulated if the</span>
<span class="sd">        `num_replicates` parameter has been used.</span>
<span class="sd">    :rtype: :class:`tskit.TreeSequence` or an iterator over</span>
<span class="sd">        :class:`tskit.TreeSequence` replicates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">replicate_index</span> <span class="o">=</span> <span class="n">_parse_replicate_index</span><span class="p">(</span>
        <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
        <span class="n">num_replicates</span><span class="o">=</span><span class="n">num_replicates</span><span class="p">,</span>
        <span class="n">replicate_index</span><span class="o">=</span><span class="n">replicate_index</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">random_seed</span> <span class="o">=</span> <span class="n">_parse_random_seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="n">provenance_dict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">command</span><span class="o">=</span><span class="s2">&quot;simulate&quot;</span><span class="p">,</span>
            <span class="n">sample_size</span><span class="o">=</span><span class="n">sample_size</span><span class="p">,</span>
            <span class="n">Ne</span><span class="o">=</span><span class="n">Ne</span><span class="p">,</span>
            <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
            <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
            <span class="n">recombination_map</span><span class="o">=</span><span class="n">recombination_map</span><span class="p">,</span>
            <span class="n">mutation_rate</span><span class="o">=</span><span class="n">mutation_rate</span><span class="p">,</span>
            <span class="n">population_configurations</span><span class="o">=</span><span class="n">population_configurations</span><span class="p">,</span>
            <span class="n">migration_matrix</span><span class="o">=</span><span class="n">migration_matrix</span><span class="p">,</span>
            <span class="n">demographic_events</span><span class="o">=</span><span class="n">demographic_events</span><span class="p">,</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="n">record_migrations</span><span class="o">=</span><span class="n">record_migrations</span><span class="p">,</span>
            <span class="n">from_ts</span><span class="o">=</span><span class="n">from_ts</span><span class="p">,</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
            <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span><span class="p">,</span>
            <span class="n">record_full_arg</span><span class="o">=</span><span class="n">record_full_arg</span><span class="p">,</span>
            <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">,</span>
            <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
            <span class="c1"># num_replicates is excluded as provenance is per replicate</span>
            <span class="c1"># replicate index is excluded as it is inserted for each replicate</span>
        <span class="p">)</span>
        <span class="n">provenance_dict</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mutation_generator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This error was added in version 0.6.1.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;mutation_generator is not longer supported. Please use &quot;</span>
            <span class="s2">&quot;msprime.mutate instead&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">mutation_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># There is ambiguity in how we should throw mutations onto partially</span>
        <span class="c1"># built tree sequences: on the whole thing, or must the newly added</span>
        <span class="c1"># topology? Before or after start_time? We avoid this complexity by</span>
        <span class="c1"># asking the user to use mutate(), which should have the required</span>
        <span class="c1"># flexibility.</span>
        <span class="k">if</span> <span class="n">from_ts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify mutation rate combined with from_ts. Please use &quot;</span>
                <span class="s2">&quot;msprime.mutate on the final tree sequence instead&quot;</span>
            <span class="p">)</span>
        <span class="c1"># There is ambiguity in how the start_time argument should interact with</span>
        <span class="c1"># the mutation generator: should we throw mutations down on the whole</span>
        <span class="c1"># tree or just the (partial) edges after start_time? To avoid complicating</span>
        <span class="c1"># things here, make the user use mutate() which should have the flexibility</span>
        <span class="c1"># to do whatever is needed.</span>
        <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify mutation rate combined with a non-zero &quot;</span>
                <span class="s2">&quot;start_time. Please use msprime.mutate on the returned &quot;</span>
                <span class="s2">&quot;tree sequence instead&quot;</span>
            <span class="p">)</span>
        <span class="n">mutation_rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">mutation_rate</span><span class="p">)</span>

    <span class="n">sim</span> <span class="o">=</span> <span class="n">_parse_simulate</span><span class="p">(</span>
        <span class="n">sample_size</span><span class="o">=</span><span class="n">sample_size</span><span class="p">,</span>
        <span class="n">Ne</span><span class="o">=</span><span class="n">Ne</span><span class="p">,</span>
        <span class="n">length</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
        <span class="n">recombination_map</span><span class="o">=</span><span class="n">recombination_map</span><span class="p">,</span>
        <span class="n">population_configurations</span><span class="o">=</span><span class="n">population_configurations</span><span class="p">,</span>
        <span class="n">migration_matrix</span><span class="o">=</span><span class="n">migration_matrix</span><span class="p">,</span>
        <span class="n">demographic_events</span><span class="o">=</span><span class="n">demographic_events</span><span class="p">,</span>
        <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="n">record_migrations</span><span class="o">=</span><span class="n">record_migrations</span><span class="p">,</span>
        <span class="n">from_ts</span><span class="o">=</span><span class="n">from_ts</span><span class="p">,</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
        <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span><span class="p">,</span>
        <span class="n">record_full_arg</span><span class="o">=</span><span class="n">record_full_arg</span><span class="p">,</span>
        <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">_wrap_replicates</span><span class="p">(</span>
        <span class="n">sim</span><span class="p">,</span>
        <span class="n">num_replicates</span><span class="o">=</span><span class="n">num_replicates</span><span class="p">,</span>
        <span class="n">replicate_index</span><span class="o">=</span><span class="n">replicate_index</span><span class="p">,</span>
        <span class="n">provenance_dict</span><span class="o">=</span><span class="n">provenance_dict</span><span class="p">,</span>
        <span class="n">mutation_rate</span><span class="o">=</span><span class="n">mutation_rate</span><span class="p">,</span>
    <span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_wrap_replicates</span><span class="p">(</span>
    <span class="n">simulator</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">num_replicates</span><span class="p">,</span>
    <span class="n">replicate_index</span><span class="p">,</span>
    <span class="n">provenance_dict</span><span class="p">,</span>
    <span class="n">mutation_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for the logic used to run replicate simulations for the two</span>
<span class="sd">    frontends.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num_replicates</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">replicate_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Default single-replicate case.</span>
        <span class="n">replicate_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">replicate_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_replicates</span> <span class="o">=</span> <span class="n">replicate_index</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">iterator</span> <span class="o">=</span> <span class="n">simulator</span><span class="o">.</span><span class="n">run_replicates</span><span class="p">(</span>
        <span class="n">num_replicates</span><span class="p">,</span>
        <span class="n">mutation_rate</span><span class="o">=</span><span class="n">mutation_rate</span><span class="p">,</span>
        <span class="n">provenance_dict</span><span class="o">=</span><span class="n">provenance_dict</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">replicate_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">deque</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">iterator</span><span class="p">,</span> <span class="n">maxlen</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">deque</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">iterator</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_rate_map</span><span class="p">(</span><span class="n">rate_param</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified input rate parameter value into a rate map.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: in the future we might have another clause here where we</span>
    <span class="c1"># allow for a different  map per population. This could be</span>
    <span class="c1"># accepted as either a list of N rate maps, or a dictionary mapping</span>
    <span class="c1"># population names to maps.</span>
    <span class="c1"># See https://github.com/tskit-dev/msprime/issues/1095</span>

    <span class="n">msg_head</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Error in parsing rate map for </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: &quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rate_param</span><span class="p">,</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="p">):</span>
        <span class="n">rate_map</span> <span class="o">=</span> <span class="n">rate_param</span>
        <span class="k">if</span> <span class="n">rate_map</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg_head</span> <span class="o">+</span> <span class="s2">&quot;sequence_length must match&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rate_param</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">rate_param</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">rate_param</span><span class="p">)</span>
        <span class="n">rate_map</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">,</span> <span class="n">rate_param</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rate_map</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_insert_sample_sets</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">,</span> <span class="n">demography</span><span class="p">,</span> <span class="n">default_ploidy</span><span class="p">,</span> <span class="n">tables</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insert the samples described in the specified {population_id: num_samples}</span>
<span class="sd">    map into the specified set of tables.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">sample_set</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">sample_set</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="n">population</span> <span class="o">=</span> <span class="n">demography</span><span class="p">[</span><span class="n">sample_set</span><span class="o">.</span><span class="n">population</span><span class="p">]</span>
        <span class="n">time</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">population</span><span class="o">.</span><span class="n">default_sampling_time</span>
            <span class="k">if</span> <span class="n">sample_set</span><span class="o">.</span><span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">sample_set</span><span class="o">.</span><span class="n">time</span>
        <span class="p">)</span>
        <span class="n">ploidy</span> <span class="o">=</span> <span class="n">default_ploidy</span> <span class="k">if</span> <span class="n">sample_set</span><span class="o">.</span><span class="n">ploidy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sample_set</span><span class="o">.</span><span class="n">ploidy</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Sampling </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> individuals with ploidy </span><span class="si">{</span><span class="n">ploidy</span><span class="si">}</span><span class="s2"> in population &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">population</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> (name=&#39;</span><span class="si">{</span><span class="n">population</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;) at time </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">node_individual</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">ploidy</span>
        <span class="p">)</span>
        <span class="n">ind_flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="o">.</span><span class="n">append_columns</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">ind_flags</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">ploidy</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append_columns</span><span class="p">(</span>
            <span class="n">flags</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">),</span>
            <span class="n">time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">time</span><span class="p">),</span>
            <span class="n">population</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">population</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">individual</span><span class="o">=</span><span class="n">node_individual</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_sample_sets</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">,</span> <span class="n">demography</span><span class="p">):</span>
    <span class="c1"># Don&#39;t modify the inputs.</span>
    <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">sample_set</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_set</span><span class="p">,</span> <span class="n">SampleSet</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;msprime.SampleSet object required&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">isinteger</span><span class="p">(</span><span class="n">sample_set</span><span class="o">.</span><span class="n">num_samples</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;The number of samples to draw from a population must be an integer&quot;</span>
            <span class="p">)</span>
        <span class="n">sample_set</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_set</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sample_set</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of samples cannot be negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sample_set</span><span class="o">.</span><span class="n">population</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">demography</span><span class="o">.</span><span class="n">num_populations</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sample_set</span><span class="o">.</span><span class="n">population</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Must specify a SampleSet population in multipopulation models&quot;</span>
                <span class="p">)</span>

    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sample_set</span><span class="o">.</span><span class="n">num_samples</span> <span class="k">for</span> <span class="n">sample_set</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Zero samples specified&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sample_sets</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_samples</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">demography</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified &quot;samples&quot; value for sim_ancestry and return the equivalent</span>
<span class="sd">    list of SampleSet instances.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
        <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">samples</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
        <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">SampleSet</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">population</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">population</span><span class="p">,</span> <span class="n">num_samples</span> <span class="ow">in</span> <span class="n">samples</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">]</span>
    <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">isinteger</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">demography</span><span class="o">.</span><span class="n">num_populations</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Numeric samples can only be used in single population models. &quot;</span>
                <span class="s2">&quot;Please use either the mapping form {pop_id: num_samples} or &quot;</span>
                <span class="s2">&quot;a list of SampleSet instances.&quot;</span>
            <span class="p">)</span>
        <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">SampleSet</span><span class="p">(</span><span class="n">samples</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The value &#39;</span><span class="si">{</span><span class="n">samples</span><span class="si">}</span><span class="s2">&#39; cannot be interpreted as sample specification. &quot;</span>
            <span class="s2">&quot;Samples must either be a single integer, a dict that maps populations &quot;</span>
            <span class="s2">&quot;to the number of samples for that population, or a list of SampleSet &quot;</span>
            <span class="s2">&quot;objects. Please see the online documentation for more details on &quot;</span>
            <span class="s2">&quot;the different forms.&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">_parse_sample_sets</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">,</span> <span class="n">demography</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gene_conversion_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">discrete_genome</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">population_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">demography</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ploidy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_migrations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_full_arg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">coalescing_segments_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">stop_at_local_mrca</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">init_for_debugger</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Argument parser for the sim_ancestry frontend. Interprets all the parameters</span>
<span class="sd">    and returns an appropriate instance of Simulator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># As a general rule we try to cast any input value to the required types</span>
    <span class="c1"># early and in a way that provides an interpretable traceback.</span>

    <span class="c1"># Simple defaults.</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">end_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">end_time</span><span class="p">)</span>
    <span class="n">discrete_genome</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">_parse_flag</span><span class="p">(</span><span class="n">discrete_genome</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">record_full_arg</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">_parse_flag</span><span class="p">(</span><span class="n">record_full_arg</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">models</span> <span class="o">=</span> <span class="n">_parse_model_arg</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="n">is_dtwf</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">models</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DiscreteTimeWrightFisher</span><span class="p">)</span>
    <span class="n">is_pedigree</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">FixedPedigree</span><span class="p">)</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">)</span>
    <span class="n">is_smck</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">SMCK</span><span class="p">)</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_smck</span> <span class="ow">and</span> <span class="n">gene_conversion_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Gene conversion is not supported for the SMCK model. &quot;</span>
            <span class="s2">&quot;Please refer to issue #2399 on GitHub for details.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">record_full_arg</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">coalescing_segments_only</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot set both coalescing_segments_only and record_full_arg.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">additional_nodes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot set both record_full_arg and additional_nodes.&quot;</span><span class="p">)</span>
        <span class="n">coalescing_segments_only</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">is_dtwf</span> <span class="ow">or</span> <span class="n">is_pedigree</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Full ARG recording not supported in FixedPedigree and DTWF simulation&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">additional_nodes</span> <span class="o">=</span> <span class="n">NodeType</span><span class="p">(</span>
                <span class="n">NodeType</span><span class="o">.</span><span class="n">RECOMBINANT</span>
                <span class="o">|</span> <span class="n">NodeType</span><span class="o">.</span><span class="n">COMMON_ANCESTOR</span>
                <span class="o">|</span> <span class="n">NodeType</span><span class="o">.</span><span class="n">MIGRANT</span>
                <span class="o">|</span> <span class="n">NodeType</span><span class="o">.</span><span class="n">GENE_CONVERSION</span>
            <span class="p">)</span>
    <span class="n">coalescing_segments_only</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">_parse_flag</span><span class="p">(</span><span class="n">coalescing_segments_only</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">additional_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">additional_nodes</span> <span class="o">=</span> <span class="n">NodeType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">additional_nodes</span><span class="p">,</span> <span class="n">NodeType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;additional_nodes should be an instance of msprime.NodeType.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">additional_nodes</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coalescing_segments_only</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Set coalescing_segments_only to False when recording&quot;</span>
                    <span class="s2">&quot; additional_nodes.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">additional_nodes</span><span class="o">.</span><span class="n">value</span> <span class="o">&amp;</span> <span class="n">NodeType</span><span class="o">.</span><span class="n">MIGRANT</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_dtwf</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Recording MIGRANT nodes is currently not supported in&quot;</span>
                    <span class="s2">&quot; DTWF simulation.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">is_pedigree</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Recording MIGRANT nodes is not supported in &quot;</span>
                    <span class="s2">&quot;FixedPedigree simulation.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">SweepGenicSelection</span><span class="p">)</span> <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Recording MIGRANT nodes is not supported in &quot;</span>
                    <span class="s2">&quot;SweepGenicSelection simulation.&quot;</span>
                <span class="p">)</span>

    <span class="n">record_migrations</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">_parse_flag</span><span class="p">(</span><span class="n">record_migrations</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TreeSequence</span><span class="p">):</span>
            <span class="n">initial_state</span> <span class="o">=</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">initial_state</span><span class="p">,</span> <span class="p">(</span><span class="n">tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">,</span> <span class="n">tskit</span><span class="o">.</span><span class="n">ImmutableTableCollection</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;initial_state must either be a TreeSequence or TableCollection instance&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">time_units</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TIME_UNITS_UNCALIBRATED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot use a tree sequence with uncalibrated time_units as &quot;</span>
                <span class="s2">&quot;the initial state&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">time_units</span> <span class="o">!=</span> <span class="n">TIME_UNITS_GENERATIONS</span><span class="p">:</span>
            <span class="n">message</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The initial_state has time_units=</span><span class="si">{</span><span class="n">initial_state</span><span class="o">.</span><span class="n">time_units</span><span class="si">}</span><span class="s2"> but &quot;</span>
                <span class="s2">&quot;time is measured in generations in msprime. This may lead to &quot;</span>
                <span class="s2">&quot;significant discrepancies between the timescales. &quot;</span>
                <span class="s2">&quot;If you wish to suppress this warning, you can use, e.g., &quot;</span>
                <span class="s2">&quot;warnings.simplefilter(&#39;ignore&#39;, msprime.TimeUnitsMismatchWarning)&quot;</span>
            <span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">TimeUnitsMismatchWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sequence_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># These are all the cases in which we derive the sequence_length</span>
        <span class="c1"># from somewhere else.</span>
        <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sequence_length</span> <span class="o">=</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="k">elif</span> <span class="n">recombination_rate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gene_conversion_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># In this case, we&#39;re doing single-locus simulations, so a sequence</span>
            <span class="c1"># length of 1 makes sense.</span>
            <span class="n">sequence_length</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recombination_rate</span><span class="p">,</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="p">):</span>
            <span class="n">sequence_length</span> <span class="o">=</span> <span class="n">recombination_rate</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gene_conversion_rate</span><span class="p">,</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="p">):</span>
            <span class="n">sequence_length</span> <span class="o">=</span> <span class="n">gene_conversion_rate</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;A sequence_length value must be specified. This can be either &quot;</span>
                <span class="s2">&quot;via the the sequence_length parameter itself, of implicitly &quot;</span>
                <span class="s2">&quot;through using a RateMap instance for the recombination_rate &quot;</span>
                <span class="s2">&quot;or gene_conversion_rate parameters, or via the initial_state &quot;</span>
                <span class="s2">&quot;tables. &quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sequence_length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">sequence_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">discrete_genome</span> <span class="ow">and</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sequence_length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have integer sequence length with discrete_genome=True&quot;</span><span class="p">)</span>

    <span class="n">recombination_map</span> <span class="o">=</span> <span class="n">_parse_rate_map</span><span class="p">(</span>
        <span class="n">recombination_rate</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">,</span> <span class="s2">&quot;recombination&quot;</span>
    <span class="p">)</span>
    <span class="n">gene_conversion_map</span> <span class="o">=</span> <span class="n">_parse_rate_map</span><span class="p">(</span>
        <span class="n">gene_conversion_rate</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">,</span> <span class="s2">&quot;gene conversion&quot;</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">gene_conversion_tract_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gene_conversion_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># It doesn&#39;t matter what the tract_length is, just set a</span>
            <span class="c1"># value to keep the low-level code happy.</span>
            <span class="n">gene_conversion_tract_length</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must specify tract length when simulating gene conversion&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gene_conversion_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must specify gene conversion rate along with tract length&quot;</span>
            <span class="p">)</span>
        <span class="n">gene_conversion_tract_length</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">gene_conversion_tract_length</span><span class="p">)</span>

    <span class="c1"># Default to diploid</span>
    <span class="n">ploidy</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">ploidy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ploidy</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">isinteger</span><span class="p">(</span><span class="n">ploidy</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;ploidy must be an integer&quot;</span><span class="p">)</span>
    <span class="n">ploidy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ploidy</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ploidy</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ploidy must be &gt;= 1&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_pedigree</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">demography</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify demography for FixedPedigree simulation&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">population_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify population_size for FixedPedigree simulation&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Must specify an input pedigree using the ``initial_state`` argument &quot;</span>
                <span class="s2">&quot;for a FixedPedigree simulation&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">ploidy</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Fixed pedigree simulations must have ploidy=2&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gene_conversion_map</span><span class="o">.</span><span class="n">total_mass</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Gene conversion not supported in FixedPedigree simulation&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">record_migrations</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Migration recording not supported in FixedPedigree simulation&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">start_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify start_time in FixedPedigree simulation&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">models</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot use FixedPedigree simulation in conjunction with other models&quot;</span>
            <span class="p">)</span>
        <span class="n">demography</span> <span class="o">=</span> <span class="n">demog</span><span class="o">.</span><span class="n">Demography</span><span class="o">.</span><span class="n">from_tree_sequence</span><span class="p">(</span>
            <span class="n">initial_state</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">(),</span> <span class="n">initial_size</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

    <span class="c1"># Check the demography. If no demography is specified, we default to a</span>
    <span class="c1"># single-population model with a given population size.</span>
    <span class="k">if</span> <span class="n">demography</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_dtwf</span><span class="p">:</span>
            <span class="c1"># A default size of 1 isn&#39;t so smart for DTWF and almost certainly</span>
            <span class="c1"># an error.</span>
            <span class="k">if</span> <span class="n">population_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;When using the DTWF model, the population size must be set &quot;</span>
                    <span class="s2">&quot;explicitly, either using the population_size or demography &quot;</span>
                    <span class="s2">&quot;arguments.&quot;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">population_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Must specify either a demography object or a population_size &quot;</span>
                    <span class="s2">&quot;(for single population models) when providing an initial_state.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_state</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Must specify demography for initial_state with &gt; 1 population&quot;</span>
                <span class="p">)</span>
        <span class="n">population_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">population_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">population_size</span><span class="p">)</span>
        <span class="n">demography</span> <span class="o">=</span> <span class="n">demog</span><span class="o">.</span><span class="n">Demography</span><span class="o">.</span><span class="n">isolated_model</span><span class="p">([</span><span class="n">population_size</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">demography</span><span class="p">,</span> <span class="n">demog</span><span class="o">.</span><span class="n">Demography</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">population_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify demography and population size&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;demography argument must be an instance of msprime.Demography&quot;</span><span class="p">)</span>
    <span class="n">demography</span> <span class="o">=</span> <span class="n">demography</span><span class="o">.</span><span class="n">validate</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">initial_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">init_for_debugger</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Either the samples or initial_state arguments must be provided&quot;</span>
            <span class="p">)</span>
        <span class="n">initial_state</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">)</span>
        <span class="n">initial_state</span><span class="o">.</span><span class="n">time_units</span> <span class="o">=</span> <span class="n">TIME_UNITS_GENERATIONS</span>
        <span class="n">demography</span><span class="o">.</span><span class="n">insert_populations</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">init_for_debugger</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">_parse_samples</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">demography</span><span class="p">)</span>
            <span class="n">_insert_sample_sets</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">,</span> <span class="n">demography</span><span class="p">,</span> <span class="n">ploidy</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both samples and initial_state&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">initial_state</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The initial_state sequence length must be consistent with the&quot;</span>
                <span class="s2">&quot;value derived from either the sequence_length, &quot;</span>
                <span class="s2">&quot;recombination_rate or gene_conversion_rate parameters.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_state</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;initial_state tables must define at least one population.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Make sure the names match-up in the input demography.</span>
        <span class="n">demography_check</span> <span class="o">=</span> <span class="n">demog</span><span class="o">.</span><span class="n">Demography</span><span class="o">.</span><span class="n">from_tree_sequence</span><span class="p">(</span>
            <span class="n">initial_state</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">demography</span><span class="o">.</span><span class="n">num_populations</span> <span class="o">&lt;</span> <span class="n">demography_check</span><span class="o">.</span><span class="n">num_populations</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Input demography must have at least as many populations as the &quot;</span>
                <span class="s2">&quot;initial state population table: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">demography</span><span class="o">.</span><span class="n">num_populations</span><span class="si">}</span><span class="s2"> &lt; </span><span class="si">{</span><span class="n">demography_check</span><span class="o">.</span><span class="n">num_populations</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">pop1</span><span class="p">,</span> <span class="n">pop2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">demography</span><span class="o">.</span><span class="n">populations</span><span class="p">,</span> <span class="n">demography_check</span><span class="o">.</span><span class="n">populations</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pop1</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">pop2</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Population names in the input demography and the initial &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;state population table must be equal: </span><span class="si">{</span><span class="n">pop1</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">pop2</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="n">demography</span><span class="o">.</span><span class="n">insert_extra_populations</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>

    <span class="c1"># It&#39;s useful to call _parse_sim_ancestry outside the context of the main</span>
    <span class="c1"># entry point - so we want to get good seeds in this case too.</span>
    <span class="n">random_seed</span> <span class="o">=</span> <span class="n">_parse_random_seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="n">random_generator</span> <span class="o">=</span> <span class="n">_msprime</span><span class="o">.</span><span class="n">RandomGenerator</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">stop_at_local_mrca</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stop_at_local_mrca</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">Simulator</span><span class="p">(</span>
        <span class="n">tables</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
        <span class="n">recombination_map</span><span class="o">=</span><span class="n">recombination_map</span><span class="p">,</span>
        <span class="n">gene_conversion_map</span><span class="o">=</span><span class="n">gene_conversion_map</span><span class="p">,</span>
        <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="n">gene_conversion_tract_length</span><span class="p">,</span>
        <span class="n">discrete_genome</span><span class="o">=</span><span class="n">discrete_genome</span><span class="p">,</span>
        <span class="n">ploidy</span><span class="o">=</span><span class="n">ploidy</span><span class="p">,</span>
        <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
        <span class="n">models</span><span class="o">=</span><span class="n">models</span><span class="p">,</span>
        <span class="n">store_migrations</span><span class="o">=</span><span class="n">record_migrations</span><span class="p">,</span>
        <span class="n">additional_nodes</span><span class="o">=</span><span class="n">additional_nodes</span><span class="p">,</span>
        <span class="n">coalescing_segments_only</span><span class="o">=</span><span class="n">coalescing_segments_only</span><span class="p">,</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
        <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span><span class="p">,</span>
        <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">,</span>
        <span class="n">random_generator</span><span class="o">=</span><span class="n">random_generator</span><span class="p">,</span>
        <span class="n">stop_at_local_mrca</span><span class="o">=</span><span class="n">stop_at_local_mrca</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="sim_ancestry">
<a class="viewcode-back" href="../../api.html#msprime.sim_ancestry">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sim_ancestry</span><span class="p">(</span>
    <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">demography</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">discrete_genome</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gene_conversion_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">population_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">ploidy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">initial_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_migrations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_full_arg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">coalescing_segments_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_replicates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">replicate_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">stop_at_local_mrca</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates an ancestral process described by the specified model, demography and</span>
<span class="sd">    samples, and return a :class:`tskit.TreeSequence` (or a sequence of</span>
<span class="sd">    replicate tree sequences).</span>

<span class="sd">    :param samples: The sampled individuals as either an integer, specifying</span>
<span class="sd">        the number of individuals to sample in a single-population model;</span>
<span class="sd">        or a list of :class:`.SampleSet` objects defining the properties of</span>
<span class="sd">        groups of similar samples; or as a mapping in which the keys</span>
<span class="sd">        are population identifiers (either an integer ID or string name)</span>
<span class="sd">        and the values are the number of samples to take from the corresponding</span>
<span class="sd">        population at its default sampling time. It is important to note that</span>
<span class="sd">        samples correspond to *individuals* here, and each sampled individual</span>
<span class="sd">        is usually associated with :math:`k` sample *nodes* (or genomes) when</span>
<span class="sd">        ``ploidy`` = :math:`k`. See the :ref:`sec_ancestry_samples` section</span>
<span class="sd">        for further details.</span>
<span class="sd">        Either ``samples`` or ``initial_state`` must be specified.</span>
<span class="sd">    :param demography: The demographic model to simulate, describing the</span>
<span class="sd">        extant and ancestral populations, their population sizes and growth</span>
<span class="sd">        rates, their migration rates, and demographic events affecting the</span>
<span class="sd">        populations over time. See the :ref:`sec_demography` section for</span>
<span class="sd">        details on how to specify demographic models and</span>
<span class="sd">        :ref:`sec_ancestry_samples` for details on how to specify the</span>
<span class="sd">        populations that samples are drawn from. If not specified (or None) we</span>
<span class="sd">        default to a single population with constant size 1</span>
<span class="sd">        (see also the ``population_size`` parameter).</span>
<span class="sd">    :param int ploidy: The number of monoploid genomes per sample individual</span>
<span class="sd">        (Default=2). See the :ref:`sec_ancestry_ploidy` section for usage examples.</span>
<span class="sd">    :param float sequence_length: The length of the genome sequence to simulate.</span>
<span class="sd">        See the :ref:`sec_ancestry_sequence_length` section for usage examples</span>
<span class="sd">        for this parameter and how it interacts with other parameters.</span>
<span class="sd">    :param bool discrete_genome: If True (the default) simulation occurs</span>
<span class="sd">        in discrete genome coordinates such that recombination and</span>
<span class="sd">        gene conversion breakpoints always occur at integer positions.</span>
<span class="sd">        Thus, multiple (e.g.) recombinations can occur at the same</span>
<span class="sd">        genome position. If ``discrete_genome`` is False simulations</span>
<span class="sd">        are performed using continuous genome coordinates. In this</span>
<span class="sd">        case multiple events at precisely the same genome location are very</span>
<span class="sd">        unlikely (but technically possible).</span>
<span class="sd">        See the :ref:`sec_ancestry_discrete_genome` section for usage examples.</span>
<span class="sd">    :param recombination_rate: The rate of recombination along the sequence;</span>
<span class="sd">        can be either a single value (specifying a single rate over the entire</span>
<span class="sd">        sequence) or an instance of :class:`RateMap`.</span>
<span class="sd">        See the :ref:`sec_ancestry_recombination` section for usage examples</span>
<span class="sd">        for this parameter and how it interacts with other parameters.</span>
<span class="sd">    :param gene_conversion_rate: The rate of gene conversion along the sequence.</span>
<span class="sd">        If provided, a value for ``gene_conversion_tract_length`` must also be</span>
<span class="sd">        specified. See the :ref:`sec_ancestry_gene_conversion` section</span>
<span class="sd">        for usage examples for this parameter and how it interacts with</span>
<span class="sd">        other parameters.</span>
<span class="sd">    :param gene_conversion_tract_length: The mean length of the gene conversion</span>
<span class="sd">        tracts. For discrete genomes the tract lengths are geometrically</span>
<span class="sd">        distributed with mean ``gene_conversion_tract_length``, which must be</span>
<span class="sd">        greater than or equal to 1. For continuous genomes the tract lengths are</span>
<span class="sd">        exponentially distributed with mean ``gene_conversion_tract_length``,</span>
<span class="sd">        which must be larger than 0.</span>
<span class="sd">    :param population_size: The number of individuals of the default single population</span>
<span class="sd">        :class:`.Demography`. If not specified, defaults to 1. Cannot be specified</span>
<span class="sd">        along with the ``demography`` parameter. See the :ref:`sec_demography`</span>
<span class="sd">        section for more details on demographic models and population sizes</span>
<span class="sd">        and the :ref:`sec_ancestry_demography` section for usage examples.</span>
<span class="sd">    :param int random_seed: The random seed. If this is not specified or `None`,</span>
<span class="sd">        a high-quality random seed will be automatically generated. Valid random</span>
<span class="sd">        seeds must be between 1 and :math:`2^{32} - 1`.</span>
<span class="sd">        See the :ref:`sec_randomness_seeds` section for usage examples.</span>
<span class="sd">    :param int num_replicates: The number of replicates of the specified</span>
<span class="sd">        parameters to simulate. If this is not specified or `None`,</span>
<span class="sd">        no replication is performed and a :class:`tskit.TreeSequence` object</span>
<span class="sd">        returned. If `num_replicates` is provided, the specified</span>
<span class="sd">        number of replicates is performed, and an iterator over the</span>
<span class="sd">        resulting :class:`tskit.TreeSequence` objects returned.</span>
<span class="sd">        See the :ref:`sec_randomness_replication` section for examples.</span>
<span class="sd">    :param bool record_full_arg: If True, record all intermediate nodes</span>
<span class="sd">        arising from common ancestor and recombination events in the output</span>
<span class="sd">        tree sequence. This will result in unary nodes (i.e., nodes in marginal</span>
<span class="sd">        trees that have only one child). Defaults to False.</span>
<span class="sd">        See the :ref:`sec_ancestry_full_arg` section for examples.</span>
<span class="sd">    :param NodeType additional_nodes: Retain all ancestry for any node</span>
<span class="sd">        of the specified type. This will result in unary nodes.</span>
<span class="sd">        Defaults to class `msprime.NodeType(0)`.</span>
<span class="sd">    :param bool coalescing_segments_only: If False, retain all ancestry for any</span>
<span class="sd">        nodes that are coalescent nodes anywhere in the sequence. This will result in</span>
<span class="sd">        unary nodes. Should be set to False when :ref:`recording additional nodes</span>
<span class="sd">        &lt;sec_ancestry_additional_nodes&gt;`. Defaults to True.</span>
<span class="sd">    :param bool record_migrations: If True, record all migration events</span>
<span class="sd">        that occur in the :ref:`tskit:sec_migration_table_definition` of</span>
<span class="sd">        the output tree sequence. Defaults to False.</span>
<span class="sd">        See the :ref:`sec_ancestry_record_migrations` section for examples.</span>
<span class="sd">    :param tskit.TreeSequence initial_state: If specified, initialise the</span>
<span class="sd">        simulation from the root segments of this tree sequence and return the</span>
<span class="sd">        completed tree sequence. Please see</span>
<span class="sd">        :ref:`sec_ancestry_initial_state` for details of the required</span>
<span class="sd">        properties of this tree sequence and its interactions with other parameters.</span>
<span class="sd">        All information in the ``initial_state`` tables is preserved</span>
<span class="sd">        (including metadata) and included in the returned tree sequence.</span>
<span class="sd">        (Default: None).</span>
<span class="sd">    :param float start_time: If specified, set the initial time that the</span>
<span class="sd">        simulation starts to this value. If not specified, the start</span>
<span class="sd">        time is zero. See the :ref:`sec_ancestry_start_time` section for examples.</span>
<span class="sd">    :param float end_time: If specified, terminate the simulation at the</span>
<span class="sd">        specified time. In the returned tree sequence, all rootward paths from</span>
<span class="sd">        samples with time &lt; ``end_time`` will end in a node with one child with</span>
<span class="sd">        time equal to end_time. Any sample nodes with time &gt;= ``end_time`` will</span>
<span class="sd">        also be present in the output tree sequence. If not specified or ``None``,</span>
<span class="sd">        run the simulation until all samples have an MRCA at all positions in</span>
<span class="sd">        the genome. See the :ref:`sec_ancestry_end_time` section for examples.</span>
<span class="sd">    :param bool record_provenance: If True (the default), record all input</span>
<span class="sd">        parameters in the tree sequence :ref:`tskit:sec_provenance`.</span>
<span class="sd">    :param model: The ancestry model to use. This can be either a</span>
<span class="sd">        single instance of :class:`.AncestryModel` (or a string that can be</span>
<span class="sd">        interpreted as an ancestry model), or a list of :class:`.AncestryModel`</span>
<span class="sd">        instances. If the ``duration`` attribute of any of these models is</span>
<span class="sd">        set, the simulation will be run until at most :math:`t + t_m`, where</span>
<span class="sd">        :math:`t` is the simulation time when the model starts and :math:`t_m`</span>
<span class="sd">        is the model&#39;s ``duration``. If the ``duration`` is not set, the</span>
<span class="sd">        simulation will continue until the model completes, the overall</span>
<span class="sd">        ``end_time`` is reached, or overall coalescence. See</span>
<span class="sd">        the :ref:`sec_ancestry_models_specifying` section for more details,</span>
<span class="sd">        and the :ref:`sec_ancestry_models` section for the available models</span>
<span class="sd">        and examples.</span>
<span class="sd">    :param stop_at_local_mrca: If True (the default), the simulation will stop for a</span>
<span class="sd">        tree when local MRCA is reached. If False, simulations will continue across</span>
<span class="sd">        the full sequence until an MRCA has been found on all segments (except</span>
<span class="sd">        for the FixedPedigree model, which will continue simulation until all</span>
<span class="sd">        individuals have been processed). With this option, all trees will have</span>
<span class="sd">        a root at the same time as the oldest local MRCA, with nodes marking</span>
<span class="sd">        distinct segments of ancestry. See :ref:`sec_ancestry_stop_at_local_mrca`</span>
<span class="sd">        for more information.</span>
<span class="sd">    :type model: str or msprime.AncestryModel or list</span>
<span class="sd">    :return: The :class:`tskit.TreeSequence` object representing the results</span>
<span class="sd">        of the simulation if no replication is performed, or an</span>
<span class="sd">        iterator over the independent replicates simulated if the</span>
<span class="sd">        `num_replicates` parameter has been used.</span>
<span class="sd">    :rtype: :class:`tskit.TreeSequence` or an iterator over</span>
<span class="sd">        :class:`tskit.TreeSequence` replicates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">record_provenance</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">record_provenance</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">record_provenance</span>
    <span class="n">replicate_index</span> <span class="o">=</span> <span class="n">_parse_replicate_index</span><span class="p">(</span>
        <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
        <span class="n">num_replicates</span><span class="o">=</span><span class="n">num_replicates</span><span class="p">,</span>
        <span class="n">replicate_index</span><span class="o">=</span><span class="n">replicate_index</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">random_seed</span> <span class="o">=</span> <span class="n">_parse_random_seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
    <span class="n">provenance_dict</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">command</span><span class="o">=</span><span class="s2">&quot;sim_ancestry&quot;</span><span class="p">,</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
            <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
            <span class="n">sequence_length</span><span class="o">=</span><span class="n">sequence_length</span><span class="p">,</span>
            <span class="n">discrete_genome</span><span class="o">=</span><span class="n">discrete_genome</span><span class="p">,</span>
            <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
            <span class="n">gene_conversion_rate</span><span class="o">=</span><span class="n">gene_conversion_rate</span><span class="p">,</span>
            <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="n">gene_conversion_tract_length</span><span class="p">,</span>
            <span class="n">population_size</span><span class="o">=</span><span class="n">population_size</span><span class="p">,</span>
            <span class="n">ploidy</span><span class="o">=</span><span class="n">ploidy</span><span class="p">,</span>
            <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
            <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span><span class="p">,</span>
            <span class="n">record_migrations</span><span class="o">=</span><span class="n">record_migrations</span><span class="p">,</span>
            <span class="n">record_full_arg</span><span class="o">=</span><span class="n">record_full_arg</span><span class="p">,</span>
            <span class="n">additional_nodes</span><span class="o">=</span><span class="n">additional_nodes</span><span class="p">,</span>
            <span class="n">coalescing_segments_only</span><span class="o">=</span><span class="n">coalescing_segments_only</span><span class="p">,</span>
            <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">,</span>
            <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
            <span class="n">stop_at_local_mrca</span><span class="o">=</span><span class="n">stop_at_local_mrca</span><span class="p">,</span>
            <span class="c1"># num_replicates is excluded as provenance is per replicate</span>
            <span class="c1"># replicate index is excluded as it is inserted for each replicate</span>
        <span class="p">)</span>
        <span class="n">provenance_dict</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">_parse_sim_ancestry</span><span class="p">(</span>
        <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
        <span class="n">sequence_length</span><span class="o">=</span><span class="n">sequence_length</span><span class="p">,</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
        <span class="n">gene_conversion_rate</span><span class="o">=</span><span class="n">gene_conversion_rate</span><span class="p">,</span>
        <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="n">gene_conversion_tract_length</span><span class="p">,</span>
        <span class="n">discrete_genome</span><span class="o">=</span><span class="n">discrete_genome</span><span class="p">,</span>
        <span class="n">population_size</span><span class="o">=</span><span class="n">population_size</span><span class="p">,</span>
        <span class="n">demography</span><span class="o">=</span><span class="n">demography</span><span class="p">,</span>
        <span class="n">ploidy</span><span class="o">=</span><span class="n">ploidy</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="n">initial_state</span><span class="o">=</span><span class="n">initial_state</span><span class="p">,</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
        <span class="n">end_time</span><span class="o">=</span><span class="n">end_time</span><span class="p">,</span>
        <span class="n">record_migrations</span><span class="o">=</span><span class="n">record_migrations</span><span class="p">,</span>
        <span class="n">record_full_arg</span><span class="o">=</span><span class="n">record_full_arg</span><span class="p">,</span>
        <span class="n">additional_nodes</span><span class="o">=</span><span class="n">additional_nodes</span><span class="p">,</span>
        <span class="n">coalescing_segments_only</span><span class="o">=</span><span class="n">coalescing_segments_only</span><span class="p">,</span>
        <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
        <span class="n">stop_at_local_mrca</span><span class="o">=</span><span class="n">stop_at_local_mrca</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">_wrap_replicates</span><span class="p">(</span>
        <span class="n">sim</span><span class="p">,</span>
        <span class="n">num_replicates</span><span class="o">=</span><span class="n">num_replicates</span><span class="p">,</span>
        <span class="n">replicate_index</span><span class="o">=</span><span class="n">replicate_index</span><span class="p">,</span>
        <span class="n">provenance_dict</span><span class="o">=</span><span class="n">provenance_dict</span><span class="p">,</span>
    <span class="p">)</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">ExitReason</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">IntEnum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The different reasons that the low-level simulation exits.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">MAX_EVENTS</span> <span class="o">=</span> <span class="n">_msprime</span><span class="o">.</span><span class="n">EXIT_MAX_EVENTS</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    We ran for the specified maximum number of events. We usually</span>
<span class="sd">    run for a maximum number of events so that we return to Python</span>
<span class="sd">    regularly, to update logs and to check if CTRL-C has been hit, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">MAX_TIME</span> <span class="o">=</span> <span class="n">_msprime</span><span class="o">.</span><span class="n">EXIT_MAX_TIME</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The simulation is equal to the specified maximum time.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">COALESCENCE</span> <span class="o">=</span> <span class="n">_msprime</span><span class="o">.</span><span class="n">EXIT_COALESCENCE</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The simulation is complete, and we have fully coalesced.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">MODEL_COMPLETE</span> <span class="o">=</span> <span class="n">_msprime</span><span class="o">.</span><span class="n">EXIT_MODEL_COMPLETE</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The model we have specified has run to completion **without**</span>
<span class="sd">    resulting in coalescence.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="NodeType">
<a class="viewcode-back" href="../../api.html#msprime.NodeType">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NodeType</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Flag</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specify the type of node for which you want to track ancestry. Extends</span>
<span class="sd">    the :class:`python:enum.Flag` class. The NodeType can be specified by</span>
<span class="sd">    means of bitwise operators on the members of the enumeration.</span>
<span class="sd">    See :ref:`additional nodes &lt;sec_ancestry_additional_nodes&gt;` for a</span>
<span class="sd">    definition of each of the different node types.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">RECOMBINANT</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span>
    <span class="n">COMMON_ANCESTOR</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">18</span>
    <span class="n">MIGRANT</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">19</span>
    <span class="n">CENSUS</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span>
    <span class="n">GENE_CONVERSION</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">21</span>
    <span class="n">PASS_THROUGH</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">22</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;__class__&quot;</span><span class="p">:</span> <span class="s2">&quot;msprime.NodeType&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">}</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">Simulator</span><span class="p">(</span><span class="n">_msprime</span><span class="o">.</span><span class="n">Simulator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to simulate trees under a variety of population models.</span>

<span class="sd">    Note: this class is not intended to be instantiated directly</span>
<span class="sd">    and is only for internal library use. The interface may change</span>
<span class="sd">    arbitrarily between versions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">tables</span><span class="p">,</span>
        <span class="n">recombination_map</span><span class="p">,</span>
        <span class="n">gene_conversion_map</span><span class="p">,</span>
        <span class="n">gene_conversion_tract_length</span><span class="p">,</span>
        <span class="n">discrete_genome</span><span class="p">,</span>
        <span class="n">ploidy</span><span class="p">,</span>
        <span class="n">demography</span><span class="p">,</span>
        <span class="n">random_generator</span><span class="p">,</span>
        <span class="n">models</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">store_migrations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">additional_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">coalescing_segments_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">start_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">end_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">num_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">stop_at_local_mrca</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># We always need at least n segments, so no point in making</span>
        <span class="c1"># allocation any smaller than this.</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>
        <span class="n">segment_block_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">block_size</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
        <span class="n">avl_node_block_size</span> <span class="o">=</span> <span class="n">block_size</span>
        <span class="n">node_mapping_block_size</span> <span class="o">=</span> <span class="n">block_size</span>

        <span class="k">if</span> <span class="n">num_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_choose_num_labels</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">additional_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">additional_nodes</span> <span class="o">=</span> <span class="n">NodeType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Now, convert the high-level values into their low-level</span>
        <span class="c1"># counterparts.</span>
        <span class="n">ll_population_configuration</span> <span class="o">=</span> <span class="p">[</span><span class="n">pop</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span> <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">demography</span><span class="o">.</span><span class="n">populations</span><span class="p">]</span>
        <span class="n">ll_demographic_events</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">event</span><span class="o">.</span><span class="n">get_ll_representation</span><span class="p">()</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">demography</span><span class="o">.</span><span class="n">events</span>
        <span class="p">]</span>
        <span class="n">ll_recomb_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_missing_intervals</span><span class="p">(</span><span class="n">recombination_map</span><span class="p">)</span>

        <span class="n">ll_tables</span> <span class="o">=</span> <span class="n">_msprime</span><span class="o">.</span><span class="n">LightweightTableCollection</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>
        <span class="n">ll_tables</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span>

        <span class="c1"># FIXME support arbitrary gene conversion maps.</span>
        <span class="c1"># https://github.com/tskit-dev/msprime/issues/1212</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">gene_conversion_map</span><span class="o">.</span><span class="n">rate</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">gene_conversion_rate</span> <span class="o">=</span> <span class="n">gene_conversion_map</span><span class="o">.</span><span class="n">rate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">start_time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">start_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">start_time</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">tables</span><span class="o">=</span><span class="n">ll_tables</span><span class="p">,</span>
            <span class="n">recombination_map</span><span class="o">=</span><span class="n">ll_recomb_map</span><span class="p">,</span>
            <span class="n">start_time</span><span class="o">=</span><span class="n">start_time</span><span class="p">,</span>
            <span class="n">random_generator</span><span class="o">=</span><span class="n">random_generator</span><span class="p">,</span>
            <span class="n">migration_matrix</span><span class="o">=</span><span class="n">demography</span><span class="o">.</span><span class="n">migration_matrix</span><span class="p">,</span>
            <span class="n">population_configuration</span><span class="o">=</span><span class="n">ll_population_configuration</span><span class="p">,</span>
            <span class="n">demographic_events</span><span class="o">=</span><span class="n">ll_demographic_events</span><span class="p">,</span>
            <span class="n">store_migrations</span><span class="o">=</span><span class="n">store_migrations</span><span class="p">,</span>
            <span class="n">additional_nodes</span><span class="o">=</span><span class="n">additional_nodes</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
            <span class="n">coalescing_segments_only</span><span class="o">=</span><span class="n">coalescing_segments_only</span><span class="p">,</span>
            <span class="n">num_labels</span><span class="o">=</span><span class="n">num_labels</span><span class="p">,</span>
            <span class="n">segment_block_size</span><span class="o">=</span><span class="n">segment_block_size</span><span class="p">,</span>
            <span class="n">avl_node_block_size</span><span class="o">=</span><span class="n">avl_node_block_size</span><span class="p">,</span>
            <span class="n">node_mapping_block_size</span><span class="o">=</span><span class="n">node_mapping_block_size</span><span class="p">,</span>
            <span class="n">gene_conversion_rate</span><span class="o">=</span><span class="n">gene_conversion_rate</span><span class="p">,</span>
            <span class="n">gene_conversion_tract_length</span><span class="o">=</span><span class="n">gene_conversion_tract_length</span><span class="p">,</span>
            <span class="n">discrete_genome</span><span class="o">=</span><span class="n">discrete_genome</span><span class="p">,</span>
            <span class="n">ploidy</span><span class="o">=</span><span class="n">ploidy</span><span class="p">,</span>
            <span class="n">stop_at_local_mrca</span><span class="o">=</span><span class="n">stop_at_local_mrca</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Highlevel attributes used externally that have no lowlevel equivalent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">end_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">end_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">models</span> <span class="o">=</span> <span class="n">models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">demography</span> <span class="o">=</span> <span class="n">demography</span>
        <span class="c1"># Temporary, until we add the low-level infrastructure for the gc map</span>
        <span class="c1"># when we&#39;ll take the same approach as the recombination map.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gene_conversion_map</span> <span class="o">=</span> <span class="n">gene_conversion_map</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the underlying table collection. This is useful</span>
<span class="sd">        for testing and avoids using the LightweightTableCollection object,</span>
<span class="sd">        which is returned by self.tables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sample_configuration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of the number of samples in each of the populations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_tables</span><span class="p">()</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">num_samples</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">population</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">num_samples</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">recombination_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">intervals</span><span class="o">.</span><span class="n">RateMap</span><span class="p">(</span><span class="o">**</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">recombination_map</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_choose_num_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">models</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Choose the number of labels appropriately, given the ancestry</span>
<span class="sd">        models that will be simulated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_labels</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">SweepGenicSelection</span><span class="p">):</span>
                <span class="n">num_labels</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">num_labels</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_resolve_missing_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recombination_map</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inspect the recombination map for unknown intervals, resolve</span>
<span class="sd">        the appropriate recombination rate to use in the actual simulation,</span>
<span class="sd">        and return the low-level recombination map representation.</span>

<span class="sd">        Also store the set of missing_intervals for later use in delete_intervals.</span>

<span class="sd">        For now we only support unknown values in the flanking regions,</span>
<span class="sd">        and insist that we can have at most two of them (so, no attempt to</span>
<span class="sd">        coalesce adjacent unknown intervals at the ends of the map).</span>
<span class="sd">        See https://github.com/tskit-dev/msprime/issues/1604 for plans</span>
<span class="sd">        and discussion for how to simulate chromosomes with unknown</span>
<span class="sd">        regions in the middle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_intervals</span> <span class="o">=</span> <span class="n">recombination_map</span><span class="o">.</span><span class="n">missing_intervals</span><span class="p">()</span>
        <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Missing regions of the genome other than the flanks are currently &quot;</span>
            <span class="s2">&quot;not supported. Please see &quot;</span>
            <span class="s2">&quot;https://github.com/tskit-dev/msprime/issues/1604&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_intervals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_intervals</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">right</span> <span class="o">==</span> <span class="n">recombination_map</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>

        <span class="n">ll_recomb_map</span> <span class="o">=</span> <span class="n">recombination_map</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="n">recombination_map</span><span class="o">.</span><span class="n">missing</span>
        <span class="n">rate</span> <span class="o">=</span> <span class="n">recombination_map</span><span class="o">.</span><span class="n">rate</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">rate</span><span class="p">[</span><span class="n">missing</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ll_recomb_map</span><span class="p">[</span><span class="s2">&quot;rate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rate</span>
        <span class="k">return</span> <span class="n">ll_recomb_map</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_run_until</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="n">event_chunk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># This is a pretty big default event chunk so that we don&#39;t spend</span>
        <span class="c1"># too much time going back and forth into Python. We could imagine</span>
        <span class="c1"># doing something a bit more sophisticated where we try to tune the</span>
        <span class="c1"># number of events so that we end up with roughly 10 second slices</span>
        <span class="c1"># (say).</span>
        <span class="k">if</span> <span class="n">event_chunk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">event_chunk</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">4</span>
        <span class="k">if</span> <span class="n">event_chunk</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have at least 1 event per chunk&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Running model </span><span class="si">%s</span><span class="s2"> until max time: </span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">end_time</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ExitReason</span><span class="o">.</span><span class="n">MAX_EVENTS</span>
        <span class="k">while</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">ExitReason</span><span class="o">.</span><span class="n">MAX_EVENTS</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ExitReason</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">event_chunk</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="n">end_time</span><span class="p">:</span>
                <span class="c1"># Currently the Pedigree and Sweeps models are &quot;non-reentrant&quot;</span>
                <span class="c1"># We can change this to an assertion once these have been fixed.</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Model </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> does not support interruption. &quot;</span>
                    <span class="s2">&quot;Please open an issue on GitHub&quot;</span>
                <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;time=</span><span class="si">%g</span><span class="s2"> ancestors=</span><span class="si">%d</span><span class="s2"> ret=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span><span class="p">,</span> <span class="n">ret</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">debug_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">debug_func</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event_chunk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs the simulation until complete coalescence has occurred,</span>
<span class="sd">        end_time has been reached, or all model durations have</span>
<span class="sd">        elapsed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">_as_lowlevel</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;model[</span><span class="si">%d</span><span class="s2">] </span><span class="si">%s</span><span class="s2"> started at time=</span><span class="si">%g</span><span class="s2"> nodes=</span><span class="si">%d</span><span class="s2"> edges=</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">j</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">model_duration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">duration</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">model</span><span class="o">.</span><span class="n">duration</span>
            <span class="k">if</span> <span class="n">model_duration</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Model durations must be &gt;= 0&quot;</span><span class="p">)</span>
            <span class="n">end_time</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="n">model_duration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">)</span>
            <span class="n">exit_reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_until</span><span class="p">(</span><span class="n">end_time</span><span class="p">,</span> <span class="n">event_chunk</span><span class="p">,</span> <span class="n">debug_func</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">exit_reason</span> <span class="o">==</span> <span class="n">ExitReason</span><span class="o">.</span><span class="n">COALESCENCE</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_time</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Skipping remaining </span><span class="si">%d</span><span class="s2"> models&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">models</span><span class="p">)</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalise_tables</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Completed at time=</span><span class="si">%g</span><span class="s2"> nodes=</span><span class="si">%d</span><span class="s2"> edges=</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run_replicates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_replicates</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mutation_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">provenance_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sequentially yield the specified number of simulation replicates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">encoded_provenance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># The JSON is modified for each replicate to insert the replicate number.</span>
        <span class="c1"># To avoid repeatedly encoding the same JSON (which can take milliseconds)</span>
        <span class="c1"># we insert a replaceable string.</span>
        <span class="n">placeholder</span> <span class="o">=</span> <span class="s2">&quot;@@_REPLICATE_INDEX_@@&quot;</span>
        <span class="k">if</span> <span class="n">provenance_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">provenance_dict</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">][</span><span class="s2">&quot;replicate_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">placeholder</span>
            <span class="n">encoded_provenance</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">json_encode_provenance</span><span class="p">(</span>
                <span class="n">provenance_dict</span><span class="p">,</span> <span class="n">num_replicates</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">replicate_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_replicates</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting replicate </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">replicate_index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">mutation_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># This is only called from simulate() or the ms interface,</span>
                <span class="c1"># so does not need any further parameters.</span>
                <span class="n">mutations</span><span class="o">.</span><span class="n">_simple_mutate</span><span class="p">(</span>
                    <span class="n">tables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="p">,</span>
                    <span class="n">random_generator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_generator</span><span class="p">,</span>
                    <span class="n">sequence_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span>
                    <span class="n">rate</span><span class="o">=</span><span class="n">mutation_rate</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">tables</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_intervals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">delete_intervals</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">missing_intervals</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
            <span class="n">replicate_provenance</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">encoded_provenance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">replicate_provenance</span> <span class="o">=</span> <span class="n">encoded_provenance</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">placeholder</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">replicate_index</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">replicate_provenance</span><span class="p">)</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">ts</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Warning! This can be very big as it&#39;s a direct dump of the low-level</span>
        <span class="c1"># data structures. If you want to debug a large simulation use</span>
        <span class="c1"># simulator.print_state(sys.stdout).</span>
        <span class="c1"># It&#39;s also possible to trigger segfault/assertions by calling this on a</span>
        <span class="c1"># simulator that&#39;s in an errored state - so use this method with care!</span>
        <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryFile</span><span class="p">()</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_state</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="k">return</span> <span class="s2">&quot;================</span><span class="se">\n</span><span class="s2">Simulator state:</span><span class="se">\n</span><span class="s2">================</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">s</span>


<div class="viewcode-block" id="SampleSet">
<a class="viewcode-back" href="../../api.html#msprime.SampleSet">[docs]</a>
<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SampleSet</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Specify a set of exchangeable sample individuals with a given ploidy</span>
<span class="sd">    value from a population at a given time. See the</span>
<span class="sd">    :ref:`sec_ancestry_samples` section for details and examples.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">num_samples</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The number of k-ploid sample **individuals** to draw.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">population</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The population in which the samples are drawn. May be either a</span>
<span class="sd">    string name or integer ID (see</span>
<span class="sd">    :ref:`sec_demography_populations_identifiers` details).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The time at which these samples are drawn. If not specified or None,</span>
<span class="sd">    defaults to the :attr:`.Population.default_sampling_time`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ploidy</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The number of monoploid genomes to sample for each sample individual.</span>
<span class="sd">    See the :ref:`sec_ancestry_ploidy` section for more details and</span>
<span class="sd">    examples.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>



<div class="viewcode-block" id="SimulationModelChange">
<a class="viewcode-back" href="../../legacy.html#msprime.SimulationModelChange">[docs]</a>
<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SimulationModelChange</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Demographic event denoting an change in ancestry model.</span>

<span class="sd">    .. important::</span>
<span class="sd">        This class is deprecated (but supported indefinitely);</span>
<span class="sd">        please use the ``model`` argument in :func:`sim_ancestry`</span>
<span class="sd">        to specify multiple models in new code.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The time at which the ancestry model changes to the new model, in</span>
<span class="sd">    generations. After this time, all internal tree nodes, edges and migrations</span>
<span class="sd">    are the result of the new model. If time is set to None (the default), the</span>
<span class="sd">    model change will occur immediately after the previous model has completed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Can&#39;t use typehints here because having a reference to AncestryModel</span>
    <span class="c1"># breaks autodoc, which wants to call it msprime.ancestry.AncestryModel</span>
    <span class="c1"># whereas we have it documented as msprime.AncestryModel. Annoying.</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The new ancestry model to use. This can either be a string (e.g.,</span>
<span class="sd">    ``&quot;smc_prime&quot;``) or an instance of an ancestry model class (e.g,</span>
<span class="sd">    ``msprime.DiscreteTimeWrightFisher()``. Please see the</span>
<span class="sd">    :ref:`sec_ancestry_models` section for more details on specifying these</span>
<span class="sd">    models. If this is None (the default) the model is changed to the standard</span>
<span class="sd">    coalescent.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>



<div class="viewcode-block" id="AncestryModel">
<a class="viewcode-back" href="../../api.html#msprime.AncestryModel">[docs]</a>
<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AncestryModel</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract superclass of all ancestry models.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">duration</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The time duration that this model should run for. If None, the model</span>
<span class="sd">    will run until completion (i.e., until the simulation coalesces</span>
<span class="sd">    or the model itself completes). Otherwise, this defines the maximum</span>
<span class="sd">    time duration which the model can run. See the</span>
<span class="sd">    :ref:`sec_ancestry_models_specifying` section for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">ClassVar</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

    <span class="c1"># We have to define an __init__ to enforce keyword-only behaviour</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>

    <span class="c1"># We need to have a separate _as_lowlevel and asdict because the</span>
    <span class="c1"># asdict form can&#39;t have the name in the dictionary for the</span>
    <span class="c1"># provenance code.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_as_lowlevel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>



<div class="viewcode-block" id="StandardCoalescent">
<a class="viewcode-back" href="../../api.html#msprime.StandardCoalescent">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">StandardCoalescent</span><span class="p">(</span><span class="n">AncestryModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The classical coalescent with recombination model (i.e., Hudson&#39;s algorithm).</span>
<span class="sd">    The string ``&quot;hudson&quot;`` can be used to refer to this model.</span>

<span class="sd">    This is a continuous time model in which the time to the next event</span>
<span class="sd">    is exponentially distributed with rates depending on the population size(s),</span>
<span class="sd">    migration rates, numbers of extant lineages and the amount of ancestral</span>
<span class="sd">    material currently present. See</span>
<span class="sd">    `Kelleher et al. (2016) &lt;https://doi.org/10.1371/journal.pcbi.1004842&gt;`_ for a</span>
<span class="sd">    detailed description of the model and further references.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;hudson&quot;</span></div>



<div class="viewcode-block" id="SmcApproxCoalescent">
<a class="viewcode-back" href="../../api.html#msprime.SmcApproxCoalescent">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SmcApproxCoalescent</span><span class="p">(</span><span class="n">AncestryModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Legacy implementation of the SMC model. Please see the</span>
<span class="sd">    :ref:`sec_ancestry_models_smc` section for information on the more</span>
<span class="sd">    efficient :class:`SMCK` method.</span>

<span class="sd">    The Sequentially Markov Coalescent (SMC) model defined by</span>
<span class="sd">    `McVean and Cardin (2005) &lt;https://dx.doi.org/10.1098%2Frstb.2005.1673&gt;`_.</span>
<span class="sd">    In the SMC, only common ancestor events that result in marginal coalescences</span>
<span class="sd">    are possible. Under this approximation, the marginal trees along the</span>
<span class="sd">    genome depend only on the immediately previous tree (i.e. are Markovian).</span>

<span class="sd">    .. note::</span>
<span class="sd">        This model is implemented using a naive rejection sampling approach</span>
<span class="sd">        and so it may not be any more efficient to simulate than the</span>
<span class="sd">        standard Hudson model.</span>

<span class="sd">    The string ``&quot;smc&quot;`` can be used to refer to this model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;smc&quot;</span></div>



<div class="viewcode-block" id="SmcPrimeApproxCoalescent">
<a class="viewcode-back" href="../../api.html#msprime.SmcPrimeApproxCoalescent">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SmcPrimeApproxCoalescent</span><span class="p">(</span><span class="n">AncestryModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Legacy implementation of the SMC&#39; model. Please see the</span>
<span class="sd">    :ref:`sec_ancestry_models_smc` section for information on the more</span>
<span class="sd">    efficient :class:`SMCK` method.</span>

<span class="sd">    The SMC&#39; model defined by</span>
<span class="sd">    `Marjoram and Wall (2006) &lt;https://doi.org/10.1186/1471-2156-7-16&gt;`_</span>
<span class="sd">    as a refinement of the :class:`SMC&lt;SmcApproxCoalescent&gt;`. The SMC&#39;</span>
<span class="sd">    extends the SMC by additionally allowing common ancestor events that</span>
<span class="sd">    join contiguous tracts of ancestral material (as well as events that</span>
<span class="sd">    result in marginal coalescences).</span>

<span class="sd">    .. note::</span>
<span class="sd">        This model is implemented using a naive rejection sampling approach</span>
<span class="sd">        and so it may not be any more efficient to simulate than the</span>
<span class="sd">        standard Hudson model.</span>

<span class="sd">    The string ``&quot;smc_prime&quot;`` can be used to refer to this model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;smc_prime&quot;</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">ParametricAncestryModel</span><span class="p">(</span><span class="n">AncestryModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The superclass of ancestry models that require extra parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="SMCK">
<a class="viewcode-back" href="../../api.html#msprime.SMCK">[docs]</a>
<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SMCK</span><span class="p">(</span><span class="n">ParametricAncestryModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A general Sequentially Markov Coalescent (SMC) model. This model accepts a</span>
<span class="sd">    parameter ``k`` that (roughly speaking) defines the distance from</span>
<span class="sd">    the SMC model. Thus ``k=0`` is equivalent to the SMC (more approximate),</span>
<span class="sd">    and ``k=L`` is equivalent to the standard coalescent for a simulation</span>
<span class="sd">    with sequence length ``L`` (less approximate). Smaller values of ``k``</span>
<span class="sd">    usually correspond to shorter running times.</span>

<span class="sd">    Please see the :ref:`sec_ancestry_models_smc` section for more information.</span>

<span class="sd">    :param float k: The distance parameter defining the approximation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;smc_k&quot;</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">float</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span></div>



<div class="viewcode-block" id="DiscreteTimeWrightFisher">
<a class="viewcode-back" href="../../api.html#msprime.DiscreteTimeWrightFisher">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DiscreteTimeWrightFisher</span><span class="p">(</span><span class="n">AncestryModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A discrete backwards-time Wright-Fisher model, with diploid back-and-forth</span>
<span class="sd">    recombination. The string ``&quot;dtwf&quot;`` can be used to refer to this model.</span>

<span class="sd">    Wright-Fisher simulations are performed very similarly to coalescent</span>
<span class="sd">    simulations, with all parameters denoting the same quantities in both</span>
<span class="sd">    models. Because events occur at discrete times however, the order in which</span>
<span class="sd">    they occur matters. Each generation consists of the following ordered</span>
<span class="sd">    events:</span>

<span class="sd">    - Migration events. As in the Hudson coalescent, these move single extant</span>
<span class="sd">      lineages between populations. Because migration events occur before</span>
<span class="sd">      lineages choose parents, migrant lineages choose parents from their new</span>
<span class="sd">      population in the same generation.</span>
<span class="sd">    - Demographic events. All events with `previous_generation &lt; event_time &lt;=</span>
<span class="sd">      current_generation` are carried out here.</span>
<span class="sd">    - Lineages draw parents. Each (monoploid) extant lineage draws a parent</span>
<span class="sd">      from their current population.</span>
<span class="sd">    - Diploid recombination. Each parent is diploid, so all child lineages</span>
<span class="sd">      recombine back-and-forth into the same two parental genome copies. These</span>
<span class="sd">      become two independent lineages in the next generation.</span>
<span class="sd">    - Historical sampling events. All historical samples with</span>
<span class="sd">      `previous_generation &lt; sample_time &lt;= current_generation` are inserted.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;dtwf&quot;</span></div>



<div class="viewcode-block" id="FixedPedigree">
<a class="viewcode-back" href="../../api.html#msprime.FixedPedigree">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FixedPedigree</span><span class="p">(</span><span class="n">AncestryModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Backwards-time simulations through a pre-specified pedigree, with diploid</span>
<span class="sd">    individuals and back-and-forth recombination. The string ``&quot;fixed_pedigree&quot;`` can</span>
<span class="sd">    be used to refer to this model.</span>

<span class="sd">    The model has no parameters, but requires that the</span>
<span class="sd">    :ref:`initial_state&lt;sec_ancestry_initial_state&gt;` parameter is provided to</span>
<span class="sd">    :func:`.sim_ancestry` and that it contains a valid pedigree. See the</span>
<span class="sd">    :ref:`sec_pedigrees` section for more information on the required</span>
<span class="sd">    encoding and methods for translating existing pedigrees into this format.</span>

<span class="sd">    Unlike other :ref:`ancestry models&lt;sec_ancestry_models&gt;`, the</span>
<span class="sd">    :class:`FixedPedigree` cannot be combined with other simulation models, and</span>
<span class="sd">    special attention must be paid to the role of founders when</span>
<span class="sd">    :ref:`recapitating these</span>
<span class="sd">    simulations&lt;sec_ancestry_models_fixed_pedigree_completing&gt;`.</span>

<span class="sd">    See the :ref:`sec_ancestry_models_fixed_pedigree` section for more information</span>
<span class="sd">    for more information and examples of running simulations within a</span>
<span class="sd">    fixed pedigree.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;fixed_pedigree&quot;</span></div>



<div class="viewcode-block" id="BetaCoalescent">
<a class="viewcode-back" href="../../api.html#msprime.BetaCoalescent">[docs]</a>
<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BetaCoalescent</span><span class="p">(</span><span class="n">ParametricAncestryModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Lambda-coalescent with multiple mergers in the haploid cases, or a</span>
<span class="sd">    Xi-coalescent with simultaneous multiple mergers in the polyploid case.</span>

<span class="sd">    There are two main differences between the Beta-coalescent and the</span>
<span class="sd">    standard coalescent. Firstly, the number of lineages that take part in each</span>
<span class="sd">    common ancestor event is random, with distribution determined by moments of</span>
<span class="sd">    the :math:`Beta(2 - \\alpha, \\alpha)`-distribution. In particular, when there</span>
<span class="sd">    are :math:`n` lineages, each set of :math:`k \\leq n` of them participates in a</span>
<span class="sd">    common ancestor event at rate</span>

<span class="sd">    .. math::</span>
<span class="sd">        \\frac{1}{B(2 - \\alpha, \\alpha)}</span>
<span class="sd">        \\int_0^1 x^{k - \\alpha - 1} (1 - x)^{n - k + \\alpha - 1} dx,</span>

<span class="sd">    where :math:`B(2 - \\alpha, \\alpha)` is the Beta-function.</span>

<span class="sd">    If ploidy = 1, then all participating lineages merge into one common ancestor,</span>
<span class="sd">    corresponding to haploid, single-parent reproduction.</span>
<span class="sd">    If ploidy = :math:`p &gt; 1`, all participating lineages split randomly into</span>
<span class="sd">    :math:`2 p` groups, corresponding to two-parent reproduction with :math:`p` copies</span>
<span class="sd">    of each chromosome per parent. All lineages within each group merge simultaneously.</span>

<span class="sd">    Secondly, the number of generations between common ancestor events predicted by the</span>
<span class="sd">    Beta-coalescent is proportional to :math:`N^{\\alpha - 1}`, where :math:`N` is</span>
<span class="sd">    the population size. Specifically, the mean number of generations until</span>
<span class="sd">    two lineages undergo a common ancestor event is</span>

<span class="sd">    .. math::</span>
<span class="sd">        G = \\frac{m^{\\alpha} N^{\\alpha - 1}}{\\alpha B(2 - \\alpha, \\alpha)},</span>

<span class="sd">    if ploidy = 1, and</span>

<span class="sd">    .. math::</span>
<span class="sd">        G = \\frac{2 p m^{\\alpha} (N / 2)^{\\alpha - 1}}</span>
<span class="sd">            {\\alpha B(2 - \\alpha, \\alpha)},</span>

<span class="sd">    if ploidy = :math:`p &gt; 1`, where :math:`m` is the mean number of juveniles per</span>
<span class="sd">    family given by</span>

<span class="sd">    .. math::</span>
<span class="sd">        m = 2 + \\frac{2^{\\alpha}}{3^{\\alpha - 1} (\\alpha - 1)},</span>

<span class="sd">    if ploidy &gt; 1, and</span>

<span class="sd">    .. math::</span>
<span class="sd">        m = 1 + \\frac{1}{2^{\\alpha - 1} (\\alpha - 1)},</span>

<span class="sd">    if ploidy = 1.</span>

<span class="sd">    In the polyploid case we divide the population size :math:`N` by two</span>
<span class="sd">    because we assume the :math:`N` polyploid individuals form :math:`N / 2`</span>
<span class="sd">    two-parent families in which reproduction takes place.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        The number of generations between common ancestor events :math:`G` depends</span>
<span class="sd">        both on the population size :math:`N` and :math:`\\alpha`,</span>
<span class="sd">        and can be dramatically shorter than in the case of the</span>
<span class="sd">        standard coalescent. For :math:`\\alpha \\approx 1` that is due to</span>
<span class="sd">        insensitivity of :math:`G` to :math:`N` --- see</span>
<span class="sd">        :ref:`sec_ancestry_models_multiple_mergers` for an illustration.</span>
<span class="sd">        For :math:`\\alpha \\approx 2`, :math:`G` is almost linear in</span>
<span class="sd">        :math:`N`, but can nevertheless be small because</span>
<span class="sd">        :math:`B(2 - \\alpha, \\alpha) \\rightarrow \\infty` as</span>
<span class="sd">        :math:`\\alpha \\rightarrow 2`. As a result, population sizes</span>
<span class="sd">        must often be many orders of magnitude larger than census population sizes</span>
<span class="sd">        to obtain realistic amounts of diversity in simulated samples.</span>

<span class="sd">    See `Schweinsberg (2003)</span>
<span class="sd">    &lt;https://www.sciencedirect.com/science/article/pii/S0304414903000280&gt;`_</span>
<span class="sd">    for the derivation of the common ancestor event rate,</span>
<span class="sd">    as well as the number of generations between common ancestor events.</span>
<span class="sd">    Note however that Schweinsberg (2003) only covers the haploid case.</span>
<span class="sd">    For details of the diploid extension, see</span>
<span class="sd">    `Blath et al. (2013) &lt;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3527250/&gt;`_,</span>
<span class="sd">    and `Birkner et al. (2018) &lt;https://projecteuclid.org/euclid.ejp/1527818427&gt;`_</span>
<span class="sd">    for a diploid version of the Schweinsberg (2003) model specifically.</span>
<span class="sd">    The general polyploid model is analogous to the diploid case, with</span>
<span class="sd">    :math:`2 p` available copies of parental chromosomes per common ancestor event,</span>
<span class="sd">    and hence up to :math:`2 p` simultaneous mergers.</span>

<span class="sd">    :param float alpha: Determines the degree of skewness in the family size</span>
<span class="sd">        distribution, and must satisfy :math:`1 &lt; \\alpha &lt; 2`. Smaller values of</span>
<span class="sd">        :math:`\\alpha` correspond to greater skewness, and :math:`\\alpha = 2`</span>
<span class="sd">        would coincide with the standard coalescent.</span>
<span class="sd">    :param float truncation_point: The maximum number of juveniles :math:`K` born to</span>
<span class="sd">        one family as a fraction of the population size :math:`N`. Must satisfy</span>
<span class="sd">        :math:`0 &lt; K \\leq \\inf`. Determines the maximum fraction of the population</span>
<span class="sd">        replaced by offspring in one reproduction event, :math:`\\tau`, via</span>
<span class="sd">        :math:`\\tau = K / (K + m)`, where :math:`m` is the mean juvenile number</span>
<span class="sd">        above. The default is :math:`K = \\inf`, which corresponds to the standard</span>
<span class="sd">        Beta-coalescent with :math:`\\tau = 1`. When :math:`K &lt; \\inf`, the number of</span>
<span class="sd">        lineages participating in a common ancestor event is determined by moments</span>
<span class="sd">        of the Beta:math:`(2 - \\alpha, \\alpha)` distribution conditioned on not</span>
<span class="sd">        exceeding :math:`\\tau`, and the Beta-function in the expression</span>
<span class="sd">        for :math:`G` is replaced by the incomplete Beta-function</span>
<span class="sd">        :math:`B(\\tau; 2 - \\alpha, \\alpha)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;beta&quot;</span>

    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">truncation_point</span><span class="p">:</span> <span class="nb">float</span>

    <span class="c1"># We have to define an __init__ to enforce keyword-only behaviour</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">truncation_point</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">truncation_point</span> <span class="o">=</span> <span class="n">truncation_point</span></div>



<div class="viewcode-block" id="DiracCoalescent">
<a class="viewcode-back" href="../../api.html#msprime.DiracCoalescent">[docs]</a>
<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DiracCoalescent</span><span class="p">(</span><span class="n">ParametricAncestryModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Lambda-coalescent with multiple mergers in the haploid cases, or a</span>
<span class="sd">    Xi-coalescent with simultaneous multiple mergers in the polyploid case.</span>

<span class="sd">    The Dirac-coalescent is an implementation of the model of</span>
<span class="sd">    `Blath et al. (2013) &lt;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3527250/&gt;`_</span>
<span class="sd">    The simulation proceeds similarly to the standard coalescent.</span>
<span class="sd">    In addition to binary common ancestor events at rate :math:`n (n - 1) / 2` when</span>
<span class="sd">    there are :math:`n` lineages, potential multiple merger events take place</span>
<span class="sd">    at rate :math:`c &gt; 0`. Each lineage participates in each multiple merger</span>
<span class="sd">    event independently with probability :math:`0 &lt; \\psi \\leq 1`.</span>

<span class="sd">    If ploidy = 1, then all participating lineages merge into one common ancestor,</span>
<span class="sd">    corresponding to haploid, single-parent reproduction.</span>
<span class="sd">    If ploidy = :math:`p &gt; 1`, all participating lineages split randomly into</span>
<span class="sd">    :math:`2 p` groups, corresponding to two-parent reproduction with :math:`p` copies</span>
<span class="sd">    of each chromosome per parent. All lineages within each group merge simultaneously.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        The Dirac-coalescent is obtained as a scaling limit of Moran models,</span>
<span class="sd">        rather than Wright-Fisher models. As a consequence, the number of generations</span>
<span class="sd">        between coalescence events is proportional to :math:`N^2`,</span>
<span class="sd">        rather than :math:`N` generations as in the standard coalescent.</span>
<span class="sd">        See :ref:`sec_ancestry_models_multiple_mergers` for an illustration</span>
<span class="sd">        of how this affects simulation output in practice.</span>

<span class="sd">    :param float c: Determines the rate of potential multiple merger events.</span>
<span class="sd">        We require :math:`c &gt; 0`.</span>
<span class="sd">    :param float psi: Determines the fraction of the population replaced by</span>
<span class="sd">        offspring in one large reproduction event, i.e. one reproduction event</span>
<span class="sd">        giving rise to potential multiple mergers when viewed backwards in time.</span>
<span class="sd">        We require :math:`0 &lt; \\psi \\leq 1`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;dirac&quot;</span>

    <span class="n">psi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">c</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span>

    <span class="c1"># We have to define an __init__ to enforce keyword-only behaviour</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">psi</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi</span> <span class="o">=</span> <span class="n">psi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span></div>



<div class="viewcode-block" id="SweepGenicSelection">
<a class="viewcode-back" href="../../api.html#msprime.SweepGenicSelection">[docs]</a>
<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SweepGenicSelection</span><span class="p">(</span><span class="n">ParametricAncestryModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A selective sweep that has occurred in the history of the sample.</span>
<span class="sd">    This will lead to a burst of rapid coalescence near the selected site.</span>

<span class="sd">    The strength of selection during the sweep is determined by the</span>
<span class="sd">    parameter :math:`s`. Here we define s such that the</span>
<span class="sd">    fitness of the three genotypes at our beneficial locus are</span>
<span class="sd">    :math:`W_{bb}=1`, :math:`W_{Bb}=1 + s/2`, :math:`W_{BB}=1 + s`.</span>
<span class="sd">    Thus fitness of the heterozygote is intermediate to the</span>
<span class="sd">    two homozygotes.</span>

<span class="sd">    .. warning:: Models where `start_frequency` is</span>
<span class="sd">       :math:`\\geq \\frac{1}{ploidy*N}`</span>
<span class="sd">       will not simulate the trajectory until its origination.</span>
<span class="sd">       In practical terms, this issue means</span>
<span class="sd">       that &quot;sweeps from neutral standing genetic variation&quot; are currently not</span>
<span class="sd">       possible. The tracking issue for this on GitHub is</span>
<span class="sd">       `here &lt;https://github.com/tskit-dev/msprime/issues/1762&gt;`_.</span>

<span class="sd">    The model is one of a structured coalescent where selective backgrounds are</span>
<span class="sd">    defined as in</span>
<span class="sd">    `Braverman et al. (1995) &lt;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1206652/&gt;`_</span>
<span class="sd">    The implementation details here follow closely those in discoal</span>
<span class="sd">    `(Kern and Schrider, 2016)</span>
<span class="sd">    &lt;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5167068/&gt;`_, with</span>
<span class="sd">    the important difference that :math:`s` in msprime is half of</span>
<span class="sd">    of that in discoal (i.e. for equivalent results  use :math:`2s`).</span>

<span class="sd">    See :ref:`sec_ancestry_models_selective_sweeps` for examples and</span>
<span class="sd">    details on how to specify different types of sweeps.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Currently models with more than one population and a selective sweep</span>
<span class="sd">        are not implemented. Population size changes during the sweep</span>
<span class="sd">        are not yet possible in msprime.</span>

<span class="sd">    :param float position: the location of the beneficial allele along the</span>
<span class="sd">        chromosome.</span>
<span class="sd">    :param float start_frequency: population frequency of the beneficial</span>
<span class="sd">        allele at the start of the selective sweep. E.g., for a *de novo*</span>
<span class="sd">        allele in a diploid population of size N, start frequency would be</span>
<span class="sd">        :math:`1/2N`.</span>
<span class="sd">    :param float end_frequency: population frequency of the beneficial</span>
<span class="sd">        allele at the end of the selective sweep.</span>
<span class="sd">    :param float s: :math:`s` is the selection coefficient of the beneficial mutation.</span>
<span class="sd">    :param float dt: dt is the small increment of time for stepping through</span>
<span class="sd">        the sweep phase of the model. a good rule of thumb is for this to be</span>
<span class="sd">        approximately :math:`1/40N` or smaller.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;sweep_genic_selection&quot;</span>

    <span class="n">position</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">start_frequency</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">end_frequency</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span>
    <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span>

    <span class="c1"># We have to define an __init__ to enforce keyword-only behaviour</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">duration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">start_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">end_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_frequency</span> <span class="o">=</span> <span class="n">start_frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end_frequency</span> <span class="o">=</span> <span class="n">end_frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span></div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Tskit Developers
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
       Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>