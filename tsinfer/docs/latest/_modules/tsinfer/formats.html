
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tsinfer.formats &#8212; Tsinfer manual</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=9c3e77be" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=1ae7504c"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/tsinfer/formats';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <script data-goatcounter="https://tskit.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/tsinfer_logo.svg" class="logo__image only-light" alt=""/>
    <script>document.write(`<img src="../../_static/tsinfer_logo.svg" class="logo__image only-dark" alt=""/>`);</script>
  
  
    <p class="title logo__title">Version 0.5.1.dev22</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Usage</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Inference</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../inference.html">Inference overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../large_scale.html">Large scale inference</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Interfaces</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli.html">Command line interface</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">File Formats</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../file_formats.html">File formats</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Miscellaneous</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CITATION.html">Citing tsinfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CHANGELOG.html">Changelog</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for tsinfer.formats</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Copyright (C) 2018-2020 University of Oxford</span>
<span class="c1">#</span>
<span class="c1"># This file is part of tsinfer.</span>
<span class="c1">#</span>
<span class="c1"># tsinfer is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># tsinfer is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with tsinfer.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Manage tsinfer&#39;s various file formats.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">abc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os.path</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">queue</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">threading</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">weakref</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span>  <span class="c1"># noqa: F401</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">attr</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">humanize</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lmdb</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numcodecs</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">zarr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tskit</span><span class="w"> </span><span class="kn">import</span> <span class="n">MISSING_DATA</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">tsinfer.exceptions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">exceptions</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tsinfer.provenance</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">provenance</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tsinfer.threads</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">threads</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="n">FORMAT_NAME_KEY</span> <span class="o">=</span> <span class="s2">&quot;format_name&quot;</span>
<span class="n">FORMAT_VERSION_KEY</span> <span class="o">=</span> <span class="s2">&quot;format_version&quot;</span>
<span class="n">FINALISED_KEY</span> <span class="o">=</span> <span class="s2">&quot;finalised&quot;</span>

<span class="c1"># We use the zstd compressor because it allows for compression of buffers</span>
<span class="c1"># bigger than 2GB, which can occur in a larger instances.</span>
<span class="n">DEFAULT_COMPRESSOR</span> <span class="o">=</span> <span class="n">numcodecs</span><span class="o">.</span><span class="n">Zstd</span><span class="p">()</span>

<span class="c1"># Lmdb on windows allocates the entire file size rather than</span>
<span class="c1"># growing dynamically (see https://github.com/mozilla/lmdb-rs/issues/40).</span>
<span class="c1"># For the default setting on windows, we therefore hard code a smaller</span>
<span class="c1"># map_size of 1GiB to avoid filling up disk space. On other platforms where</span>
<span class="c1"># sparse files are supported, we default to 1TiB.</span>
<span class="n">DEFAULT_MAX_FILE_SIZE</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">30</span> <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s2">&quot;win32&quot;</span> <span class="k">else</span> <span class="mi">2</span><span class="o">**</span><span class="mi">40</span>


<span class="k">def</span><span class="w"> </span><span class="nf">np_obj_equal</span><span class="p">(</span><span class="n">np_obj_array1</span><span class="p">,</span> <span class="n">np_obj_array2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A replacement for np.array_equal to test equality of numpy arrays that</span>
<span class="sd">    contain objects, as used e.g. for metadata, location, alleles, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np_obj_array1</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">np_obj_array2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">np_obj_array1</span><span class="p">,</span> <span class="n">np_obj_array2</span><span class="p">)))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">exclude_id</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to filter out the id field from attrs objects such as Ancestor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">attribute</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;id&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">exclude_id_and_full_haplotype</span><span class="p">(</span><span class="n">attribute</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used to filter out the id field from attrs objects such as Ancestor</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">attribute</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;full_haplotype&quot;</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">open_lmbd_readonly</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="c1"># We set the mapsize here because LMBD will map 1TB of virtual memory if</span>
    <span class="c1"># we don&#39;t, making it hard to figure out how much memory we&#39;re actually</span>
    <span class="c1"># using.</span>
    <span class="n">map_size</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">map_size</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">FileFormatError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">store</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">LMDBStore</span><span class="p">(</span>
            <span class="n">path</span><span class="p">,</span> <span class="n">map_size</span><span class="o">=</span><span class="n">map_size</span><span class="p">,</span> <span class="n">readonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subdir</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="n">lmdb</span><span class="o">.</span><span class="n">InvalidError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">FileFormatError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown file format:</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
    <span class="k">except</span> <span class="n">lmdb</span><span class="o">.</span><span class="n">Error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">FileFormatError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
    <span class="k">return</span> <span class="n">store</span>


<span class="k">def</span><span class="w"> </span><span class="nf">remove_lmdb_lockfile</span><span class="p">(</span><span class="n">lmdb_file</span><span class="p">):</span>
    <span class="n">lockfile</span> <span class="o">=</span> <span class="n">lmdb_file</span> <span class="o">+</span> <span class="s2">&quot;-lock&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">lockfile</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">lockfile</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">BufferedItemWriter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that writes items sequentially into a set of zarr arrays,</span>
<span class="sd">    buffering writes and flushing them to the destination arrays</span>
<span class="sd">    asynchronosly using threads.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array_map</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">array_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">chunked_dimension</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="s2">&quot;full_haplotype&quot;</span> <span class="ow">in</span> <span class="n">key</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">chunked_dimension</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">chunked_dimension</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Chunk sizes must be equal&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span> <span class="o">=</span> <span class="n">array_map</span>
        <span class="k">if</span> <span class="n">num_threads</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Use a syncronous algorithm.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_buffers</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># One buffer for each thread. Buffers are referred to by their indexes.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_buffers</span> <span class="o">=</span> <span class="n">num_threads</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="n">num_threads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_items</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_buffers</span><span class="p">)]</span>
            <span class="n">np_array</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:]</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">chunked_dimension</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="s2">&quot;full_haplotype&quot;</span> <span class="ow">in</span> <span class="n">key</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">chunked_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_buffers</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">np_array</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">)</span>
                <span class="c1"># We need to initialise the buffers for the arrays where only the extent</span>
                <span class="c1"># of the ancestor is written</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;full_haplotype&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">MISSING_DATA</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;full_haplotype_mask&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Make sure the destination array is zero sized at the start.</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">chunked_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">array</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">start_offset</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_buffers</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_buffered_items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_buffers</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_buffer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># This lock must be held when resizing the underlying arrays.</span>
        <span class="c1"># This is no-op when using a single-threaded algorithm, but it&#39;s</span>
        <span class="c1"># not worth removing and complicating the logic.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resize_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Buffer indexes are placed in the queues. The current write buffer</span>
            <span class="c1"># is obtained from the write_queue. Flush worker threads pull buffer</span>
            <span class="c1"># indexes from the flush queue, and push them back on to the write</span>
            <span class="c1"># queue when the buffer has been flushed.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush_queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
            <span class="c1"># The initial write buffer is 0; place the others on the queue.</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_buffers</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="c1"># Make the flush threads.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush_threads</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">threads</span><span class="o">.</span><span class="n">queue_consumer_thread</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_flush_worker</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flush_queue</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;flush-worker-</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Started </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="si">}</span><span class="s2"> flush worker threads&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_commit_write_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">write_buffer</span><span class="p">):</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_offset</span><span class="p">[</span><span class="n">write_buffer</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_buffered_items</span><span class="p">[</span><span class="n">write_buffer</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">n</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Flushing buffer </span><span class="si">{</span><span class="n">write_buffer</span><span class="si">}</span><span class="s2">: start=</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2"> n=</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">resize_lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_size</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_size</span> <span class="o">=</span> <span class="n">end</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">chunked_dimension</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="s2">&quot;full_haplotype&quot;</span> <span class="ow">in</span> <span class="n">key</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="n">shape</span><span class="p">[</span><span class="n">chunked_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_size</span>
                    <span class="n">array</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="s2">&quot;full_haplotype&quot;</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
                <span class="n">buffered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">write_buffer</span><span class="p">][:,</span> <span class="p">:</span><span class="n">n</span><span class="p">]</span>
                <span class="n">array</span><span class="p">[:,</span> <span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">buffered</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">buffered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">write_buffer</span><span class="p">][:</span><span class="n">n</span><span class="p">]</span>
                <span class="n">array</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">=</span> <span class="n">buffered</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;full_haplotype&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">write_buffer</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">MISSING_DATA</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;full_haplotype_mask&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">write_buffer</span><span class="p">][</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Buffer </span><span class="si">{</span><span class="n">write_buffer</span><span class="si">}</span><span class="s2"> flush done&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_flush_worker</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thread_index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Thread worker responsible for flushing buffers. Read a buffer index</span>
<span class="sd">        from flush_queue and write it to disk. Push the index back on</span>
<span class="sd">        to the write queue to allow it be reused.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">buffer_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flush_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">buffer_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_commit_write_buffer</span><span class="p">(</span><span class="n">buffer_index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">buffer_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_queue_flush_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flushes the buffered ancestors to the data file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Pushing buffer </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">write_buffer</span><span class="si">}</span><span class="s2"> to flush queue&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">write_buffer</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write_buffer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Syncronously flushing buffer&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_commit_write_buffer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">write_buffer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_buffered_items</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">write_buffer</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_offset</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">write_buffer</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_items</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an item to each of the arrays. The keyword arguments for this</span>
<span class="sd">        function correspond to the keys in the dictionary of arrays provided</span>
<span class="sd">        to the constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_buffered_items</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">write_buffer</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_queue_flush_buffer</span><span class="p">()</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_buffered_items</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">write_buffer</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Here we have to special case the haplotype for performance</span>
            <span class="c1"># reasons, as writing the full haplotype is expensive.</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;haplotype&quot;</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;end&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="s2">&quot;full_haplotype&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">write_buffer</span><span class="p">][</span>
                    <span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="s2">&quot;full_haplotype_mask&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">write_buffer</span><span class="p">][</span>
                    <span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span>
                <span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">write_buffer</span><span class="p">][</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_buffered_items</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">write_buffer</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_items</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_items</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flush the remaining items to the destination arrays and return all</span>
<span class="sd">        items are safely commited.</span>

<span class="sd">        It is an error to call ``add`` after ``flush`` has been called.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_queue_flush_buffer</span><span class="p">()</span>
        <span class="c1"># Stop the worker threads.</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush_threads</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span><span class="w"> </span><span class="nf">zarr_summary</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a string with a brief summary of the specified zarr array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;shape=</span><span class="si">{</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">; dtype=</span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="o">!=</span> <span class="s2">&quot;object&quot;</span><span class="p">:</span>
        <span class="c1"># nbytes doesn&#39;t work correctly for object arrays.</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;uncompressed size=</span><span class="si">{</span><span class="n">humanize</span><span class="o">.</span><span class="n">naturalsize</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">nbytes</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">ret</span>


<span class="k">def</span><span class="w"> </span><span class="nf">chunk_iterator</span><span class="p">(</span>
    <span class="n">array</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">select</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orthogonal_select</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">0</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility to iterate over closely spaced rows in the specified array efficiently</span>
<span class="sd">    by accessing one chunk at a time (normally used as an iterator over each row)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Only the first two dimensions are supported.</span>
    <span class="k">assert</span> <span class="n">dimension</span> <span class="o">&lt;</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">select</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dimension</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">orthogonal_select</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">orthogonal_select</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="n">dimension</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">select</span><span class="p">)</span> <span class="o">!=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dimension</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mask must be the same length as the array&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">select</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="ow">or</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="ow">or</span> <span class="n">indexes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ids must be positive and in ascending order&quot;</span><span class="p">)</span>

    <span class="c1"># If there is a variant mask we need to translate the indexes from the masked</span>
    <span class="c1"># space to the unmasked space.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">select</span><span class="p">):</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">select</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="n">indexes</span><span class="p">]</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="n">dimension</span><span class="p">]</span>
    <span class="n">prev_chunk_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
            <span class="n">chunk_id</span> <span class="o">=</span> <span class="n">j</span> <span class="o">//</span> <span class="n">chunk_size</span>
            <span class="k">if</span> <span class="n">chunk_id</span> <span class="o">!=</span> <span class="n">prev_chunk_id</span><span class="p">:</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">chunk_id</span> <span class="o">*</span> <span class="n">chunk_size</span> <span class="p">:</span> <span class="p">(</span><span class="n">chunk_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunk_size</span><span class="p">][:]</span>
                <span class="n">prev_chunk_id</span> <span class="o">=</span> <span class="n">chunk_id</span>
            <span class="k">yield</span> <span class="n">chunk</span><span class="p">[</span><span class="n">j</span> <span class="o">%</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="n">orthogonal_select</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
            <span class="n">chunk_id</span> <span class="o">=</span> <span class="n">j</span> <span class="o">//</span> <span class="n">chunk_size</span>
            <span class="k">if</span> <span class="n">chunk_id</span> <span class="o">!=</span> <span class="n">prev_chunk_id</span><span class="p">:</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="n">chunk_id</span> <span class="o">*</span> <span class="n">chunk_size</span> <span class="p">:</span> <span class="p">(</span><span class="n">chunk_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunk_size</span><span class="p">][:]</span>
                <span class="n">prev_chunk_id</span> <span class="o">=</span> <span class="n">chunk_id</span>
            <span class="k">yield</span> <span class="n">chunk</span><span class="p">[</span><span class="n">orthogonal_select</span><span class="p">,</span> <span class="n">j</span> <span class="o">%</span> <span class="n">chunk_size</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">merge_variants</span><span class="p">(</span><span class="n">sd1</span><span class="p">,</span> <span class="n">sd2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an iterator over the merged variants in the specified</span>
<span class="sd">    SampleData files. Sites are merged by site position, and</span>
<span class="sd">    genotypes are set to missing data for sites are as not present</span>
<span class="sd">    in one of the data files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">var1_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">sd1</span><span class="o">.</span><span class="n">variants</span><span class="p">())</span>
    <span class="n">var2_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">sd2</span><span class="o">.</span><span class="n">variants</span><span class="p">())</span>
    <span class="n">var1</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">var1_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">var2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">var2_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">sd1</span><span class="o">.</span><span class="n">num_samples</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="n">sd2</span><span class="o">.</span><span class="n">num_samples</span>
    <span class="n">genotypes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">var1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">var2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span> <span class="o">==</span> <span class="n">var2</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">:</span>
            <span class="c1"># Checking metadata as well is probably overly strict, but</span>
            <span class="c1"># we can fix this later if needs be.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">ancestral_state</span> <span class="o">!=</span> <span class="n">var2</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">ancestral_state</span>
                <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">var2</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">metadata</span> <span class="o">!=</span> <span class="n">var2</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">metadata</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Merged sites must have the same ancestral_state, &quot;</span>
                    <span class="s2">&quot;time and metadata&quot;</span>
                <span class="p">)</span>
            <span class="c1"># If there is missing data the last allele is always None</span>
            <span class="n">missing_data</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">alleles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">alleles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">alleles</span> <span class="o">=</span> <span class="n">alleles</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">missing_data</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">var2_genotypes</span> <span class="o">=</span> <span class="n">var2</span><span class="o">.</span><span class="n">genotypes</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">old_index</span><span class="p">,</span> <span class="n">allele</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">var2</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">alleles</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">allele</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">missing_data</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">allele</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">alleles</span><span class="p">:</span>
                    <span class="n">alleles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">allele</span><span class="p">)</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="n">alleles</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">allele</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">old_index</span> <span class="o">!=</span> <span class="n">new_index</span><span class="p">:</span>
                    <span class="n">var2_genotypes</span><span class="p">[</span><span class="n">var2</span><span class="o">.</span><span class="n">genotypes</span> <span class="o">==</span> <span class="n">old_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_index</span>
            <span class="k">if</span> <span class="n">missing_data</span><span class="p">:</span>
                <span class="n">alleles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">genotypes</span><span class="p">[:</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="n">var1</span><span class="o">.</span><span class="n">genotypes</span>
            <span class="n">genotypes</span><span class="p">[</span><span class="n">n1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">var2_genotypes</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">var1</span><span class="o">.</span><span class="n">site</span>
            <span class="n">site</span><span class="o">.</span><span class="n">alleles</span> <span class="o">=</span> <span class="n">alleles</span>
            <span class="c1"># TODO not sure why we have alleles on both the Site and Variant</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">Variant</span><span class="p">(</span><span class="n">site</span><span class="o">=</span><span class="n">site</span><span class="p">,</span> <span class="n">genotypes</span><span class="o">=</span><span class="n">genotypes</span><span class="p">,</span> <span class="n">alleles</span><span class="o">=</span><span class="n">alleles</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">var</span>
            <span class="n">var1</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">var1_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">var2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">var2_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span> <span class="o">&lt;</span> <span class="n">var2</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">:</span>
            <span class="n">genotypes</span><span class="p">[:</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="n">var1</span><span class="o">.</span><span class="n">genotypes</span>
            <span class="n">genotypes</span><span class="p">[</span><span class="n">n1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">MISSING_DATA</span>
            <span class="n">var1</span><span class="o">.</span><span class="n">genotypes</span> <span class="o">=</span> <span class="n">genotypes</span>
            <span class="k">yield</span> <span class="n">var1</span>
            <span class="n">var1</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">var1_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">genotypes</span><span class="p">[:</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="n">MISSING_DATA</span>
            <span class="n">genotypes</span><span class="p">[</span><span class="n">n1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">var2</span><span class="o">.</span><span class="n">genotypes</span>
            <span class="n">var2</span><span class="o">.</span><span class="n">genotypes</span> <span class="o">=</span> <span class="n">genotypes</span>
            <span class="k">yield</span> <span class="n">var2</span>
            <span class="n">var2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">var2_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="n">genotypes</span><span class="p">[</span><span class="n">n1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">MISSING_DATA</span>
    <span class="k">while</span> <span class="n">var1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">genotypes</span><span class="p">[:</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="n">var1</span><span class="o">.</span><span class="n">genotypes</span>
        <span class="n">var1</span><span class="o">.</span><span class="n">genotypes</span> <span class="o">=</span> <span class="n">genotypes</span>
        <span class="k">yield</span> <span class="n">var1</span>
        <span class="n">var1</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">var1_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="n">genotypes</span><span class="p">[:</span><span class="n">n1</span><span class="p">]</span> <span class="o">=</span> <span class="n">MISSING_DATA</span>
    <span class="k">while</span> <span class="n">var2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">genotypes</span><span class="p">[</span><span class="n">n1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">var2</span><span class="o">.</span><span class="n">genotypes</span>
        <span class="n">var2</span><span class="o">.</span><span class="n">genotypes</span> <span class="o">=</span> <span class="n">genotypes</span>
        <span class="k">yield</span> <span class="n">var2</span>
        <span class="n">var2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">var2_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">DataContainer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Superclass of objects used to represent a collection of related</span>
<span class="sd">    data. Each datacontainer in a wrapper around a zarr group.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">READ_MODE</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">BUILD_MODE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">EDIT_MODE</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1"># Must be defined by subclasses.</span>
    <span class="n">FORMAT_NAME</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">FORMAT_VERSION</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">num_flush_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">compressor</span><span class="o">=</span><span class="n">DEFAULT_COMPRESSOR</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span>
        <span class="n">max_file_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BUILD_MODE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_flush_threads</span> <span class="o">=</span> <span class="n">num_flush_threads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_codec</span> <span class="o">=</span> <span class="n">numcodecs</span><span class="o">.</span><span class="n">JSON</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span> <span class="o">=</span> <span class="n">compressor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">store</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_lmdb_store</span><span class="p">(</span><span class="n">max_file_size</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open_group</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="n">store</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">FORMAT_NAME_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FORMAT_NAME</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">FORMAT_VERSION_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FORMAT_VERSION</span>

        <span class="n">chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size</span>
        <span class="n">provenances_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;provenances&quot;</span><span class="p">)</span>
        <span class="n">provenances_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;timestamp&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
            <span class="n">object_codec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_metadata_codec</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">provenances_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;record&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
            <span class="n">object_codec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_metadata_codec</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Register a backstop to close the current store if the object leaks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_store_finalizer</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">READ_MODE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalise</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_open_readonly</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">store</span> <span class="o">=</span> <span class="n">open_lmbd_readonly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># This happens when we finalise an in-memory container.</span>
            <span class="n">store</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">store</span><span class="o">=</span><span class="n">store</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_format</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">READ_MODE</span>
        <span class="c1"># Refresh finalizer to target the current store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_store_finalizer</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_new_lmdb_store</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="c1"># The existence of a lock-file can confuse things, so delete it.</span>
        <span class="n">remove_lmdb_lockfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">map_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">map_size</span> <span class="o">=</span> <span class="n">DEFAULT_MAX_FILE_SIZE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">map_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">map_size</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">map_size</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max_file_size must be &gt; 0&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">zarr</span><span class="o">.</span><span class="n">LMDBStore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">subdir</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">map_size</span><span class="o">=</span><span class="n">map_size</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="c1"># Try to read the file. This should raise the correct error if we have a</span>
        <span class="c1"># directory, missing file, permissions, etc.</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">READ_MODE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_readonly</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loaded </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Close this DataContainer. Any read or write operations attempted</span>
<span class="sd">        after calling this will fail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">READ_MODE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finalise</span><span class="p">()</span>
        <span class="c1"># Detach backstop to avoid double-closing on explicit close</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_detach_store_finalizer</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">store</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">store</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_file_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this DataContainer opened in &#39;edit&#39; mode. If path</span>
<span class="sd">        is specified, this must not be equal to the path of the current</span>
<span class="sd">        data container.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">READ_MODE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot copy unless in read mode.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot copy to the same file&quot;</span><span class="p">)</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Have to work around a fairly weird bug in zarr where if we</span>
            <span class="c1"># try to use copy_store on an in-memory array we end up</span>
            <span class="c1"># overwriting the original values.</span>
            <span class="n">other</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="c1"># Another workaround: if we don&#39;t absorb warnings here</span>
                <span class="c1"># we get &quot;FutureWarning: missing object_codec for object array;</span>
                <span class="c1"># this will raise a ValueError in v3.&quot; Since this is an internal</span>
                <span class="c1"># Zarr call it seems easiest to just ignore for now and deal with</span>
                <span class="c1"># the ValueError if/when it happens</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="n">zarr</span><span class="o">.</span><span class="n">copy_all</span><span class="p">(</span><span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">store</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_new_lmdb_store</span><span class="p">(</span><span class="n">max_file_size</span><span class="p">)</span>
            <span class="n">zarr</span><span class="o">.</span><span class="n">copy_store</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">store</span><span class="p">,</span> <span class="n">store</span><span class="p">)</span>
            <span class="n">other</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">FINALISED_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">other</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EDIT_MODE</span>
        <span class="k">return</span> <span class="n">other</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">finalise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensures that the state of the data is flushed and writes the</span>
<span class="sd">        provenance for the current operation. The specified &#39;command&#39; is used</span>
<span class="sd">        to fill the corresponding entry in the provenance dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_write_modes</span><span class="p">()</span>
        <span class="n">zarr</span><span class="o">.</span><span class="n">consolidate_metadata</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">store</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">FINALISED_KEY</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">store</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">store</span>
            <span class="c1"># The store is about to change; detach any backstop on the old store</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_detach_store_finalizer</span><span class="p">()</span>
            <span class="n">store</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Fixing up LMDB file size&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">lmdb</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">subdir</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">writemap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">db</span><span class="p">:</span>
                <span class="c1"># LMDB maps a very large amount of space by default. While this</span>
                <span class="c1"># doesn&#39;t do any harm, it&#39;s annoying because we can&#39;t use ls to</span>
                <span class="c1"># see the file sizes and the amount of RAM we&#39;re mapping can</span>
                <span class="c1"># look like it&#39;s very large. So, we fix this up so that the</span>
                <span class="c1"># map size is equal to the number of pages in use.</span>
                <span class="n">num_pages</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">info</span><span class="p">()[</span><span class="s2">&quot;last_pgno&quot;</span><span class="p">]</span>
                <span class="n">page_size</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">stat</span><span class="p">()[</span><span class="s2">&quot;psize&quot;</span><span class="p">]</span>
                <span class="n">db</span><span class="o">.</span><span class="n">set_mapsize</span><span class="p">(</span><span class="n">num_pages</span> <span class="o">*</span> <span class="n">page_size</span><span class="p">)</span>
            <span class="c1"># Remove the lock file as we don&#39;t need it after this point.</span>
            <span class="n">remove_lmdb_lockfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_readonly</span><span class="p">()</span>

    <span class="c1"># The tsinfer test suite creates many DataContainer objects,</span>
    <span class="c1"># lots of which are never closed explicitly. On Windows these</span>
    <span class="c1"># files can&#39;t be deleted until the file handle is closed, so</span>
    <span class="c1"># CI fails with &quot;no disk space left on device&quot; errors. To avoid</span>
    <span class="c1"># this, we use a finalizer to close the underlying store if</span>
    <span class="c1"># the object is garbage collected without being closed.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_detach_store_finalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fin</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_gc_close&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">fin</span><span class="p">,</span> <span class="s2">&quot;alive&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">fin</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_store_finalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Detach any previous finalizer and attach to current store</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_detach_store_finalizer</span><span class="p">()</span>
        <span class="n">store</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">store</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">store</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;store&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">store</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="s2">&quot;close&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gc_close</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">store</span><span class="o">.</span><span class="n">close</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gc_close</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_format</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">format_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_name</span>
            <span class="n">format_version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_version</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">FileFormatError</span><span class="p">(</span><span class="s2">&quot;Incorrect file format&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">format_name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FORMAT_NAME</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">FileFormatError</span><span class="p">(</span>
                <span class="s2">&quot;Incorrect file format: expected &#39;</span><span class="si">{}</span><span class="s2">&#39; got &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">FORMAT_NAME</span><span class="p">,</span> <span class="n">format_name</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">format_version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">FORMAT_VERSION</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">FileFormatTooOld</span><span class="p">(</span>
                <span class="s2">&quot;Format version </span><span class="si">{}</span><span class="s2"> too old. Current version = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">format_version</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">FORMAT_VERSION</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">format_version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">FORMAT_VERSION</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">FileFormatTooNew</span><span class="p">(</span>
                <span class="s2">&quot;Format version </span><span class="si">{}</span><span class="s2"> too new. Current version = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">format_version</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">FORMAT_VERSION</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_build_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">BUILD_MODE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid operation: must be in build mode&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_edit_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">EDIT_MODE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid operation: must be in edit mode&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_write_modes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">EDIT_MODE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">BUILD_MODE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid operation: must be in edit or build mode&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_finalised</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalised</span><span class="p">:</span>
            <span class="n">error_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">format_name</span><span class="si">}</span><span class="s2"> file&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">error_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; at `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s2">`&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">error_msg</span> <span class="o">+</span> <span class="s2">&quot; is not finalised&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">file_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the size of the underlying file, or -1 if we do not have a</span>
<span class="sd">        file associated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">metadata</span>
        <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Metadata must be a JSON-like dictionary&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_provenance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new provenance record with the specified timestamp and record.</span>
<span class="sd">        Timestamps should ISO8601 formatted, and record is some JSON encodable</span>
<span class="sd">        object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">BUILD_MODE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">EDIT_MODE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid operation: cannot add provenances unless in BUILD &quot;</span>
                <span class="s2">&quot;or EDIT mode&quot;</span>
            <span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_provenances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">provenances_timestamp</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">provenances_record</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">provenances_timestamp</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">timestamp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">provenances_record</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">record_provenance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resources</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Records the provenance information for this file using the</span>
<span class="sd">        tskit provenances schema.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span>
            <span class="n">command</span><span class="o">=</span><span class="n">command</span><span class="p">,</span> <span class="n">resources</span><span class="o">=</span><span class="n">resources</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_provenance</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">clear_provenances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear all provenances in this instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">BUILD_MODE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">EDIT_MODE</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Invalid operation: cannot clear provenances unless in BUILD &quot;</span>
                <span class="s2">&quot;or EDIT mode&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">provenances_timestamp</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">provenances_record</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">format_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">FORMAT_NAME_KEY</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">format_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">FORMAT_VERSION_KEY</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">finalised</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">FINALISED_KEY</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">FINALISED_KEY</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_provenances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">provenances_timestamp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">provenances_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;provenances/timestamp&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">provenances_record</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;provenances/record&quot;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_format_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function for formatting __str__ output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1"># Quick hack to make sure everything lines up.</span>
        <span class="n">max_key</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="s2">&quot;provenances/timestamp&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;{:&lt;</span><span class="si">{}</span><span class="s2">} = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">max_key</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;path&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;file_size&quot;</span><span class="p">,</span> <span class="n">humanize</span><span class="o">.</span><span class="n">naturalsize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_size</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;format_name&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_name</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;format_version&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_version</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;finalised&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalised</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;num_provenances&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_provenances</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;provenances/timestamp&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">provenances_timestamp</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;provenances/record&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">provenances_record</span><span class="p">)),</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_str</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of all the zarr arrays in this DataContainer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">visitor</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">zarr</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">visititems</span><span class="p">(</span><span class="n">visitor</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a string containing the zarr info for each array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">array</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">():</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">provenances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the (timestamp, record) pairs representing</span>
<span class="sd">        the provenances for this data container.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">timestamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">provenances_timestamp</span><span class="p">[:]</span>
        <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">provenances_record</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_provenances</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">timestamp</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">record</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>


<div class="viewcode-block" id="Site">
<a class="viewcode-back" href="../../api.html#tsinfer.Site">[docs]</a>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Site</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single site. Mirrors the definition in tskit with some additional fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO document properly.</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">position</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">ancestral_allele</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>  <span class="c1"># here -1 (tskit.MISSING_DATA) means none defined</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">alleles</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ancestral_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestral_allele</span> <span class="o">==</span> <span class="n">MISSING_DATA</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestral_allele</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">reorder_alleles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The alleles list reordered so that the ancestral allele is first</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestral_allele</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestral_allele</span><span class="p">],)</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alleles</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestral_allele</span><span class="p">]</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestral_allele</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">alleles</span></div>



<div class="viewcode-block" id="Variant">
<a class="viewcode-back" href="../../api.html#tsinfer.Variant">[docs]</a>
<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Variant</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single variant. Mirrors the definition in tskit.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO document properly.</span>
    <span class="n">site</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">genotypes</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">alleles</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span></div>



<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Individual</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An Individual object, representing a single individual which may contain multiple</span>
<span class="sd">    *samples* (i.e. phased genomes). For instance, a diploid individual will have</span>
<span class="sd">    two sample genomes. This is deliberately similar to a :class:`tskit.Individual`.</span>

<span class="sd">    Individuals are created with `SampleData.add_individual`. If a tree sequence</span>
<span class="sd">    is inferred from a sample data file containing individuals, these individuals (and</span>
<span class="sd">    the data associated with them) will carry through to the inferred tree sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO document properly.</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">location</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="c1"># the samples attribute is filled in programmatically, not stored per individual</span>
    <span class="n">samples</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="c1"># Not in equivalent tskit object</span>
    <span class="n">population</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>  <span class="c1"># NB: differs from tskit, which stores this per node</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>  <span class="c1"># NB: differs from tskit, which stores this per node</span>


<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Sample</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Sample object, representing a single haploid genome or chromosome. Several</span>
<span class="sd">    Samples can be associated with the same :class:`Individual`: for example a</span>
<span class="sd">    diploid individual will have one maternal and one paternal sample.</span>

<span class="sd">    If a tree sequence is inferred from a set of samples, each sample will be</span>
<span class="sd">    associated with a tskit &quot;node&quot;, which will be flagged up with</span>
<span class="sd">    :data:`tskit.NODE_IS_SAMPLE`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO document properly.</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">individual</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>


<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Population</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Population object. Mirrors :class:`tskit.Population`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO document properly.</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SampleData</span><span class="p">(</span><span class="n">DataContainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SampleData(sequence_length=0, *, path=None, num_flush_threads=0, \</span>
<span class="sd">    compressor=DEFAULT_COMPRESSOR, chunk_size=1024, max_file_size=None)</span>

<span class="sd">    .. deprecated:: 0.4.0</span>
<span class="sd">       This class is deprecated and will be removed in a future version.</span>
<span class="sd">       Please use :class:`VariantData` instead.</span>

<span class="sd">    Class representing input sample data used for inference.</span>
<span class="sd">    for details on the structure of this file.</span>

<span class="sd">    The most common usage for this class will be to import data from some</span>
<span class="sd">    external source and save it to file for later use. This will usually</span>
<span class="sd">    follow a pattern like:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        sample_data = tsinfer.SampleData(path=&quot;mydata.samples&quot;)</span>
<span class="sd">        sample_data.add_site(position=1234, genotypes=[0, 0, 1, 0], alleles=[&quot;G&quot;, &quot;C&quot;])</span>
<span class="sd">        sample_data.add_site(position=5678, genotypes=[1, 1, 1, 0], alleles=[&quot;A&quot;, &quot;T&quot;])</span>
<span class="sd">        sample_data.finalise()</span>

<span class="sd">    This creates a sample data file for four haploid samples and two sites, and</span>
<span class="sd">    saves it in the file &quot;mydata.samples&quot;. Note that the call to</span>
<span class="sd">    :meth:`.finalise` is essential here to ensure that all data will be</span>
<span class="sd">    correctly flushed to disk. For convenience, a context manager may</span>
<span class="sd">    also be used to ensure this is done:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        with tsinfer.SampleData(path=&quot;mydata.samples&quot;) as sample_data:</span>
<span class="sd">            sample_data.add_site(1234, [0, 0, 1, 0], [&quot;G&quot;, &quot;C&quot;])</span>
<span class="sd">            sample_data.add_site(5678, [1, 1, 1, 0], [&quot;A&quot;, &quot;T&quot;])</span>

<span class="sd">    More complex :ref:`data models &lt;sec_inference_data_model&gt;` consisting</span>
<span class="sd">    of populations and polyploid individuals can also be specified. For</span>
<span class="sd">    example, we might have:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        with tsinfer.SampleData(path=&quot;mydata.samples&quot;) as sample_data:</span>
<span class="sd">            # Define populations</span>
<span class="sd">            sample_data.add_population(metadata={&quot;name&quot;: &quot;CEU&quot;})</span>
<span class="sd">            sample_data.add_population(metadata={&quot;name&quot;: &quot;YRI&quot;})</span>
<span class="sd">            # Define individuals</span>
<span class="sd">            sample_data.add_individual(ploidy=2, population=0, metadata={&quot;name&quot;: &quot;NA12&quot;})</span>
<span class="sd">            sample_data.add_individual(ploidy=2, population=0, metadata={&quot;name&quot;: &quot;NA13&quot;})</span>
<span class="sd">            sample_data.add_individual(ploidy=2, population=0, metadata={&quot;name&quot;: &quot;NA14&quot;})</span>
<span class="sd">            sample_data.add_individual(ploidy=2, population=1, metadata={&quot;name&quot;: &quot;NA15&quot;})</span>
<span class="sd">            # Define sites and genotypes</span>
<span class="sd">            sample_data.add_site(1234, [0, 1, 1, 1, 0, 0, 0, 0], [&quot;G&quot;, &quot;C&quot;])</span>
<span class="sd">            sample_data.add_site(5678, [0, 0, 0, 0, 0, 0, 1, 1], [&quot;A&quot;, &quot;T&quot;])</span>

<span class="sd">    In this example we defined two populations and four diploid individuals,</span>
<span class="sd">    and so our genotypes arrays are of length eight. Thus, at first site the</span>
<span class="sd">    first individual is heterozygous, the second is homozygous with the derived</span>
<span class="sd">    allele and the other two individuals are homozygous with the ancestral</span>
<span class="sd">    allele. To illustrate how we can use site and population metadata to link</span>
<span class="sd">    up with external data sources we use the 1000 genomes identifiers (although</span>
<span class="sd">    of course the genotype data is fake). Here we suppose that we have the</span>
<span class="sd">    famous NA12878 trio from the CEU population, and one other individual from</span>
<span class="sd">    the YRI population. This metadata is then embedded in the final tree</span>
<span class="sd">    sequence that we infer, allowing us to use it conveniently in downstream</span>
<span class="sd">    analyses.</span>

<span class="sd">    .. note:: If a ``path`` is specified, the ``max_file_size`` option puts an</span>
<span class="sd">        upper limit on the possible size of the created file. On non-Windows</span>
<span class="sd">        systems, space for this file is not immediately allocated but just</span>
<span class="sd">        &quot;reserved&quot; using sparse file systems. However, on Windows systems</span>
<span class="sd">        the file is allocated immediately, so ``max_file_size`` takes a smaller</span>
<span class="sd">        default value, to avoid allocating very large files for no reason.</span>
<span class="sd">        Users who wish to run large inferences on Windows may therefore need to</span>
<span class="sd">        explictly set an appropriate ``max_file_size``. Note that the</span>
<span class="sd">        ``max_file_size`` is only used while the file is being built: one the</span>
<span class="sd">        file has been finalised, it is shrunk to its minimum size.</span>

<span class="sd">    :param float sequence_length: If specified, this is the sequence length</span>
<span class="sd">        that will be associated with the tree sequence output by</span>
<span class="sd">        :func:`tsinfer.infer` and :func:`tsinfer.match_samples`. If provided</span>
<span class="sd">        site coordinates must be less than this value.</span>
<span class="sd">    :param str path: The path of the file to store the sample data. If None,</span>
<span class="sd">        the information is stored in memory and not persistent.</span>
<span class="sd">    :param int num_flush_threads: The number of background threads to use</span>
<span class="sd">        for compressing data and flushing to disc. If &lt;= 0, do not spawn</span>
<span class="sd">        any threads but use a synchronous algorithm instead. Default=0.</span>
<span class="sd">    :param numcodecs.abc.Codec compressor: A :class:`numcodecs.abc.Codec`</span>
<span class="sd">        instance to use for compressing data. Any codec may be used, but</span>
<span class="sd">        problems may occur with very large datasets on certain codecs as</span>
<span class="sd">        they cannot compress buffers &gt;2GB. If None, do not use any compression.</span>
<span class="sd">        Default=:class:`numcodecs.zstd.Zstd`.</span>
<span class="sd">    :param int chunk_size: The chunk size used for</span>
<span class="sd">        `zarr arrays &lt;http://zarr.readthedocs.io/&gt;`_. This affects</span>
<span class="sd">        compression level and algorithm performance. Default=1024.</span>
<span class="sd">    :param int max_file_size: If a file is being used to store this data, set</span>
<span class="sd">        a maximum size in bytes for the stored file. If None, the default</span>
<span class="sd">        value of 1GiB (2**30 bytes) is used on Windows and 1TiB (2**40 bytes)</span>
<span class="sd">        on other platforms (see above for details).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">FORMAT_NAME</span> <span class="o">=</span> <span class="s2">&quot;tsinfer-sample-data&quot;</span>
    <span class="n">FORMAT_VERSION</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># State machine for handling automatic addition of samples.</span>
    <span class="n">ADDING_POPULATIONS</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ADDING_SAMPLES</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ADDING_SITES</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;SampleData is deprecated&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;sequence_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;metadata_schema&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="o">.</span><span class="n">permissive_json</span><span class="p">()</span><span class="o">.</span><span class="n">schema</span>
        <span class="p">)</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size</span><span class="p">,)</span>
        <span class="n">populations_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;populations&quot;</span><span class="p">)</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">populations_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
            <span class="n">object_codec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_metadata_codec</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">populations_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;metadata_schema&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_populations_writer</span> <span class="o">=</span> <span class="n">BufferedItemWriter</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;metadata&quot;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">},</span> <span class="n">num_threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_flush_threads</span>
        <span class="p">)</span>

        <span class="n">individuals_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;individuals&quot;</span><span class="p">)</span>
        <span class="n">individuals_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;metadata_schema&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">individuals_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
            <span class="n">object_codec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_metadata_codec</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">individuals_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;location&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;array:f8&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">individuals_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;time&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">population</span> <span class="o">=</span> <span class="n">individuals_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;population&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="n">individuals_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;flags&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_writer</span> <span class="o">=</span> <span class="n">BufferedItemWriter</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;metadata&quot;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">,</span>
                <span class="s2">&quot;location&quot;</span><span class="p">:</span> <span class="n">location</span><span class="p">,</span>
                <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span>
                <span class="s2">&quot;population&quot;</span><span class="p">:</span> <span class="n">population</span><span class="p">,</span>
                <span class="s2">&quot;flags&quot;</span><span class="p">:</span> <span class="n">flags</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">num_threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_flush_threads</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">samples_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;samples&quot;</span><span class="p">)</span>
        <span class="n">individual</span> <span class="o">=</span> <span class="n">samples_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;individual&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_samples_writer</span> <span class="o">=</span> <span class="n">BufferedItemWriter</span><span class="p">(</span>
            <span class="p">{</span><span class="s2">&quot;individual&quot;</span><span class="p">:</span> <span class="n">individual</span><span class="p">},</span>
            <span class="n">num_threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_flush_threads</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">sites_group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;sites&quot;</span><span class="p">)</span>
        <span class="n">sites_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;metadata_schema&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">sites_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;position&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sites_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;time&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sites_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;genotypes&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size</span><span class="p">),</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sites_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;alleles&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
            <span class="n">object_codec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_metadata_codec</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sites_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;ancestral_allele&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sites_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">,</span>
            <span class="n">object_codec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_metadata_codec</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_last_position</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sites_writer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># We are initially in the ADDING_POPULATIONS state.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDING_POPULATIONS</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;SampleData(num_samples=</span><span class="si">{}</span><span class="s2">, num_sites=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span>
        <span class="p">)</span>

    <span class="c1"># Note: abstracting the process of getting and setting the metadata schemas</span>
    <span class="c1"># out here so we can do better validation of the inputs/optionally accept</span>
    <span class="c1"># a tskit MetadataSchema object rather than a dict.</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__metadata_schema_getter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zarr_group</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">zarr_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;metadata_schema&quot;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__metadata_schema_setter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zarr_group</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="c1"># Make sure we can parse it.</span>
        <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parsed_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
            <span class="c1"># We only support the JSON codec for now for simplicity.</span>
            <span class="k">if</span> <span class="n">parsed_schema</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="s2">&quot;codec&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;json&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only the JSON codec is currently supported&quot;</span><span class="p">)</span>
        <span class="n">zarr_group</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;metadata_schema&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">schema</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sequence_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;sequence_length&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;metadata_schema&quot;</span><span class="p">]</span>

    <span class="nd">@metadata_schema</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have a schema for top-level metadata&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__metadata_schema_setter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span>

    <span class="nd">@metadata</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">metadata</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">populations_metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata_schema_getter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;populations&quot;</span><span class="p">])</span>

    <span class="nd">@populations_metadata_schema</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">populations_metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__metadata_schema_setter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;populations&quot;</span><span class="p">],</span> <span class="n">schema</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata_schema_getter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;individuals&quot;</span><span class="p">])</span>

    <span class="nd">@individuals_metadata_schema</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__metadata_schema_setter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;individuals&quot;</span><span class="p">],</span> <span class="n">schema</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata_schema_getter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sites&quot;</span><span class="p">])</span>

    <span class="nd">@sites_metadata_schema</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__metadata_schema_setter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sites&quot;</span><span class="p">],</span> <span class="n">schema</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_populations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations_metadata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_individual</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_metadata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">populations_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;populations/metadata&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;individuals/metadata&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_location</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;individuals/location&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;individuals/time&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_population</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;individuals/population&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;individuals/flags&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">samples_individual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;samples/individual&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_genotypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The &quot;raw&quot; genotypes array for each site, as passed in when adding sites. The</span>
<span class="sd">        values in this array correspond to indexes into the :attr:`sites_alleles` array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sites/genotypes&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sites/position&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sites/time&quot;</span><span class="p">]</span>

    <span class="nd">@sites_time</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_edit_mode</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sites/time&quot;</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_alleles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The alleles list for each site, in the order given when adding sites. If</span>
<span class="sd">        missing data is present, the last allelic state will be ``None``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sites/alleles&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_ancestral_allele</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index into each :attr:`sites_alleles` list which corresponds to the</span>
<span class="sd">        ancestral state. If the ancestral state is unknown, this is indicated by</span>
<span class="sd">        a value of tskit.MISSING_DATA (-1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sites/ancestral_allele&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Maintains backwards compatibility: in previous tsinfer versions the</span>
            <span class="c1"># ancestral allele was always the zeroth element in the alleles list</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sites/metadata&quot;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;sequence_length&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;metadata_schema&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;num_populations&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;num_individuals&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;num_samples&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;num_sites&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;populations/metadata_schema&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations_metadata_schema</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;populations/metadata&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">populations_metadata</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;individuals/metadata_schema&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_metadata_schema</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;individuals/metadata&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_metadata</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;individuals/location&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_location</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;individuals/time&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_time</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;individuals/population&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_population</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;individuals/flags&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_flags</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;samples/individual&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples_individual</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;sites/position&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;sites/time&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_time</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;sites/alleles&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_alleles</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;sites/genotypes&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_genotypes</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;sites/metadata_schema&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_metadata_schema</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;sites/metadata&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_metadata</span><span class="p">)),</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_str</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">formats_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">format_name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">format_name</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_version</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">format_version</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">populations_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">num_populations</span>
            <span class="c1"># Need to take a different approach with np object arrays.</span>
            <span class="ow">and</span> <span class="n">np_obj_equal</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">populations_metadata</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">populations_metadata</span><span class="p">[:]</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">num_individuals</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">individuals_time</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">individuals_time</span><span class="p">[:],</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_flags</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">individuals_flags</span><span class="p">[:])</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">individuals_population</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">individuals_population</span><span class="p">[:]</span>
            <span class="p">)</span>
            <span class="ow">and</span> <span class="n">np_obj_equal</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">individuals_metadata</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">individuals_metadata</span><span class="p">[:]</span>
            <span class="p">)</span>
            <span class="ow">and</span> <span class="n">np_obj_equal</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">individuals_location</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">individuals_location</span><span class="p">[:]</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">samples_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">num_samples</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">samples_individual</span><span class="p">[:]</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">samples_individual</span><span class="p">[:]</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">sites_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">num_sites</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:]</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:])</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_genotypes</span><span class="p">[:]</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sites_genotypes</span><span class="p">[:])</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_time</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">sites_time</span><span class="p">[:],</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np_obj_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_metadata</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">sites_metadata</span><span class="p">[:])</span>
            <span class="ow">and</span> <span class="n">np_obj_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_alleles</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">sites_alleles</span><span class="p">[:])</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">data_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if all the data attributes of this input file and the</span>
<span class="sd">        specified input file are equal. This compares every attribute except</span>
<span class="sd">        the provenance.</span>

<span class="sd">        To compare two `SampleData` instances for exact equality of</span>
<span class="sd">        all data including provenance data, use ``s1 == s2``.</span>

<span class="sd">        :param SampleData other: The other `SampleData` instance to</span>
<span class="sd">            compare with.</span>
<span class="sd">        :return: ``True`` if the data held in this `SampleData`</span>
<span class="sd">            instance is identical to the date held in the other instance.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sequence_length</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">formats_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">assert_data_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The same as :meth:`.data_equal`, but raises an assertion rather than returning</span>
<span class="sd">        False. This is useful for testing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">formats_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">subset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">individuals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a subset of this sample data file consisting of the specified</span>
<span class="sd">        individuals and sites. It is important to note that these are</span>
<span class="sd">        *individual* IDs and not *sample* IDs (corresponding to distinct</span>
<span class="sd">        haplotypes within an individual). When working with haploid data, the</span>
<span class="sd">        individual and sample IDs are guaranteed to be the same, and so can be</span>
<span class="sd">        used interchangably.</span>

<span class="sd">        :param arraylike individuals: The individual IDs to retain in the</span>
<span class="sd">            returned subset. IDs must be unique, and refer to valid individuals</span>
<span class="sd">            in the current dataset. IDs can be supplied in any order,</span>
<span class="sd">            and the order will be preserved in the returned data file (i.e.,</span>
<span class="sd">            ``individuals[0]`` will be the first individual in the new</span>
<span class="sd">            dataset, etc).</span>
<span class="sd">        :param arraylike sites: The site IDs to retain in the</span>
<span class="sd">            returned subset. IDs must be unique, and refer to valid sites</span>
<span class="sd">            in the current dataset. Site IDs can be supplied in any order,</span>
<span class="sd">            but the order will *not* be preserved in the returned data file,</span>
<span class="sd">            so that sites are always in position sorted order in the output.</span>
<span class="sd">        :param float sequence_length: The sequence length to use for the</span>
<span class="sd">            returned object. If None, use the same sequence length as in the</span>
<span class="sd">            original sample data file.</span>
<span class="sd">        :param \\**kwargs: Further arguments passed to the `SampleData`</span>
<span class="sd">            constructor.</span>
<span class="sd">        :return: A `SampleData` object.</span>
<span class="sd">        :rtype: `SampleData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">individuals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">individuals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">)</span>
        <span class="n">individuals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">individuals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">individuals</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">individuals</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Individual ID out of bounds&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">individuals</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">individuals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Duplicate individual IDs&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sites</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sites</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sites</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Site ID out of bounds&quot;</span><span class="p">)</span>
        <span class="n">num_sites</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="c1"># Store the sites as a set for quick lookup.</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_sites</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Duplicate site IDS&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sequence_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sequence_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="k">with</span> <span class="n">SampleData</span><span class="p">(</span><span class="n">sequence_length</span><span class="o">=</span><span class="n">sequence_length</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">subset</span><span class="p">:</span>
            <span class="c1"># NOTE We don&#39;t bother filtering the populations, but we could.</span>
            <span class="k">for</span> <span class="n">population</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">():</span>
                <span class="n">subset</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">population</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">sample_selection</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">individual_id</span> <span class="ow">in</span> <span class="n">individuals</span><span class="p">:</span>
                <span class="n">individual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">individual</span><span class="p">(</span><span class="n">individual_id</span><span class="p">)</span>
                <span class="n">sample_selection</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">samples</span><span class="p">)</span>
                <span class="n">subset</span><span class="o">.</span><span class="n">add_individual</span><span class="p">(</span>
                    <span class="n">location</span><span class="o">=</span><span class="n">individual</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="n">individual</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">individual</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                    <span class="n">population</span><span class="o">=</span><span class="n">individual</span><span class="o">.</span><span class="n">population</span><span class="p">,</span>
                    <span class="n">ploidy</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">samples</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="n">sample_selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_selection</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_selection</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have at least one sample&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">variant</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">variant</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                    <span class="n">subset</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span>
                        <span class="n">position</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                        <span class="n">genotypes</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">genotypes</span><span class="p">[</span><span class="n">sample_selection</span><span class="p">],</span>
                        <span class="n">alleles</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">alleles</span><span class="p">,</span>
                        <span class="n">metadata</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
                        <span class="n">time</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="p">():</span>
                <span class="n">subset</span><span class="o">.</span><span class="n">add_provenance</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>
            <span class="n">subset</span><span class="o">.</span><span class="n">record_provenance</span><span class="p">(</span><span class="n">command</span><span class="o">=</span><span class="s2">&quot;subset&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subset</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">min_site_times</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">individuals_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a numpy array of the lower bound of the time of sites in the SampleData</span>
<span class="sd">        file. Each individual with a nonzero time (from the individuals_time array)</span>
<span class="sd">        gives a lower bound on the age of sites where the individual carries a</span>
<span class="sd">        derived allele.</span>

<span class="sd">        :return: A numpy array of the lower bound for each sites time.</span>
<span class="sd">        :rtype: numpy.ndarray(dtype=float64)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">samples_individual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_individual</span><span class="p">[:]</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">samples_individual</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">samples_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_time</span><span class="p">[:][</span><span class="n">samples_individual</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">samples_time</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Individuals cannot have negative times&quot;</span><span class="p">)</span>
        <span class="n">historical_samples</span> <span class="o">=</span> <span class="n">samples_time</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">historical_samples_time</span> <span class="o">=</span> <span class="n">samples_time</span><span class="p">[</span><span class="n">historical_samples</span><span class="p">]</span>
        <span class="n">sites_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">():</span>
            <span class="n">historical_genos</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">genotypes</span><span class="p">[</span><span class="n">historical_samples</span><span class="p">]</span>
            <span class="n">derived</span> <span class="o">=</span> <span class="n">historical_genos</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">derived</span><span class="p">):</span>
                <span class="n">historical_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">historical_samples_time</span><span class="p">[</span><span class="n">derived</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">historical_bound</span> <span class="o">&gt;</span> <span class="n">sites_bound</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span><span class="p">]:</span>
                    <span class="n">sites_bound</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">historical_bound</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">individuals_only</span><span class="p">:</span>
            <span class="n">sites_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_time</span><span class="p">[:],</span> <span class="n">sites_bound</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sites_bound</span>

    <span class="c1">####################################</span>
    <span class="c1"># Write mode</span>
    <span class="c1">####################################</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_tree_sequence</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">ts</span><span class="p">,</span>
        <span class="n">use_sites_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_individuals_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a SampleData instance from the sample nodes in an existing tree sequence.</span>
<span class="sd">        Each sample node in the tree sequence results in a sample created in the returned</span>
<span class="sd">        object. Populations in the tree sequence will be copied into the returned object.</span>
<span class="sd">        Individuals in the tree sequence that are associated with any sample nodes will</span>
<span class="sd">        also be incorporated: the ploidy of each individual is assumed to be the number</span>
<span class="sd">        of sample nodes which reference that individual; individuals with no sample nodes</span>
<span class="sd">        are omitted. A new haploid individual is created for any sample node which lacks</span>
<span class="sd">        an associated individual in the existing tree sequence. Thus a tree sequence</span>
<span class="sd">        with ``u`` sample nodes but no individuals will be translated into a SampleData</span>
<span class="sd">        file with ``u`` haploid individuals and ``u`` samples.</span>

<span class="sd">        Metadata associated with individuals, populations, sites, and at the top level</span>
<span class="sd">        of the tree sequence, is also stored in the appropriate places in the returned</span>
<span class="sd">        SampleData instance. Any such metadata must either have a schema defined</span>
<span class="sd">        or be JSON encodable text. See the `tskit documentation</span>
<span class="sd">        &lt;https://tskit.readthedocs.io/en/stable/metadata.html&gt;`_ for more details</span>
<span class="sd">        on metadata schemas.</span>

<span class="sd">        :param tskit.TreeSequence ts: The :class:`tskit.TreeSequence` from which to</span>
<span class="sd">            generate samples.</span>
<span class="sd">        :param bool use_sites_time: If ``True``, the times of nodes in the tree</span>
<span class="sd">            sequence are used to set a time for each site (which affects the relative</span>
<span class="sd">            temporal order of ancestors during inference). Times for a site are only</span>
<span class="sd">            used if there is a single mutation at that site, in which case the node</span>
<span class="sd">            immediately below the mutation is taken as the origination time for the</span>
<span class="sd">            variant. If ``False``, the frequency of the variant is used as a proxy for</span>
<span class="sd">            the relative variant time (see :meth:`.add_site`). Defaults to ``False``.</span>
<span class="sd">        :param bool use_individuals_time: If ``True``, use the time of the sample nodes</span>
<span class="sd">            in the tree sequence as the time of the individuals associated with</span>
<span class="sd">            those nodes in the sample data file. This is likely only to be meaningful if</span>
<span class="sd">            ``use_sites_time`` is also ``True``. If ``False``, all individuals are set</span>
<span class="sd">            to time 0. Defaults to ``False``.</span>
<span class="sd">        :param \\**kwargs: Further arguments passed to the `SampleData`</span>
<span class="sd">            constructor.</span>
<span class="sd">        :return: A `SampleData` object.</span>
<span class="sd">        :rtype: `SampleData`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">encode_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">metadata</span>

        <span class="k">if</span> <span class="n">use_sites_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_sites_time</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">use_individuals_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">use_individuals_time</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">tables</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">tables</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">sequence_length</span><span class="o">=</span><span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">schema</span>
        <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">schema</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">metadata</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">schema</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">populations_metadata_schema</span> <span class="o">=</span> <span class="n">schema</span>
        <span class="k">for</span> <span class="n">population</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">populations</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="n">encode_metadata</span><span class="p">(</span><span class="n">population</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">schema</span><span class="p">))</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">schema</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals_metadata_schema</span> <span class="o">=</span> <span class="n">schema</span>
        <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">individuals</span><span class="p">():</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">individual</span><span class="o">.</span><span class="n">nodes</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">first_node</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">time</span> <span class="o">!=</span> <span class="n">first_node</span><span class="o">.</span><span class="n">time</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;All nodes for individual </span><span class="si">{}</span><span class="s2"> must have the same time&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">individual</span><span class="o">.</span><span class="n">id</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">population</span> <span class="o">!=</span> <span class="n">first_node</span><span class="o">.</span><span class="n">population</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;All nodes for individual </span><span class="si">{}</span><span class="s2"> must be in the same &quot;</span>
                            <span class="s2">&quot;population&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                        <span class="p">)</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">encode_metadata</span><span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">use_individuals_time</span><span class="p">:</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="n">first_node</span><span class="o">.</span><span class="n">time</span>
                    <span class="k">if</span> <span class="n">time</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">use_sites_time</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Incompatible timescales: site frequencies used for times &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;(use_sites_time=False), but node </span><span class="si">{</span><span class="n">first_node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> in &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;individual </span><span class="si">{</span><span class="n">individual</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> has a nonzero time and &quot;</span>
                            <span class="s2">&quot;use_individuals_time=True. Please set site times manually.&quot;</span>
                        <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_individual</span><span class="p">(</span>
                    <span class="n">location</span><span class="o">=</span><span class="n">individual</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                    <span class="n">population</span><span class="o">=</span><span class="n">first_node</span><span class="o">.</span><span class="n">population</span><span class="p">,</span>
                    <span class="n">flags</span><span class="o">=</span><span class="n">individual</span><span class="o">.</span><span class="n">flags</span><span class="p">,</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                    <span class="n">ploidy</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">samples</span><span class="p">():</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">individual</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">:</span>
                <span class="c1"># The sample node has no individual: create a haploid individual for it</span>
                <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">use_individuals_time</span><span class="p">:</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">time</span>
                    <span class="k">if</span> <span class="n">time</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">use_sites_time</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Incompatible timescales: site frequencies used for times &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;(use_sites_time=False), but node </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="s2">&quot;has a nonzero time and use_individuals_time=True. &quot;</span>
                            <span class="s2">&quot;Please set site times manually.&quot;</span>
                        <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_individual</span><span class="p">(</span>
                    <span class="n">population</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">population</span><span class="p">,</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">time</span> <span class="k">if</span> <span class="n">use_individuals_time</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="n">ploidy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">schema</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites_metadata_schema</span> <span class="o">=</span> <span class="n">schema</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">variants</span><span class="p">():</span>
            <span class="n">variant_time</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">UNKNOWN_TIME</span>
            <span class="k">if</span> <span class="n">use_sites_time</span><span class="p">:</span>
                <span class="n">variant_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">mutations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">variant_time</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">mutations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="n">time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span>
                <span class="n">v</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                <span class="n">v</span><span class="o">.</span><span class="n">genotypes</span><span class="p">,</span>
                <span class="n">v</span><span class="o">.</span><span class="n">alleles</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">encode_metadata</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">schema</span><span class="p">),</span>
                <span class="n">time</span><span class="o">=</span><span class="n">variant_time</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># Insert all the provenance from the original tree sequence.</span>
        <span class="k">for</span> <span class="n">prov</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">provenances</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_provenance</span><span class="p">(</span><span class="n">prov</span><span class="o">.</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">prov</span><span class="o">.</span><span class="n">record</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">record_provenance</span><span class="p">(</span><span class="n">command</span><span class="o">=</span><span class="s2">&quot;from-tree-sequence&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finalise</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_alloc_site_writer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have at least 1 sample&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites_genotypes</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;position&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">,</span>
            <span class="s2">&quot;genotypes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_genotypes</span><span class="p">,</span>
            <span class="s2">&quot;alleles&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_alleles</span><span class="p">,</span>
            <span class="s2">&quot;metadata&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_metadata</span><span class="p">,</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_time</span><span class="p">,</span>
            <span class="s2">&quot;ancestral_allele&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_ancestral_allele</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sites_writer</span> <span class="o">=</span> <span class="n">BufferedItemWriter</span><span class="p">(</span>
            <span class="n">arrays</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_flush_threads</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new :ref:`sec_inference_data_model_population` to this</span>
<span class="sd">        `SampleData` and returns its ID.</span>

<span class="sd">        All calls to this method must be made **before** individuals or sites</span>
<span class="sd">        are defined.</span>

<span class="sd">        :param dict metadata: A JSON encodable dict-like object containing</span>
<span class="sd">            metadata that is to be associated with this population.</span>
<span class="sd">        :return: The ID of the newly added population.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_build_mode</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDING_POPULATIONS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot add populations after adding samples or sites&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_populations_writer</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_individual</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ploidy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">population</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new :ref:`sec_inference_data_model_individual` to this</span>
<span class="sd">        `SampleData` and returns its ID and those of the resulting additional</span>
<span class="sd">        samples. Adding an individual with ploidy ``k`` results in ``k`` new samples</span>
<span class="sd">        being added, and each of these samples will be associated with the</span>
<span class="sd">        new individual. Each new sample will also be associated with the specified</span>
<span class="sd">        population ID. It is an error to specify a population ID that does not</span>
<span class="sd">        correspond to a population defined using :meth:`.add_population`.</span>

<span class="sd">        All calls to this method must be made **after** populations are defined</span>
<span class="sd">        using :meth:`.add_population` and **before** sites are defined using</span>
<span class="sd">        :meth:`.add_site`.</span>

<span class="sd">        :param int ploidy: The ploidy of this individual. This corresponds to the</span>
<span class="sd">            number of samples added that refer to this individual. Defaults to 1</span>
<span class="sd">            (haploid).</span>
<span class="sd">        :param dict metadata: A JSON encodable dict-like object containing</span>
<span class="sd">            metadata that is to be associated with this individual.</span>
<span class="sd">        :param int population: The ID of the population to associate with this</span>
<span class="sd">            individual (or more precisely, with the samples for this individual).</span>
<span class="sd">            If not specified or None, defaults to the null population (-1).</span>
<span class="sd">        :param arraylike location: An array-like object defining n-dimensional</span>
<span class="sd">            spatial location of this individual. If not specified or None, the</span>
<span class="sd">            empty location is stored.</span>
<span class="sd">        :param float time: The historical time into the past when the samples</span>
<span class="sd">            associated with this individual were taken. By default we assume that</span>
<span class="sd">            all samples come from the present time (i.e. the default time is 0).</span>
<span class="sd">        :param int flags: The bitwise flags for this individual.</span>
<span class="sd">        :return: The ID of the newly added individual and a list of the sample</span>
<span class="sd">            IDs also added.</span>
<span class="sd">        :rtype: tuple(int, list(int))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_build_mode</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDING_POPULATIONS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_populations_writer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_populations_writer</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDING_SAMPLES</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDING_SAMPLES</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot add individuals after adding sites&quot;</span><span class="p">)</span>

        <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">time</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;time must be a single finite number&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">population</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span>
        <span class="k">if</span> <span class="n">population</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;population ID out of bounds&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ploidy</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ploidy must be at least 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">location</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">individual_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_writer</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">),</span>
            <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
            <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sample_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ploidy</span><span class="p">):</span>
            <span class="n">sid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_samples_writer</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                <span class="n">individual</span><span class="o">=</span><span class="n">individual_id</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">sample_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">individual_id</span><span class="p">,</span> <span class="n">sample_ids</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_site</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">position</span><span class="p">,</span>
        <span class="n">genotypes</span><span class="p">,</span>
        <span class="n">alleles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ancestral_allele</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new site to this `SampleData` and returns its ID.</span>

<span class="sd">        At a minimum, the new site must specify the ``position`` and</span>
<span class="sd">        ``genotypes``. Sites must be added in increasing order of position;</span>
<span class="sd">        duplicate positions are **not** supported. For each site a list of</span>
<span class="sd">        ``alleles`` may be supplied. This list defines the ancestral and</span>
<span class="sd">        derived states at the site. For example, if we set ``alleles=[&quot;A&quot;,</span>
<span class="sd">        &quot;T&quot;]`` then the ancestral state is &quot;A&quot; and the derived state is &quot;T&quot;.</span>
<span class="sd">        The observed state for each sample is then encoded using the</span>
<span class="sd">        ``genotypes`` parameter. Thus if we have ``n`` samples then</span>
<span class="sd">        this must be a one dimensional array-like object with length ``n``.</span>
<span class="sd">        The ``genotypes`` index into the list of ``alleles``, so that for</span>
<span class="sd">        a given array ``g`` and sample index ``j``, ``g[j]`` should contain</span>
<span class="sd">        ``0`` if sample ``j`` carries the ancestral state at this site and</span>
<span class="sd">        ``1`` if it carries the derived state. For multiple derived states,</span>
<span class="sd">        there may be more than 2 ``alleles`, and ``g[j]`` can be greater</span>
<span class="sd">        than ``1``, but such sites are not used for inference. All sites must</span>
<span class="sd">        have genotypes for the same number of samples.</span>

<span class="sd">        All populations and individuals must be defined **before** this method</span>
<span class="sd">        is called. If no individuals have been defined using</span>
<span class="sd">        :meth:`.add_individual`, the first call to this method adds ``n``</span>
<span class="sd">        haploid individuals, where ``n`` is the length of the ``genotypes``</span>
<span class="sd">        array.</span>

<span class="sd">        :param float position: The floating point position of this site. Must be</span>
<span class="sd">            less than the ``sequence_length`` if provided to the `SampleData`</span>
<span class="sd">            constructor. Must be greater than all previously added sites.</span>
<span class="sd">        :param arraylike genotypes: An array-like object defining the sample</span>
<span class="sd">            genotypes at this site. The array of genotypes corresponds to the</span>
<span class="sd">            observed alleles for each sample, represented by indexes into the</span>
<span class="sd">            alleles array. Missing sample data can be represented by tskit.MISSING_DATA</span>
<span class="sd">            in this array. The input is converted to a numpy array with</span>
<span class="sd">            dtype ``np.int8``; therefore, for maximum efficiency ensure</span>
<span class="sd">            that the input array is also of this type.</span>
<span class="sd">        :param list(str) alleles: A list of strings defining the alleles at this</span>
<span class="sd">            site. Only biallelic sites can currently be used for inference. Sites</span>
<span class="sd">            with 3 or more non-missing alleles cannot have ``inference`` (below)</span>
<span class="sd">            set to ``True``. If missing data is present in the ``genotypes`` array,</span>
<span class="sd">            the stored list of alleles will be modified as necessary so that</span>
<span class="sd">            ``alleles[tskit.MISSING_DATA] == None``. If ``alleles`` is not specified</span>
<span class="sd">            or None, a default of [&quot;0&quot;, &quot;1&quot;] is used.</span>
<span class="sd">        :param dict metadata: A JSON encodable dict-like object containing</span>
<span class="sd">            metadata that is to be associated with this site.</span>
<span class="sd">        :param float time: The time of occurence (pastwards) of the mutation to the</span>
<span class="sd">            derived state at this site. If not specified or None, the frequency of the</span>
<span class="sd">            derived alleles (i.e., the proportion of non-zero values in the genotypes,</span>
<span class="sd">            out of all the non-missing values) will be used in inference. For</span>
<span class="sd">            biallelic sites this frequency should provide a reasonable estimate</span>
<span class="sd">            of the relative time, as used to order ancestral haplotypes during the</span>
<span class="sd">            inference process. For sites not used in inference, such as singletons or</span>
<span class="sd">            sites with more than two alleles or when the time is specified as</span>
<span class="sd">            ``np.nan``, then the value is unused. Defaults to None.</span>
<span class="sd">        :param int ancestral_allele: A positive index into the alleles array, specifying</span>
<span class="sd">            which allele is the ancestral state, or ``tskit.MISSING_DATA`` (-1) if the</span>
<span class="sd">            ancestral state is unknown (in which case the site will not be used for</span>
<span class="sd">            inference, and the ancestral state will be inferred using parsimony).</span>
<span class="sd">            Default: ``None``, treated as ``0``, so that the first allele in the list</span>
<span class="sd">            is taken as the ancestral state.</span>

<span class="sd">        :return: The ID of the newly added site.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">genotypes</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">genotypes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_build_mode</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDING_POPULATIONS</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">genotypes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We could just raise an error here but we set the state</span>
                <span class="c1"># here so that we can raise the same error as other</span>
                <span class="c1"># similar conditions.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDING_SAMPLES</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Add in the default haploid samples.</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">genotypes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_individual</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDING_SAMPLES</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_writer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_samples_writer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_alloc_site_writer</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDING_SITES</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_position</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDING_SITES</span>

        <span class="k">if</span> <span class="n">alleles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">alleles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">]</span>
        <span class="n">n_alleles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">)</span>
        <span class="n">non_missing</span> <span class="o">=</span> <span class="n">genotypes</span> <span class="o">!=</span> <span class="n">MISSING_DATA</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">alleles</span><span class="p">))</span> <span class="o">!=</span> <span class="n">n_alleles</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Alleles must be distinct&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_alleles</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">:</span>
            <span class="c1"># This is mandated by tskit&#39;s map_mutations function.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot have more than 64 alleles&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">genotypes</span> <span class="o">==</span> <span class="n">MISSING_DATA</span><span class="p">)</span> <span class="ow">and</span> <span class="n">alleles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Don&#39;t modify the input parameter</span>
            <span class="n">alleles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">alleles</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">genotypes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">genotypes</span> <span class="o">!=</span> <span class="n">MISSING_DATA</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non-missing values for genotypes cannot be negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">genotypes</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Must have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="si">}</span><span class="s2"> (num_samples) genotypes.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">genotypes</span><span class="p">[</span><span class="n">non_missing</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">n_alleles</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non-missing values for genotypes must be &lt; num alleles&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ancestral_allele</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ancestral_allele</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ancestral_allele</span> <span class="o">&gt;=</span> <span class="n">n_alleles</span> <span class="ow">or</span> <span class="n">ancestral_allele</span> <span class="o">&lt;</span> <span class="n">MISSING_DATA</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;ancestral_allele needs to be an index into the alleles array &quot;</span>
                    <span class="s2">&quot;or tskit.MISSING_DATA&quot;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Site position must be &gt; 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">position</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Site position must be less than the sequence length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_position</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Site positions must be unique and added in increasing order&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">inference</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Inference sites no longer be stored in the sample data file. &quot;</span>
                <span class="s2">&quot;Please use the exclude_positions option to generate_ancestors.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">UNKNOWN_TIME</span>
        <span class="n">site_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sites_writer</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span>
            <span class="n">genotypes</span><span class="o">=</span><span class="n">genotypes</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">),</span>
            <span class="n">alleles</span><span class="o">=</span><span class="n">alleles</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">ancestral_allele</span><span class="o">=</span><span class="n">ancestral_allele</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_position</span> <span class="o">=</span> <span class="n">position</span>
        <span class="k">return</span> <span class="n">site_id</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">append_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">additional_samples</span><span class="p">):</span>
        <span class="c1"># Append sites from additional sample data objects to the current object. This</span>
        <span class="c1"># allows input files (e.g. vcf files) to be read in parallel into separate</span>
        <span class="c1"># sample data files and the combined together. The additional samples should have</span>
        <span class="c1"># exactly the same populations, individuals, and samples, but with additional</span>
        <span class="c1"># sites. The additional sample data objects must be provided in the correct order</span>
        <span class="c1"># such that site positions are monotonically ascending.</span>
        <span class="c1"># The method is deliberately undocumented, as a more capable way of representing</span>
        <span class="c1"># variant data is planned in the future, which should include this functionality.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_write_modes</span><span class="p">()</span>
        <span class="n">last_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">additional_samples</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">last_pos</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;sample data files must be in ascending order of genome position&quot;</span>
                <span class="p">)</span>
            <span class="n">last_pos</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sample data files must have the same sequence length&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">formats_equal</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sample data files must be of the same format&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_equal</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sample data files must have identical samples&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_equal</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sample data files must have identical individuals&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations_equal</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sample data files must have identical populations&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">additional_samples</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arrays</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;sites/&quot;</span><span class="p">):</span>
                    <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">finalise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">BUILD_MODE</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDING_POPULATIONS</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must add at least one sample individual&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDING_SAMPLES</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_writer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_samples_writer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADDING_SITES</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sites_writer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must add at least one site&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Need to be careful that sequence_length is JSON serialisable here.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;sequence_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_position</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">finalise</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__insert_individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">pop_id_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to insert all the individuals in this SampleData file</span>
<span class="sd">        into the other. If pop_id_map is specified, use it to map</span>
<span class="sd">        population IDs in this dataset to IDs in other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pop_id_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pop_id_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">j</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">num_populations</span><span class="p">)}</span>
            <span class="n">pop_id_map</span><span class="p">[</span><span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">]</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span>
        <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">individuals</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_individual</span><span class="p">(</span>
                <span class="n">location</span><span class="o">=</span><span class="n">individual</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">individual</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">individual</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">individual</span><span class="o">.</span><span class="n">flags</span><span class="p">,</span>
                <span class="c1"># We&#39;re assuming this is the same for all samples</span>
                <span class="n">population</span><span class="o">=</span><span class="n">pop_id_map</span><span class="p">[</span><span class="n">individual</span><span class="o">.</span><span class="n">population</span><span class="p">],</span>
                <span class="n">ploidy</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">samples</span><span class="p">),</span>
            <span class="p">)</span>

    <span class="c1">####################################</span>
    <span class="c1"># Read mode</span>
    <span class="c1">####################################</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this SampleData file merged with the specified</span>
<span class="sd">        other SampleData file. Subsequent keyword arguments are passed</span>
<span class="sd">        to the SampleData constructor for the returned merged dataset.</span>

<span class="sd">        The datasets are merged by following process:</span>

<span class="sd">        1. We add the populations from this dataset to the result, followed</span>
<span class="sd">           by the populations from other. Population references from the two</span>
<span class="sd">           datasets are updated accordingly.</span>
<span class="sd">        2. We add individual data from this dataset to the result, followed</span>
<span class="sd">           by the individuals from the other dataset.</span>
<span class="sd">        3. We merge the variant data from the two datasets by comparing sites</span>
<span class="sd">           by their position. If two sites in the datasets have the same</span>
<span class="sd">           position we combine the genotype data. The alleles from this dataset</span>
<span class="sd">           are updated to include any new alleles in other, and we then combine</span>
<span class="sd">           and update the genotypes accordingly. It is an error if sites with</span>
<span class="sd">           the same position have different ancestral state, time, or metadata</span>
<span class="sd">           values. For sites that exist in one dataset and not the other,</span>
<span class="sd">           we insert the site with ``tskit.MISSING_DATA`` present in the genotypes for</span>
<span class="sd">           the dataset that does not contain the site.</span>
<span class="sd">        4. We add the provenances for this dataset, followed by the provenances</span>
<span class="sd">           for the other dataset.</span>

<span class="sd">        :param SampleData other: The other `SampleData` instance to</span>
<span class="sd">            to merge.</span>
<span class="sd">        :return: A new SampleData instance which contains the merged data</span>
<span class="sd">            from the two datasets.</span>
<span class="sd">        :rtype: `SampleData`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
        <span class="n">other</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample data files must have the same sequence length&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">SampleData</span><span class="p">(</span><span class="n">sequence_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">as</span> <span class="n">result</span><span class="p">:</span>
            <span class="c1"># Keep the same population IDs from self.</span>
            <span class="k">for</span> <span class="n">population</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">():</span>
                <span class="n">result</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">population</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
            <span class="c1"># TODO we could avoid duplicate populations here by keying on the</span>
            <span class="c1"># metadata. It&#39;s slightly complicated by the case where the</span>
            <span class="c1"># metadata is all empty, but we could fall through to just</span>
            <span class="c1"># adding in all the populations as is, then.</span>
            <span class="n">other_pop_map</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">population</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">populations</span><span class="p">():</span>
                <span class="n">pid</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">add_population</span><span class="p">(</span><span class="n">population</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
                <span class="n">other_pop_map</span><span class="p">[</span><span class="n">population</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">pid</span>

            <span class="n">result</span><span class="o">.</span><span class="n">__insert_individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">__insert_individuals</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">other_pop_map</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">variant</span> <span class="ow">in</span> <span class="n">merge_variants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span>
                    <span class="n">position</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                    <span class="n">genotypes</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">genotypes</span><span class="p">,</span>
                    <span class="n">alleles</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">alleles</span><span class="p">,</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">variant</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">other</span><span class="o">.</span><span class="n">provenances</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">add_provenance</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">record_provenance</span><span class="p">(</span><span class="n">command</span><span class="o">=</span><span class="s2">&quot;merge&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the Site objects. A subset of the</span>
<span class="sd">        sites can be returned using the ``ids`` parameter. This must</span>
<span class="sd">        be a list of integer site IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">position_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:]</span>
        <span class="n">alleles_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_alleles</span><span class="p">[:]</span>
        <span class="n">metadata_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_metadata</span><span class="p">[:]</span>
        <span class="n">time_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_time</span><span class="p">[:]</span>
        <span class="n">ancestral_allele_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_ancestral_allele</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="n">ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
            <span class="n">anc_idx</span> <span class="o">=</span> <span class="n">ancestral_allele_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">Site</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
                <span class="n">position</span><span class="o">=</span><span class="n">position_array</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">ancestral_allele</span><span class="o">=</span><span class="n">anc_idx</span><span class="p">,</span>
                <span class="n">alleles</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">alleles_array</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata_array</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time_array</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">yield</span> <span class="n">site</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">num_alleles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a numpy array of the number of alleles at each site. Missing data is</span>
<span class="sd">        not counted as an allele.</span>

<span class="sd">        :param array sites: A numpy array of sites for which to return data. If None</span>
<span class="sd">            (default) return all sites.</span>

<span class="sd">        :return: A numpy array of the number of alleles at each site.</span>
<span class="sd">        :rtype: numpy.ndarray(dtype=uint32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sites</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>
        <span class="n">num_alleles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">alleles</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_alleles</span><span class="p">):</span>
            <span class="c1"># Filter out empty alleles (generated by, for example sgkit)</span>
            <span class="n">num_alleles</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                <span class="p">[</span><span class="n">allele</span> <span class="k">for</span> <span class="n">allele</span> <span class="ow">in</span> <span class="n">alleles</span> <span class="k">if</span> <span class="n">allele</span> <span class="o">!=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">allele</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">alleles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">num_alleles</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">num_alleles</span><span class="p">[</span><span class="n">sites</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">variants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the :class:`Variant` objects. This is equivalent to</span>
<span class="sd">        the :meth:`tskit.TreeSequence.variants` iterator. If recode_ancestral is</span>
<span class="sd">        ``True``, the ``.alleles`` attribute of each variant is guaranteed to return</span>
<span class="sd">        the alleles in an order such that the ancestral state is the first item</span>
<span class="sd">        in the list. In this case, ``variant.alleles`` may list the alleles in a</span>
<span class="sd">        different order from the input order as listed in ``variant.site.alleles``,</span>
<span class="sd">        and the values in genotypes array will be recoded so that the ancestral</span>
<span class="sd">        state will have a genotype of 0. If the ancestral state is unknown, the</span>
<span class="sd">        original input order is kept.</span>

<span class="sd">        If a variant contains missing data, it is guaranteed that the alleles</span>
<span class="sd">        attribute for that variant satisfies ``alleles[tskit.MISSING_DATA] == None``.</span>

<span class="sd">        :param array sites: A numpy array of ascending site ids for which to return</span>
<span class="sd">            data. If None (default) return all sites.</span>
<span class="sd">        :param bool recode_ancestral: If True, recode genotypes at sites where the</span>
<span class="sd">            ancestral state is known such that the ancestral state is coded as 0,</span>
<span class="sd">            as described above. Otherwise return genotypes in the input allele encoding.</span>
<span class="sd">            Default: ``None`` treated as ``False``.</span>
<span class="sd">        :return: An iterator over the variants in the sample data file.</span>
<span class="sd">        :rtype: iter(:class:`Variant`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">recode_ancestral</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">recode_ancestral</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">all_genotypes</span> <span class="o">=</span> <span class="n">chunk_iterator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_genotypes</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">sites</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">MISSING_DATA</span> <span class="o">&lt;</span> <span class="mi">0</span>  <span class="c1"># required for geno_map to remap MISSING_DATA</span>
        <span class="k">for</span> <span class="n">genos</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_genotypes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">(</span><span class="n">ids</span><span class="o">=</span><span class="n">sites</span><span class="p">)):</span>
            <span class="n">aa</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">ancestral_allele</span>
            <span class="n">alleles</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">alleles</span>
            <span class="k">if</span> <span class="n">aa</span> <span class="o">!=</span> <span class="n">MISSING_DATA</span> <span class="ow">and</span> <span class="n">aa</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">recode_ancestral</span><span class="p">:</span>
                <span class="c1"># Need to recode this site</span>
                <span class="n">alleles</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">reorder_alleles</span><span class="p">()</span>
                <span class="c1"># re-map the genotypes</span>
                <span class="n">geno_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">)</span> <span class="o">-</span> <span class="n">MISSING_DATA</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">genos</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">geno_map</span><span class="p">[</span><span class="n">MISSING_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">MISSING_DATA</span>
                <span class="n">geno_map</span><span class="p">[</span><span class="n">aa</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">geno_map</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">aa</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">genos</span> <span class="o">=</span> <span class="n">geno_map</span><span class="p">[</span><span class="n">genos</span><span class="p">]</span>
            <span class="k">yield</span> <span class="n">Variant</span><span class="p">(</span><span class="n">site</span><span class="o">=</span><span class="n">site</span><span class="p">,</span> <span class="n">alleles</span><span class="o">=</span><span class="n">alleles</span><span class="p">,</span> <span class="n">genotypes</span><span class="o">=</span><span class="n">genos</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_all_haplotypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># We iterate over chunks vertically here, and it&#39;s not worth complicating</span>
        <span class="c1"># the chunk iterator to handle this.</span>
        <span class="k">if</span> <span class="n">recode_ancestral</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">recode_ancestral</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">aa_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_ancestral_allele</span><span class="p">[:]</span>
        <span class="c1"># If ancestral allele is missing, keep the order unchanged (aa_index of zero)</span>
        <span class="n">aa_index</span><span class="p">[</span><span class="n">aa_index</span> <span class="o">==</span> <span class="n">MISSING_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_genotypes</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">%</span> <span class="n">chunk_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_genotypes</span><span class="p">[:,</span> <span class="n">j</span> <span class="p">:</span> <span class="n">j</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">[</span><span class="n">j</span> <span class="o">%</span> <span class="n">chunk_size</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">recode_ancestral</span><span class="p">:</span>
                <span class="c1"># Remap the genotypes at all sites, depending on the aa_index</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                    <span class="n">a</span> <span class="o">==</span> <span class="n">aa_index</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">MISSING_DATA</span><span class="p">,</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">aa_index</span><span class="p">),</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">yield</span> <span class="n">j</span><span class="p">,</span> <span class="n">a</span> <span class="k">if</span> <span class="n">sites</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">a</span><span class="p">[</span><span class="n">sites</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">haplotypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the (sample_id, haplotype) pairs. Each haplotype is</span>
<span class="sd">        an array of indexes, where the ``i`` th value is an index into the</span>
<span class="sd">        alleles list for the ``i`` th specified site (but see warning below).</span>

<span class="sd">        .. warning::</span>
<span class="sd">            If ``recode_ancestral=True``, the haplotype values may not correspond</span>
<span class="sd">            to indexes into the ``sites.alleles`` list. Instead, they will correspond to</span>
<span class="sd">            the ``variant.alleles`` list, returned when iterating over :meth:`variants`</span>
<span class="sd">            using ``variants(recode_ancestral=True)``.</span>

<span class="sd">        :param list samples: The sample IDs for which haplotypes are returned. If</span>
<span class="sd">            ``None``, return haplotypes for all sample nodes, otherwise this may be a</span>
<span class="sd">            numpy array (or array-like) object (converted to dtype=np.int32).</span>
<span class="sd">        :param array sites: A numpy array of sites to use, or ``None`` for all sites.</span>
<span class="sd">        :param bool recode_ancestral: If ``True``, recode genotypes so that the</span>
<span class="sd">            ancestral state is coded as 0 as described under :meth:`variants`. Otherwise</span>
<span class="sd">            return genotypes in the input allele encoding. Default: ``None``,</span>
<span class="sd">            treated as ``False``.</span>
<span class="sd">        :return: An iterator over (sample_id, haplotype) pairs.</span>
<span class="sd">        :rtype: iter(int, numpy.ndarray(dtype=int8))</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">samples</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sample indexes must be in increasing order.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">samples</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample index too large.&quot;</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_all_haplotypes</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">recode_ancestral</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">samples</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">yield</span> <span class="n">index</span><span class="p">,</span> <span class="n">a</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">individual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
        <span class="c1"># TODO document</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples_individual</span><span class="p">[:]</span> <span class="o">==</span> <span class="n">id_</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Make sure the numpy arrays are converted to lists so that</span>
        <span class="c1"># we can compare individuals using ==</span>
        <span class="k">return</span> <span class="n">Individual</span><span class="p">(</span>
            <span class="n">id_</span><span class="p">,</span>
            <span class="n">location</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_location</span><span class="p">[</span><span class="n">id_</span><span class="p">]),</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_metadata</span><span class="p">[</span><span class="n">id_</span><span class="p">],</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_time</span><span class="p">[</span><span class="n">id_</span><span class="p">],</span>
            <span class="n">population</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_population</span><span class="p">[</span><span class="n">id_</span><span class="p">],</span>
            <span class="n">samples</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span>
            <span class="n">flags</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_flags</span><span class="p">[</span><span class="n">id_</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">individual_samples</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">sample_id</span><span class="p">,</span> <span class="n">individual_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples_individual</span><span class="p">[:]):</span>
            <span class="n">individual_samples</span><span class="p">[</span><span class="n">individual_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample_id</span><span class="p">)</span>
        <span class="c1"># TODO document</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals_location</span><span class="p">[:],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals_metadata</span><span class="p">[:],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals_time</span><span class="p">[:],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals_population</span><span class="p">[:],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals_flags</span><span class="p">[:],</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">Individual</span><span class="p">(</span>
                <span class="n">j</span><span class="p">,</span>
                <span class="n">location</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">location</span><span class="p">),</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
                <span class="n">samples</span><span class="o">=</span><span class="n">individual_samples</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
        <span class="c1"># TODO document</span>
        <span class="k">return</span> <span class="n">Sample</span><span class="p">(</span>
            <span class="n">id_</span><span class="p">,</span>
            <span class="n">individual</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">samples_individual</span><span class="p">[</span><span class="n">id_</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO document</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples_individual</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">individual</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">Sample</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">individual</span><span class="o">=</span><span class="n">individual</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
        <span class="c1"># TODO document</span>
        <span class="k">return</span> <span class="n">Population</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">populations_metadata</span><span class="p">[</span><span class="n">id_</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">populations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO document</span>
        <span class="n">iterator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations_metadata</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">metadata</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">Population</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>


<div class="viewcode-block" id="VariantData">
<a class="viewcode-back" href="../../api.html#tsinfer.VariantData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">VariantData</span><span class="p">(</span><span class="n">SampleData</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class representing input variant data used for inference. This is</span>
<span class="sd">    mostly a thin wrapper for a Zarr dataset storing information in</span>
<span class="sd">    the VCF Zarr (.vcz) format, plus information specifing the ancestral allele</span>
<span class="sd">    and (optional) data masks. It then provides various derived properties and</span>
<span class="sd">    methods for accessing the data in a form suitable for inference.</span>

<span class="sd">    .. note::</span>
<span class="sd">        In the VariantData object, &quot;samples&quot; refer to the individuals in the dataset,</span>
<span class="sd">        each of which can be of arbitrary ploidy. This is in contrast to ``tskit``,</span>
<span class="sd">        in which each *haploid genome* is treated as a separate &quot;sample&quot;. For example</span>
<span class="sd">        in a diploid dataset, the inferred tree sequence returned at the end of</span>
<span class="sd">        the inference process will have ``inferred_ts.num_samples`` equal to double</span>
<span class="sd">        the number returned by ``VariantData.num_samples``.</span>

<span class="sd">    :param Union(str, zarr.Group) path_or_zarr: The input dataset in</span>
<span class="sd">        `VCF Zarr &lt;https://github.com/sgkit-dev/vcf-zarr-spec&gt;`_ format.</span>
<span class="sd">        This can either a path to the Zarr dataset saved on disk, or the</span>
<span class="sd">        Zarr object itself.</span>
<span class="sd">    :param Union(array, str) ancestral_state: A numpy array of strings specifying</span>
<span class="sd">        the ancestral states (alleles) used in inference. This must be the same length</span>
<span class="sd">        as the number of unmasked sites in the dataset. Alternatively, a single string</span>
<span class="sd">        can be provided, giving the name of an array in the input dataset which contains</span>
<span class="sd">        the ancestral states. Unknown ancestral states can be specified using &quot;N&quot;.</span>
<span class="sd">        Any ancestral states which do not match any of the known alleles at that site,</span>
<span class="sd">        will be tallied, and a warning issued summarizing the unknown ancestral states.</span>
<span class="sd">        Note that allelic states are case-sensitive in tsinfer.</span>
<span class="sd">    :param Union(array, str) sample_mask: A numpy array of booleans specifying which</span>
<span class="sd">        samples to mask out (exclude) from the dataset. Alternatively, a string</span>
<span class="sd">        can be provided, giving the name of an array in the input dataset which contains</span>
<span class="sd">        the sample mask. If ``None`` (default), all samples are included.</span>
<span class="sd">    :param Union(array, str) site_mask: A numpy array of booleans specifying which</span>
<span class="sd">        sites to mask out (exclude) from the dataset. Alternatively, a string</span>
<span class="sd">        can be provided, giving the name of an array in the input dataset which contains</span>
<span class="sd">        the site mask. If ``None`` (default), all sites are included.</span>
<span class="sd">    :param Union(array, str) sites_time: A numpy array of floats specifying the relative</span>
<span class="sd">        time of occurrence of the mutation to the derived state at each site. This must</span>
<span class="sd">        be of the same length as the number of unmasked sites. Alternatively, a</span>
<span class="sd">        string can be provided, giving the name of an array in the input dataset</span>
<span class="sd">        which contains the site times. If ``None`` (default), the frequency of the</span>
<span class="sd">        derived allele is used as a proxy for the time of occurrence: this is usually a</span>
<span class="sd">        reasonable approximation to the relative order of ancestors used for inference.</span>
<span class="sd">        Time values are ignored for sites not used in inference, such as singletons,</span>
<span class="sd">        sites with more than two alleles, or sites with an unknown ancestral state.</span>
<span class="sd">    :param Union(array, str) individuals_time: A numpy array of floats specifying</span>
<span class="sd">        the time of each individual in the dataset. This must be the same length</span>
<span class="sd">        as the number of unmasked individuals. Alternatively, a string can be provided,</span>
<span class="sd">        giving the name of an array in the input dataset which contains the individual</span>
<span class="sd">        times. If ``None`` (default), individuals are assumed to have</span>
<span class="sd">        ``tskit.UNKNOWN_TIME``.</span>
<span class="sd">    :param Union(array, str) individuals_location: A numpy array specifying</span>
<span class="sd">        the location of each individual in the dataset. This must be the same length</span>
<span class="sd">        as the number of unmasked individuals. Alternatively, a string can be provided,</span>
<span class="sd">        giving the name of an array in the input dataset which contains the individual</span>
<span class="sd">        locations. If ``None`` (default), individuals are assumed to have empty</span>
<span class="sd">        location arrays.</span>
<span class="sd">    :param Union(array, str) individuals_population: A numpy array of integers specifying</span>
<span class="sd">        the population of each individual in the dataset. This must be the same length</span>
<span class="sd">        as the number of unmasked individuals. Alternatively, a string can be provided,</span>
<span class="sd">        giving the name of an array in the input dataset which contains the individual</span>
<span class="sd">        populations. If ``None`` (default), individuals are assumed to have</span>
<span class="sd">        ``tskit.NULL`` as their population.</span>
<span class="sd">    :param Union(array, str) individuals_flags: A numpy array of integers specifying</span>
<span class="sd">        the flags of each individual in the dataset. This must be the same length</span>
<span class="sd">        as the number of unmasked individuals. Alternatively, a string can be provided,</span>
<span class="sd">        giving the name of an array in the input dataset which contains the individual</span>
<span class="sd">        flags. If ``None`` (default), individuals are assumed to have flags set to 0.</span>
<span class="sd">    :param int sequence_length: An integer specifying the resulting `sequence_length`</span>
<span class="sd">        attribute of the output tree sequence. If not specified the `contig_length`</span>
<span class="sd">        attribute from the undelying zarr store for the contig of the selected variants.</span>
<span class="sd">        is used. If that is not present then the maximum position plus one of the used</span>
<span class="sd">        variants is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">FORMAT_NAME</span> <span class="o">=</span> <span class="s2">&quot;tsinfer-variant-data&quot;</span>
    <span class="n">FORMAT_VERSION</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path_or_zarr</span><span class="p">,</span>
        <span class="n">ancestral_state</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sample_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">site_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sites_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">individuals_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">individuals_location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">individuals_population</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">individuals_flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sequence_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sequence_length</span> <span class="o">=</span> <span class="n">sequence_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_contig_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_contig_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_or_zarr</span><span class="o">.</span><span class="n">call_genotype</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># Assumed to be a VCF Zarr hierarchy</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">path_or_zarr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Expecting a VCF Zarr object with 3D call_genotype array: &quot;</span>
                    <span class="s2">&quot;see https://github.com/sgkit-dev/vcf-zarr-spec/&quot;</span>
                <span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path_or_zarr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path_or_zarr</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

        <span class="n">genotypes_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;call_genotype&quot;</span><span class="p">]</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_individuals_before_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">=</span> <span class="n">genotypes_arr</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">process_mask</span><span class="p">(</span><span class="n">mask_param</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">param_name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mask_param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask_param</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mask_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mask_param</span><span class="p">][:]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">mask_param</span><span class="si">}</span><span class="s2"> was not found in the dataset.&quot;</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">mask_param</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">length</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2"> must be the same length as the number of &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;unmasked sites&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="s1">&#39;site&#39;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">param_name</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;individuals&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">mask_param</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">process_array</span><span class="p">(</span>
            <span class="n">array_param</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">default_value</span><span class="p">,</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">expected_size</span><span class="p">,</span> <span class="n">dtype</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">array_param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">default_value</span> <span class="o">==</span> <span class="p">[]:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">expected_size</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">expected_size</span><span class="p">,</span> <span class="n">default_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array_param</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">array_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">array_param</span><span class="p">][:][</span><span class="n">mask</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">array_param</span><span class="si">}</span><span class="s2"> was not found in the dataset&quot;</span>
                    <span class="p">)</span>
            <span class="k">if</span> <span class="n">array_param</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">expected_size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">param_name</span><span class="si">}</span><span class="s2"> must be the same length as the number of &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;selected </span><span class="si">{</span><span class="s1">&#39;sites&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="s1">&#39;sites&#39;</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">param_name</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;individuals&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">array_param</span>

        <span class="n">site_mask</span> <span class="o">=</span> <span class="n">process_mask</span><span class="p">(</span>
            <span class="n">site_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;variant_position&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;site mask array&quot;</span>
        <span class="p">)</span>

        <span class="n">sample_mask</span> <span class="o">=</span> <span class="n">process_mask</span><span class="p">(</span>
            <span class="n">sample_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_individuals_before_mask</span><span class="p">,</span> <span class="s2">&quot;samples mask array&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sites_select</span> <span class="o">=</span> <span class="o">~</span><span class="n">site_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span> <span class="o">=</span> <span class="o">~</span><span class="n">sample_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_select</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_select</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;All sites have been masked out, at least one value &quot;</span>
                <span class="s2">&quot;must be &#39;False&#39; in the site mask&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_time</span> <span class="o">=</span> <span class="n">process_array</span><span class="p">(</span>
            <span class="n">individuals_time</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span><span class="p">,</span>
            <span class="n">tskit</span><span class="o">.</span><span class="n">UNKNOWN_TIME</span><span class="p">,</span>
            <span class="s2">&quot;individuals time array&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_location</span> <span class="o">=</span> <span class="n">process_array</span><span class="p">(</span>
            <span class="n">individuals_location</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span><span class="p">,</span>
            <span class="p">[],</span>
            <span class="s2">&quot;individuals location array&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">,</span>
            <span class="nb">float</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_population</span> <span class="o">=</span> <span class="n">process_array</span><span class="p">(</span>
            <span class="n">individuals_population</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span><span class="p">,</span>
            <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">,</span>
            <span class="s2">&quot;individuals population array&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_flags</span> <span class="o">=</span> <span class="n">process_array</span><span class="p">(</span>
            <span class="n">individuals_flags</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;individuals flags array&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sites_time</span> <span class="o">=</span> <span class="n">process_array</span><span class="p">(</span>
            <span class="n">sites_time</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sites_select</span><span class="p">,</span>
            <span class="n">tskit</span><span class="o">.</span><span class="n">UNKNOWN_TIME</span><span class="p">,</span>
            <span class="s2">&quot;sites time array&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;call_genotype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;call_genotype_phased&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The call_genotype_phased array is missing from the&quot;</span>
                    <span class="s2">&quot; zarr dataset, indicating that all the genotypes are&quot;</span>
                    <span class="s2">&quot; unphased&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;variant_contig&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">used_contigs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">variant_contig</span><span class="p">[:][</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_select</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_contig_index</span> <span class="o">=</span> <span class="n">used_contigs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_contig_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">contig_id</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_contig_index</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">used_contigs</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contig_index</span><span class="p">):</span>
                <span class="n">contig_names</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">contig_id</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="si">}</span><span class="s1">&quot;&#39;</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">used_contigs</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Sites belong to multiple contigs (</span><span class="si">{</span><span class="n">contig_names</span><span class="si">}</span><span class="s2">). &quot;</span>
                    <span class="s2">&quot;Please restrict sites to one contig using the sites_mask argument.&quot;</span>
                    <span class="s2">&quot;e.g. `mask=zarr_group[&#39;variant_contig&#39;] != wanted_index`&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Values taken from the variant_position array are not strictly &quot;</span>
                <span class="s2">&quot;increasing (i.e. have duplicate or out-of-order values). &quot;</span>
                <span class="s2">&quot;These must be masked out to run tsinfer.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ancestral_state</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ancestral_state</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Ancestral state array must be the same length as the number of&quot;</span>
                    <span class="s2">&quot; selected sites&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ancestral_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ancestral_state</span><span class="p">][:][</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_select</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The ancestral state array </span><span class="si">{</span><span class="n">ancestral_state</span><span class="si">}</span><span class="s2"> was not&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; found in the dataset.&quot;</span>
                <span class="p">)</span>
        <span class="n">ancestral_state</span> <span class="o">=</span> <span class="n">ancestral_state</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ancestral_state</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ancestral state array cannot contain empty strings&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sites_ancestral_allele</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">unknown_alleles</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">anc_state</span><span class="p">,</span> <span class="n">site</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ancestral_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">())):</span>
            <span class="k">if</span> <span class="n">anc_state</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">}</span> <span class="ow">or</span> <span class="n">anc_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">site</span><span class="o">.</span><span class="n">alleles</span><span class="p">:</span>
                <span class="n">unknown_alleles</span><span class="p">[</span><span class="n">anc_state</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sites_ancestral_allele</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">alleles</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">anc_state</span><span class="p">)</span>
        <span class="n">deliberately_unknown</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">unknown_alleles</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;N&quot;</span><span class="p">,</span> <span class="s2">&quot;n&quot;</span><span class="p">)])</span>
        <span class="n">tot</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">unknown_alleles</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">tot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">frac_bad</span> <span class="o">=</span> <span class="n">tot</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span>
            <span class="n">frac_bad_per_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">unknown_alleles</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
            <span class="n">summarise_unknown</span> <span class="o">=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">frac</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">% of sites)&quot;</span>  <span class="c1"># Summarise per allele type</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">frac</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">unknown_alleles</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">frac_bad_per_type</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">tot</span> <span class="o">==</span> <span class="n">deliberately_unknown</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tot</span><span class="si">}</span><span class="s2"> sites (</span><span class="si">{</span><span class="n">frac_bad</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%) were deliberately marked as &quot;</span>
                    <span class="s2">&quot;of unknown ancestral state. They will not be used for inference&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;An ancestral allele was not found in the variant_allele array for &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;the </span><span class="si">{</span><span class="n">tot</span><span class="si">}</span><span class="s2"> sites (</span><span class="si">{</span><span class="n">frac_bad</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%) listed below. &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;They will be treated as of unknown ancestral state:</span><span class="se">\n</span><span class="s2"> &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">summarise_unknown</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">frac_bad</span> <span class="o">&gt;</span> <span class="mf">0.2</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;More than 20</span><span class="si">% o</span><span class="s2">f sites have unknown ancestral states. &quot;</span>
                        <span class="s2">&quot;This might indicate that the ancestral sequence was misaligned &quot;</span>
                        <span class="s2">&quot;or not from the correct reference genome.&quot;</span>
                    <span class="p">)</span>

        <span class="c1"># Create zarr arrays for convenience when iterating over chunks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_sites_select</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sites_select</span><span class="p">,</span> <span class="n">chunks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;call_genotype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
        <span class="p">)</span>
        <span class="c1"># Find the first chunk from the left and right that contains an unmasked site</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites_used_chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sites_chunk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_sites_select</span><span class="o">.</span><span class="n">cdata_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_sites_select</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">sites_chunk</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sites_used_chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sites_chunk</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of sites after applying mask: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Sites chunks used: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_used_chunks</span><span class="p">)</span><span class="si">}</span><span class="s2"> - &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">z_sites_select</span><span class="o">.</span><span class="n">cdata_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Number of individuals after applying mask: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">format_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">FORMAT_NAME</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">format_version</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">FORMAT_VERSION</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">finalised</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sequence_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The sequence length of the contig associated with sites used in the dataset.</span>
<span class="sd">        If set manually then that value is used else if the dataset has recorded</span>
<span class="sd">        contig lengths use that else the length is calculated from the maximum</span>
<span class="sd">        variant position plus one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sequence_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sequence_length</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contig_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;contig_length&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">contig_length</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_contig_index</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">contig_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The contig ID (name) for all used sites, or None if no</span>
<span class="sd">        contig IDs were present in the zarr dataset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contig_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_sites</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">samples_select</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Samples in sgkit are individuals in tskit, so we need to expand</span>
        <span class="c1"># the mask to cover all the samples for each individual.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span><span class="p">)</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">parse_metadata_schema</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;sites_metadata_schema&quot;</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">schema</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="o">.</span><span class="n">permissive_json</span><span class="p">()</span><span class="o">.</span><span class="n">schema</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_metadata_schema</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">schema</span><span class="o">.</span><span class="n">decode_row</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sites_metadata&quot;</span><span class="p">][:][</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_select</span><span class="p">]</span>
            <span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sites_time</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;variant_position&quot;</span><span class="p">][:][</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_select</span><span class="p">]</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_alleles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;variant_allele&quot;</span><span class="p">][:][</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_select</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_ancestral_allele</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sites_ancestral_allele</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_genotypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">gt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;call_genotype&quot;</span><span class="p">]</span>
        <span class="c1"># This method is only used for test/debug so we retrieve and</span>
        <span class="c1"># reshape the entire array.</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">gt</span><span class="p">[</span><span class="o">...</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_select</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">provenances_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;provenances_timestamp&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">provenances_record</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;provenances_record&quot;</span><span class="p">]]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples_select</span><span class="p">)</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">samples_individual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span><span class="p">):</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">p</span> <span class="p">::</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">parse_metadata_schema</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;metadata_schema&quot;</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">schema</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="o">.</span><span class="n">permissive_json</span><span class="p">()</span><span class="o">.</span><span class="n">schema</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="p">)</span><span class="o">.</span><span class="n">decode_row</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_populations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;populations_metadata&quot;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">populations_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">populations_metadata_schema</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">schema</span><span class="o">.</span><span class="n">decode_row</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;populations_metadata&quot;</span><span class="p">][:]]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span><span class="p">)]</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">populations_metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">parse_metadata_schema</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;populations_metadata_schema&quot;</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">schema</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="o">.</span><span class="n">permissive_json</span><span class="p">()</span><span class="o">.</span><span class="n">schema</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span><span class="p">)</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">parse_metadata_schema</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;individuals_metadata_schema&quot;</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">schema</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="o">.</span><span class="n">permissive_json</span><span class="p">()</span><span class="o">.</span><span class="n">schema</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_metadata_schema</span><span class="p">)</span>
        <span class="c1"># We set the sample_id in the individual metadata as this is often useful,</span>
        <span class="c1"># however we silently don&#39;t overwrite if the key exists</span>
        <span class="k">if</span> <span class="s2">&quot;individuals_metadata&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;individuals_metadata&quot;</span><span class="p">])</span>
                <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_individuals_before_mask</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_individuals_before_mask</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sample_id&quot;</span><span class="p">])</span>
            <span class="n">md_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sample_id</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sample_id&quot;</span><span class="p">][:][</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;individuals_metadata&quot;</span><span class="p">][:][</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span><span class="p">],</span>
            <span class="p">):</span>
                <span class="n">md</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">decode_row</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;variant_data_sample_id&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">md</span><span class="p">:</span>
                    <span class="n">md</span><span class="p">[</span><span class="s2">&quot;variant_data_sample_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample_id</span>
                <span class="n">md_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">md</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">md_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="p">{</span><span class="s2">&quot;variant_data_sample_id&quot;</span><span class="p">:</span> <span class="n">sample_id</span><span class="p">}</span>
                <span class="k">for</span> <span class="n">sample_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sample_id&quot;</span><span class="p">][:][</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span><span class="p">]</span>
            <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_location</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_location</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_population</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_population</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_flags</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_trim_allele_array</span><span class="p">(</span><span class="n">allele_array</span><span class="p">,</span> <span class="n">site_id</span><span class="p">):</span>
        <span class="c1"># Trim a list of allelic states to remove any trailing &quot;&quot; entries.</span>
        <span class="k">assert</span> <span class="n">allele_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">allele_array</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">allele_array</span> <span class="o">=</span> <span class="n">allele_array</span><span class="p">[:</span> <span class="p">(</span><span class="n">used</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">allele_array</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Bad alleles: fill value &quot;&quot; in middle of list: </span><span class="si">{</span><span class="n">allele_array</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">allele_array</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">allele_array</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Duplicate allele values provided at site </span><span class="si">{</span><span class="n">site_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">allele_array</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the Site objects. A subset of the</span>
<span class="sd">        sites can be returned using the ``ids`` parameter. This must</span>
<span class="sd">        be a list of integer site IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">position_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:]</span>
        <span class="n">alleles_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_alleles</span><span class="p">[:]</span>
        <span class="n">metadata_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_metadata</span><span class="p">[:]</span>
        <span class="n">time_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_time</span><span class="p">[:]</span>
        <span class="n">ancestral_allele_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_ancestral_allele</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="n">ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
            <span class="n">anc_idx</span> <span class="o">=</span> <span class="n">ancestral_allele_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">Site</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
                <span class="n">position</span><span class="o">=</span><span class="n">position_array</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">ancestral_allele</span><span class="o">=</span><span class="n">anc_idx</span><span class="p">,</span>
                <span class="n">alleles</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trim_allele_array</span><span class="p">(</span><span class="n">alleles_array</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">j</span><span class="p">)),</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata_array</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time_array</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">yield</span> <span class="n">site</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">variants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the :class:`Variant` objects. This is equivalent to</span>
<span class="sd">        the :meth:`tskit.TreeSequence.variants` iterator. If recode_ancestral is</span>
<span class="sd">        ``True``, the ``.alleles`` attribute of each variant is guaranteed to return</span>
<span class="sd">        the alleles in an order such that the ancestral state is the first item</span>
<span class="sd">        in the list. In this case, ``variant.alleles`` may list the alleles in a</span>
<span class="sd">        different order from the input order as listed in ``variant.site.alleles``,</span>
<span class="sd">        and the values in genotypes array will be recoded so that the ancestral</span>
<span class="sd">        state will have a genotype of 0. If the ancestral state is unknown, the</span>
<span class="sd">        original input order is kept.</span>

<span class="sd">        :param array sites: A numpy array of ascending site ids for which to return</span>
<span class="sd">            data. If None (default) return all sites.</span>
<span class="sd">        :param bool recode_ancestral: If True, recode genotypes at sites where the</span>
<span class="sd">            ancestral state is known such that the ancestral state is coded as 0,</span>
<span class="sd">            as described above. Otherwise return genotypes in the input allele encoding.</span>
<span class="sd">            Default: ``None`` treated as ``False``.</span>
<span class="sd">        :return: An iterator over the variants in the sample data file.</span>
<span class="sd">        :rtype: iter(:class:`Variant`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">recode_ancestral</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">recode_ancestral</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">all_genotypes</span> <span class="o">=</span> <span class="n">chunk_iterator</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;call_genotype&quot;</span><span class="p">],</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">sites</span><span class="p">,</span>
            <span class="n">select</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_select</span><span class="p">,</span>
            <span class="n">orthogonal_select</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="n">MISSING_DATA</span> <span class="o">&lt;</span> <span class="mi">0</span>  <span class="c1"># required for geno_map to remap MISSING_DATA</span>
        <span class="k">for</span> <span class="n">genos</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_genotypes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">(</span><span class="n">ids</span><span class="o">=</span><span class="n">sites</span><span class="p">)):</span>
            <span class="c1"># We have an extra ploidy dimension when coming from sgkit</span>
            <span class="n">genos</span> <span class="o">=</span> <span class="n">genos</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)</span>
            <span class="n">aa</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">ancestral_allele</span>
            <span class="n">alleles</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">alleles</span>
            <span class="k">if</span> <span class="n">aa</span> <span class="o">!=</span> <span class="n">MISSING_DATA</span> <span class="ow">and</span> <span class="n">aa</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">recode_ancestral</span><span class="p">:</span>
                <span class="c1"># Need to recode this site</span>
                <span class="n">alleles</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">reorder_alleles</span><span class="p">()</span>
                <span class="c1"># re-map the genotypes</span>
                <span class="n">geno_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">)</span> <span class="o">-</span> <span class="n">MISSING_DATA</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">genos</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">geno_map</span><span class="p">[</span><span class="n">MISSING_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">MISSING_DATA</span>
                <span class="n">geno_map</span><span class="p">[</span><span class="n">aa</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">geno_map</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">aa</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">genos</span> <span class="o">=</span> <span class="n">geno_map</span><span class="p">[</span><span class="n">genos</span><span class="p">]</span>
            <span class="c1"># Empty alleles (padded by sgkit) should never be seen</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alleles</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">Variant</span><span class="p">(</span><span class="n">site</span><span class="o">=</span><span class="n">site</span><span class="p">,</span> <span class="n">alleles</span><span class="o">=</span><span class="n">alleles</span><span class="p">,</span> <span class="n">genotypes</span><span class="o">=</span><span class="n">genos</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_all_haplotypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">samples_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># We iterate over chunks vertically here, and it&#39;s not worth complicating</span>
        <span class="c1"># the chunk iterator to handle this.</span>
        <span class="k">if</span> <span class="n">samples_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples_slice</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">samples_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">samples_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Samples slice must be a multiple of ploidy&quot;</span><span class="p">)</span>
        <span class="c1"># Make an individuals mask that respects the samples slice</span>
        <span class="n">ind_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ind_select</span> <span class="o">=</span> <span class="n">zarr</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals_select</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">chunks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;call_genotype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ind_select</span><span class="p">[</span>
            <span class="n">ind_indexes</span><span class="p">[</span>
                <span class="n">samples_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span> <span class="p">:</span> <span class="n">samples_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span>
            <span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">sample_index</span> <span class="o">=</span> <span class="n">samples_slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ind_chunk_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ind_select</span><span class="o">.</span><span class="n">cdata_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ind_select_chunk</span> <span class="o">=</span> <span class="n">ind_select</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">ind_chunk_i</span><span class="p">]</span>
            <span class="n">num_samples_in_chunk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ind_select_chunk</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ploidy</span>
            <span class="k">if</span> <span class="n">num_samples_in_chunk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">final_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">num_samples_in_chunk</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
            <span class="n">site_insertion_position</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">sites_chunk_i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_used_chunks</span><span class="p">:</span>
                <span class="n">site_select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_sites_select</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">sites_chunk_i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">site_select</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">gt_chunk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;call_genotype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span>
                    <span class="n">sites_chunk_i</span><span class="p">,</span> <span class="n">ind_chunk_i</span><span class="p">,</span> <span class="p">:</span>
                <span class="p">]</span>
                <span class="n">gt_chunk</span> <span class="o">=</span> <span class="n">gt_chunk</span><span class="p">[</span><span class="n">site_select</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="n">gt_chunk</span> <span class="o">=</span> <span class="n">gt_chunk</span><span class="p">[:,</span> <span class="n">ind_select_chunk</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">gt_chunk</span> <span class="o">=</span> <span class="n">gt_chunk</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gt_chunk</span><span class="p">),</span> <span class="n">num_samples_in_chunk</span><span class="p">)</span>
                <span class="n">final_data</span><span class="p">[</span>
                    <span class="n">site_insertion_position</span> <span class="p">:</span> <span class="n">site_insertion_position</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">gt_chunk</span><span class="p">),</span> <span class="p">:</span>
                <span class="p">]</span> <span class="o">=</span> <span class="n">gt_chunk</span>
                <span class="n">site_insertion_position</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gt_chunk</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">site_insertion_position</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples_in_chunk</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">final_data</span><span class="p">[:,</span> <span class="n">s</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">recode_ancestral</span><span class="p">:</span>
                    <span class="c1"># Remap the genotypes at all sites, depending on the aa_index</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">a</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_ancestral_allele</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                                <span class="n">a</span> <span class="o">!=</span> <span class="n">MISSING_DATA</span><span class="p">,</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_ancestral_allele</span>
                            <span class="p">),</span>
                            <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">a</span><span class="p">,</span>
                        <span class="p">),</span>
                    <span class="p">)</span>
                <span class="k">yield</span> <span class="n">sample_index</span><span class="p">,</span> <span class="n">a</span> <span class="k">if</span> <span class="n">sites</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">a</span><span class="p">[</span><span class="n">sites</span><span class="p">]</span>
                <span class="n">sample_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">sample_index</span> <span class="o">==</span> <span class="n">samples_slice</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_tree_sequence</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;This method is not implemented for VariantData&quot;</span><span class="p">)</span></div>



<span class="nd">@attr</span><span class="o">.</span><span class="n">s</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eq</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Ancestor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An ancestor object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO document properly.</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">focal_sites</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>
    <span class="n">full_haplotype</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">ib</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">haplotype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_haplotype</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">start</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">end</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">focal_sites</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">focal_sites</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_haplotype</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">full_haplotype</span><span class="p">)</span>
        <span class="p">)</span>


<div class="viewcode-block" id="AncestorData">
<a class="viewcode-back" href="../../api.html#tsinfer.AncestorData">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">AncestorData</span><span class="p">(</span><span class="n">DataContainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    AncestorData(position, sequence_length, *, path=None, num_flush_threads=0, \</span>
<span class="sd">    compressor=None, chunk_size=1024, max_file_size=None)</span>

<span class="sd">    Class representing the stored ancestor data produced by</span>
<span class="sd">    :func:`generate_ancestors`. See the ancestor data file format</span>
<span class="sd">    :ref:`specifications &lt;sec_file_formats_ancestors&gt;` for details on the structure</span>
<span class="sd">    of this file.</span>

<span class="sd">    .. note:: If a ``path`` is specified, the ``max_file_size`` option puts an</span>
<span class="sd">        upper limit on the possible size of the created file. On non-Windows</span>
<span class="sd">        systems, space for this file is not immediately allocated but just</span>
<span class="sd">        &quot;reserved&quot; using sparse file systems. However, on Windows systems</span>
<span class="sd">        the file is allocated immediately, so ``max_file_size`` takes a smaller</span>
<span class="sd">        default value, to avoid allocating very large files for no reason.</span>
<span class="sd">        Users who wish to run large inferences on Windows may therefore need to</span>
<span class="sd">        explictly set an appropriate ``max_file_size``. Note that the</span>
<span class="sd">        ``max_file_size`` is only used while the file is being built: one the</span>
<span class="sd">        file has been finalised, it is shrunk to its minimum size.</span>

<span class="sd">    :param arraylike position: Integer array of the site positions of the ancestors.</span>
<span class="sd">        All values should be &gt;0 and the array should be monotonically increasing.</span>
<span class="sd">    :param float sequence_length: Total length of the sequence, site positions must</span>
<span class="sd">        be less than this value.</span>
<span class="sd">    :param str path: The path of the file to store the ancestor data. If None,</span>
<span class="sd">        the information is stored in memory and not persistent.</span>
<span class="sd">    :param int num_flush_threads: The number of background threads to use</span>
<span class="sd">        for compressing data and flushing to disc. If &lt;= 0, do not spawn</span>
<span class="sd">        any threads but use a synchronous algorithm instead. Default=0.</span>
<span class="sd">    :param numcodecs.abc.Codec compressor: A :class:`numcodecs.abc.Codec`</span>
<span class="sd">        instance to use for compressing data. Any codec may be used, but</span>
<span class="sd">        problems may occur with very large datasets on certain codecs as</span>
<span class="sd">        they cannot compress buffers &gt;2GB. If None, do not use any compression.</span>
<span class="sd">        Default=:class:`numcodecs.zstd.Zstd`.</span>
<span class="sd">    :param int chunk_size: The chunk size used for</span>
<span class="sd">         `zarr arrays &lt;http://zarr.readthedocs.io/&gt;`_ in the sample dimension. This</span>
<span class="sd">         affects compression level and algorithm performance. Default=1024.</span>
<span class="sd">    :param int chunk_size_sites: The chunk size used for the genotype</span>
<span class="sd">        `zarr arrays &lt;http://zarr.readthedocs.io/&gt;`_ in the sites dimension. This affects</span>
<span class="sd">        compression level and algorithm performance. Default=16384.</span>
<span class="sd">    :param int max_file_size: If a file is being used to store this data, set</span>
<span class="sd">        a maximum size in bytes for the stored file. If None, the default</span>
<span class="sd">        value of 1GiB is used on Windows and 1TiB on other</span>
<span class="sd">        platforms (see above for details).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">FORMAT_NAME</span> <span class="o">=</span> <span class="s2">&quot;tsinfer-ancestor-data&quot;</span>
    <span class="n">FORMAT_VERSION</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">,</span> <span class="n">chunk_size_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inference_sites_set</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">chunk_size_sites</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size_sites</span> <span class="o">=</span> <span class="mi">16384</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size_sites</span> <span class="o">=</span> <span class="n">chunk_size_sites</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;sequence_length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sequence_length</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad samples file: sequence_length cannot be zero or less&quot;</span><span class="p">)</span>

        <span class="c1"># We specify fill_value here due to https://github.com/pydata/xarray/issues/7292</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;sample_start&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;sample_end&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;sample_time&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s2">&quot;sample_focal_sites&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;array:i4&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;variant_position&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">position</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">position</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">chunks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size_sites</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;variants&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># We have to include a ploidy dimension sgkit compatibility</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;call_genotype&quot;</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;i1&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size_sites</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;variants&quot;</span><span class="p">,</span> <span class="s2">&quot;samples&quot;</span><span class="p">,</span> <span class="s2">&quot;ploidy&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;mixed_ploidy&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;call_genotype_mask&quot;</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;i1&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size_sites</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;variants&quot;</span><span class="p">,</span> <span class="s2">&quot;samples&quot;</span><span class="p">,</span> <span class="s2">&quot;ploidy&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># We add this to be identical to sgkit generated arrays</span>
        <span class="n">a</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;bool&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_alloc_ancestor_writer</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">create_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">chunks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">compressor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dimensions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">chunks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size</span>
        <span class="k">if</span> <span class="n">compressor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">compressor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compressor</span>
        <span class="k">if</span> <span class="n">dimensions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;samples&quot;</span><span class="p">]</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="n">compressor</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;_ARRAY_DIMENSIONS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dimensions</span>
        <span class="k">return</span> <span class="n">ds</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_alloc_ancestor_writer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_writer</span> <span class="o">=</span> <span class="n">BufferedItemWriter</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_start</span><span class="p">,</span>
                <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_end</span><span class="p">,</span>
                <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_time</span><span class="p">,</span>
                <span class="s2">&quot;focal_sites&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_focal_sites</span><span class="p">,</span>
                <span class="s2">&quot;full_haplotype&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_full_haplotype</span><span class="p">,</span>
                <span class="s2">&quot;full_haplotype_mask&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_full_haplotype_mask</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">num_threads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_flush_threads</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;AncestorData(num_ancestors=</span><span class="si">{}</span><span class="s2">, num_sites=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;sequence_length&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;num_ancestors&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;num_sites&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;variant_position&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;sample_start&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_start</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;sample_end&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_end</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;sample_time&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_time</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;sample_focal_sites&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_focal_sites</span><span class="p">)),</span>
            <span class="p">(</span><span class="s2">&quot;call_genotype&quot;</span><span class="p">,</span> <span class="n">zarr_summary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_full_haplotype</span><span class="p">)),</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_str</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

<div class="viewcode-block" id="AncestorData.data_equal">
<a class="viewcode-back" href="../../api.html#tsinfer.AncestorData.data_equal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">data_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if all the data attributes of this input file and the</span>
<span class="sd">        specified input file are equal. This compares every attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sequence_length</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">format_name</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_version</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">format_version</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">num_ancestors</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">num_sites</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:])</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_start</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">ancestors_start</span><span class="p">[:])</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_end</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">ancestors_end</span><span class="p">[:])</span>
            <span class="c1"># Need to take a different approach with np object arrays.</span>
            <span class="ow">and</span> <span class="n">np_obj_equal</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_focal_sites</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">ancestors_focal_sites</span><span class="p">[:]</span>
            <span class="p">)</span>
            <span class="c1"># TODO For large sets of ancestors, this needs to be done chunk-wise</span>
            <span class="ow">and</span> <span class="n">np_obj_equal</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_full_haplotype</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">ancestors_full_haplotype</span><span class="p">[:]</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">assert_data_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_equal</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">format_name</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">format_version</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">format_version</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">num_ancestors</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">num_sites</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:])</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_start</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">ancestors_start</span><span class="p">[:])</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_end</span><span class="p">[:],</span> <span class="n">other</span><span class="o">.</span><span class="n">ancestors_end</span><span class="p">[:])</span>
        <span class="n">fc_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_focal_sites</span><span class="p">[:]</span>
        <span class="n">fc_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ancestors_focal_sites</span><span class="p">[:]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fc_self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fc_other</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sites_self</span><span class="p">,</span> <span class="n">sites_other</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fc_self</span><span class="p">,</span> <span class="n">fc_other</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">sites_self</span><span class="p">,</span> <span class="n">sites_other</span><span class="p">)</span>
        <span class="n">haps_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_full_haplotype</span><span class="p">[:]</span>
        <span class="n">haps_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">ancestors_full_haplotype</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">hap_self</span><span class="p">,</span> <span class="n">hap_other</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">haps_self</span><span class="p">,</span> <span class="n">haps_other</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">hap_self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">hap_other</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># Put this assert last to have an easy to change attribute so we can</span>
        <span class="c1"># test this function.</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Bug in this function&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sequence_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sequence length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;sequence_length&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_start</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">cached_property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of inference sites used to generate the ancestors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The positions of the inference sites used to generate the ancestors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;variant_position&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ancestors_start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sample_start&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ancestors_end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sample_end&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ancestors_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sample_time&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ancestors_focal_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sample_focal_sites&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ancestors_full_haplotype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Named and shaped to be compatible with sgkit</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;call_genotype&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ancestors_full_haplotype_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Only required for sgkit compatibility</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;call_genotype_mask&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ancestors_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the length of ancestors in physical coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ancestor start and end are half-closed. The last site is assumed</span>
        <span class="c1"># to cover the region up to sequence length.</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:],</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">]])</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_start</span><span class="p">[:]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_end</span><span class="p">[:]</span>
        <span class="k">return</span> <span class="n">pos</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="n">start</span><span class="p">]</span>

<div class="viewcode-block" id="AncestorData.insert_proxy_samples">
<a class="viewcode-back" href="../../api.html#tsinfer.AncestorData.insert_proxy_samples">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">insert_proxy_samples</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variant_data</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sample_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_mutation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Take a set of samples from a :class:`.VariantData` instance and create additional</span>
<span class="sd">        &quot;proxy sample ancestors&quot; from them, returning a new :class:`.AncestorData`</span>
<span class="sd">        instance including both the current ancestors and the additional ancestors</span>
<span class="sd">        at the appropriate time points.</span>

<span class="sd">        A *proxy sample ancestor* is an ancestor based upon a known sample. At</span>
<span class="sd">        sites used in the full inference process, the haplotype of this ancestor</span>
<span class="sd">        is identical to that of the sample on which it is based. The time of the</span>
<span class="sd">        ancestor is taken to be a fraction ``epsilon`` older than the sample on</span>
<span class="sd">        which it is based.</span>

<span class="sd">        A common use of this function is to provide ancestral nodes for anchoring</span>
<span class="sd">        historical samples at the correct time when matching them into a tree</span>
<span class="sd">        sequence during the :func:`tsinfer.match_samples` stage of inference.</span>
<span class="sd">        For this reason, by default, the samples chosen from ``sample_data``</span>
<span class="sd">        are those associated with historical (i.e. non-contemporary)</span>
<span class="sd">        :ref:`individuals &lt;sec_inference_data_model_individual&gt;`. This can be</span>
<span class="sd">        altered by using the ``sample_ids`` parameter.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The proxy sample ancestors inserted here will correspond to extra nodes</span>
<span class="sd">            in the inferred tree sequence. At sites which are not used in the full</span>
<span class="sd">            inference process (e.g. sites unique to a single historical sample),</span>
<span class="sd">            these proxy sample ancestor nodes may have a different genotype from</span>
<span class="sd">            their corresponding sample.</span>

<span class="sd">        :param VariantData variant_data: The `VariantData` instance</span>
<span class="sd">            from which to select the samples used to create extra ancestors.</span>
<span class="sd">        :param list(int) sample_ids: A list of sample ids in the ``variant_data``</span>
<span class="sd">            instance that will be selected to create the extra ancestors. If</span>
<span class="sd">            ``None`` (default) select all the historical samples, i.e. those</span>
<span class="sd">            associated with an :ref:`sec_inference_data_model_individual` whose</span>
<span class="sd">            time is greater than zero. The order of ids is ignored, as are</span>
<span class="sd">            duplicate ids.</span>
<span class="sd">        :param list(float) epsilon: An list of small time increments</span>
<span class="sd">            determining how much older each proxy sample ancestor is than the</span>
<span class="sd">            corresponding sample listed in ``sample_ids``. A single value is also</span>
<span class="sd">            allowed, in which case it is used as the time increment for all selected</span>
<span class="sd">            proxy sample ancestors. If None (default) find :math:`{\\delta}t`, the</span>
<span class="sd">            smallest time difference between between the sample times and the next</span>
<span class="sd">            oldest ancestor in the current :class:`.AncestorData` instance, setting</span>
<span class="sd">            ``epsilon`` = :math:`{\\delta}t / 100` (or, if all selected samples</span>
<span class="sd">            are at least as old as the oldest ancestor, take :math:`{\\delta}t`</span>
<span class="sd">            to be the smallest non-zero time difference between existing ancestors).</span>
<span class="sd">        :param bool allow_mutation: If ``False`` (the default), any site in a proxy</span>
<span class="sd">            sample ancestor that has a derived allele must have a pre-existing</span>
<span class="sd">            mutation in an older (non-proxy) ancestor, otherwise an error is raised.</span>
<span class="sd">            Alternatively, if ``allow_mutation`` is ``True``, proxy ancestors can</span>
<span class="sd">            contain a de-novo mutation at a site that also has a mutation elsewhere</span>
<span class="sd">            (i.e. breaking the infinite sites assumption), allowing them to possess</span>
<span class="sd">            derived alleles at sites where there are no pre-existing mutations in</span>
<span class="sd">            older ancestors.</span>
<span class="sd">        :param \\**kwargs: Further arguments passed to the constructor when creating</span>
<span class="sd">            the new :class:`AncestorData` instance which will be returned.</span>

<span class="sd">        :return: A new :class:`.AncestorData` object.</span>
<span class="sd">        :rtype: AncestorData</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
        <span class="n">variant_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;variant_data does not have the correct sequence length&quot;</span><span class="p">)</span>
        <span class="n">used_sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">variant_data</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">used_sites</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Genome positions in ancestors missing from variant_data&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sample_ids</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_ids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">individuals</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sample_ids</span> <span class="o">+=</span> <span class="n">i</span><span class="o">.</span><span class="n">samples</span>
        <span class="c1"># sort by ID and make unique for quick haplotype access</span>
        <span class="n">sample_ids</span><span class="p">,</span> <span class="n">unique_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_ids</span><span class="p">),</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">sample_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_ids</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_time</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sample_ids</span><span class="p">):</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sample</span><span class="o">.</span><span class="n">individual</span> <span class="o">!=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">:</span>
                <span class="n">sample_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">individual</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">individual</span><span class="p">)</span><span class="o">.</span><span class="n">time</span>

        <span class="k">if</span> <span class="n">epsilon</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">epsilons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">epsilon</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">epsilons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># all get the same epsilon</span>
                <span class="n">epsilons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">epsilons</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_ids</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">epsilons</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_indices</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;The number of epsilon values must equal the number of &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;sample_ids (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_ids</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
                    <span class="p">)</span>
                <span class="n">epsilons</span> <span class="o">=</span> <span class="n">epsilons</span><span class="p">[</span><span class="n">unique_indices</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">anc_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_time</span><span class="p">[:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># find ascending time order</span>
            <span class="n">older_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">anc_times</span><span class="p">,</span> <span class="n">sample_times</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
            <span class="c1"># Don&#39;t include times older than the oldest ancestor</span>
            <span class="n">allowed</span> <span class="o">=</span> <span class="n">older_index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">allowed</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">delta_t</span> <span class="o">=</span> <span class="n">anc_times</span><span class="p">[</span><span class="n">older_index</span><span class="p">[</span><span class="n">allowed</span><span class="p">]]</span> <span class="o">-</span> <span class="n">sample_times</span><span class="p">[</span><span class="n">allowed</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># All samples have times equal to or older than the oldest curr ancestor</span>
                <span class="n">time_diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">anc_times</span><span class="p">)</span>
                <span class="n">delta_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">time_diffs</span><span class="p">[</span><span class="n">time_diffs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">epsilons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">delta_t</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_ids</span><span class="p">))</span>

        <span class="n">proxy_times</span> <span class="o">=</span> <span class="n">sample_times</span> <span class="o">+</span> <span class="n">epsilons</span>
        <span class="n">reverse_time_sorted_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">proxy_times</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># In cases where we have more than a handful of samples to use as proxies, it is</span>
        <span class="c1"># inefficient to access the haplotypes out of order, so we iterate and cache</span>
        <span class="c1"># (caution: the haplotypes list may be quite large in this case)</span>
        <span class="n">haplotypes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">haplotypes</span><span class="p">(</span><span class="n">samples</span><span class="o">=</span><span class="n">sample_ids</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="n">used_sites</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">with</span> <span class="n">AncestorData</span><span class="p">(</span>
            <span class="n">variant_data</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:][</span><span class="n">used_sites</span><span class="p">],</span>
            <span class="n">variant_data</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span> <span class="k">as</span> <span class="n">other</span><span class="p">:</span>
            <span class="n">mutated_sites</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># To check if mutations have ocurred yet</span>
            <span class="n">ancestors_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors</span><span class="p">()</span>
            <span class="n">ancestor</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">ancestors_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">reverse_time_sorted_indexes</span><span class="p">:</span>
                <span class="n">proxy_time</span> <span class="o">=</span> <span class="n">proxy_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">sample_id</span> <span class="o">=</span> <span class="n">sample_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">haplotype</span> <span class="o">=</span> <span class="n">haplotypes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">while</span> <span class="n">ancestor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="n">proxy_time</span><span class="p">:</span>
                    <span class="n">ancestor_dict</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span>
                        <span class="n">ancestor</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="n">exclude_id_and_full_haplotype</span>
                    <span class="p">)</span>
                    <span class="n">ancestor_dict</span><span class="p">[</span><span class="s2">&quot;haplotype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">haplotype</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">add_ancestor</span><span class="p">(</span><span class="o">**</span><span class="n">ancestor_dict</span><span class="p">)</span>
                    <span class="n">mutated_sites</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ancestor</span><span class="o">.</span><span class="n">focal_sites</span><span class="p">)</span>
                    <span class="n">ancestor</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">ancestors_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_mutation</span><span class="p">:</span>
                    <span class="n">derived_sites</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">haplotype</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">derived_sites</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">mutated_sites</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Sample </span><span class="si">{</span><span class="n">sample_id</span><span class="si">}</span><span class="s2"> contains a new derived allele, which &quot;</span>
                            <span class="s2">&quot;requires a novel mutation, but `allow_mutation` is False.&quot;</span>
                        <span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Inserting proxy ancestor: sample </span><span class="si">{</span><span class="n">sample_id</span><span class="si">}</span><span class="s2"> at time </span><span class="si">{</span><span class="n">proxy_time</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">other</span><span class="o">.</span><span class="n">add_ancestor</span><span class="p">(</span>
                    <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">proxy_time</span><span class="p">,</span>
                    <span class="n">focal_sites</span><span class="o">=</span><span class="p">[],</span>
                    <span class="n">haplotype</span><span class="o">=</span><span class="n">haplotype</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="c1"># Add any ancestors remaining in the current instance</span>
            <span class="k">while</span> <span class="n">ancestor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ancestor_dict</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span>
                    <span class="n">ancestor</span><span class="p">,</span> <span class="nb">filter</span><span class="o">=</span><span class="n">exclude_id_and_full_haplotype</span>
                <span class="p">)</span>
                <span class="n">ancestor_dict</span><span class="p">[</span><span class="s2">&quot;haplotype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ancestor</span><span class="o">.</span><span class="n">haplotype</span>
                <span class="n">other</span><span class="o">.</span><span class="n">add_ancestor</span><span class="p">(</span><span class="o">**</span><span class="n">ancestor_dict</span><span class="p">)</span>
                <span class="n">ancestor</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">ancestors_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># TODO - set metadata on these ancestors, once ancestors have metadata</span>
            <span class="n">other</span><span class="o">.</span><span class="n">clear_provenances</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="p">():</span>
                <span class="n">other</span><span class="o">.</span><span class="n">add_provenance</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>
            <span class="n">other</span><span class="o">.</span><span class="n">record_provenance</span><span class="p">(</span><span class="n">command</span><span class="o">=</span><span class="s2">&quot;insert_proxy_samples&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">other</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_ids</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">other</span></div>


<div class="viewcode-block" id="AncestorData.truncate_ancestors">
<a class="viewcode-back" href="../../api.html#tsinfer.AncestorData.truncate_ancestors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">truncate_ancestors</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lower_time_bound</span><span class="p">,</span>
        <span class="n">upper_time_bound</span><span class="p">,</span>
        <span class="n">length_multiplier</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">buffer_length</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Truncates the length of ancestors above a given time and returns a new</span>
<span class="sd">        :class:`.AncestorData` instance.</span>

<span class="sd">        Given a set of haplotypes H such that ``lower_time_bound`` &lt;= ``h.time`` &lt;</span>
<span class="sd">        ``upper_time_bound``, we let ``max_len = length_multiplier * max(max(h.length)</span>
<span class="sd">        for h in H)``. Then, we truncate all haplotypes containing at least one focal</span>
<span class="sd">        site where ``h.time &gt;= upper``, ensuring these haplotypes extend no further than</span>
<span class="sd">        half of ``max_len`` to the either side of the leftmost and</span>
<span class="sd">        rightmost focal sites of the ancestral haplotype. Note that ancestors above</span>
<span class="sd">        ``upper_time_bound`` may still be longer than ``max_len`` if the ancestor</span>
<span class="sd">        contains greater than 2 focal sites.</span>

<span class="sd">        This function should be used when :func:`tsinfer.generate_ancestors` generates</span>
<span class="sd">        old ancestors which are very long, as these can significantly slow down matching</span>
<span class="sd">        time. Older ancestors should generally be shorter than younger ancestors, so</span>
<span class="sd">        truncating the lengths of older ancestors has negligible effect on inference</span>
<span class="sd">        accuracy.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Please ensure that the time values provided to ``lower_time_bound`` and</span>
<span class="sd">            ``upper_time_bound`` match the units used in the :class:`.AncestorData`</span>
<span class="sd">            file, i.e. if your ancestors do not have site times specified,</span>
<span class="sd">            ``upper_time_bound`` should be between 0 and 1.</span>

<span class="sd">        :param float lower_time_bound: Defines the lower bound (inclusive) of the half</span>
<span class="sd">            open interval where we search for a truncation value.</span>
<span class="sd">        :param float upper_time_bound: Defines the upper bound (exclusive) of the half</span>
<span class="sd">            open interval where we search for a truncation value. The truncation value</span>
<span class="sd">            is the length of the longest haplotype in this interval multiplied by</span>
<span class="sd">            ``length_multiplier``. The length of ancestors as old or older than</span>
<span class="sd">            ``upper_time_bound`` will be truncated using this value.</span>
<span class="sd">        :param float length_multiplier: A multiplier for the length of the longest</span>
<span class="sd">            ancestor in the half-open interval between ``lower_time_bound`` (inclusive)</span>
<span class="sd">            and ``uppper_time_bound`` (exclusive), i.e.</span>
<span class="sd">            if the longest ancestor in the interval is 1 megabase, a</span>
<span class="sd">            ``length_multiplier`` of 2 creates a maximum length of 2 megabases.</span>
<span class="sd">        :param int buffer_length: The number of changed ancestors to buffer before</span>
<span class="sd">            writing to disk.</span>
<span class="sd">        :param \\**kwargs: Further arguments passed to the :func:`AncestorData.copy`</span>
<span class="sd">            when creating the new :class:`AncestorData` instance which will be returned.</span>

<span class="sd">        :return: A new :class:`.AncestorData` object.</span>
<span class="sd">        :rtype: AncestorData</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Passed an AncestorData file with 0 ancestors. Nothing to do&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">upper_time_bound</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">lower_time_bound</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Time bounds cannot be negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">length_multiplier</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length multiplier cannot be zero or negative&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">upper_time_bound</span> <span class="o">&lt;</span> <span class="n">lower_time_bound</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Upper bound must be &gt;= lower bound&quot;</span><span class="p">)</span>

        <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:]</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_time</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="n">upper_time_bound</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="ow">or</span> <span class="n">lower_time_bound</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Time bounds cannot be greater than older ancestor&quot;</span><span class="p">)</span>

        <span class="n">anc_in_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
            <span class="n">time</span> <span class="o">&gt;=</span> <span class="n">lower_time_bound</span><span class="p">,</span>
            <span class="n">time</span> <span class="o">&lt;</span> <span class="n">upper_time_bound</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">anc_in_bound</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No ancestors in time bound&quot;</span><span class="p">)</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="n">length_multiplier</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_length</span><span class="p">[:][</span><span class="n">anc_in_bound</span><span class="p">])</span>

        <span class="n">truncated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Create a buffer of buffer_length ancestors with their indexes</span>
        <span class="n">index_buffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">buffer_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">start_buffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">buffer_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_start</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">end_buffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">buffer_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_end</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">time_buffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">buffer_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_time</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">focal_sites_buffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">buffer_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_focal_sites</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">haplotype_buffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_full_haplotype</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buffer_length</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">tskit</span><span class="o">.</span><span class="n">MISSING_DATA</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_full_haplotype</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">buffer_pos</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">flush_buffers</span><span class="p">(</span><span class="n">buffer_pos</span><span class="p">):</span>
            <span class="c1"># As we find ancestors that need to be truncated, we write them to the</span>
            <span class="c1"># buffers, with index_buffer storing the index of the ancestor in the</span>
            <span class="c1"># original AncestorData file. We can use then specify this index array to</span>
            <span class="c1"># zarr to just write those changed lines to the new AncestorData file.</span>
            <span class="n">truncated</span><span class="o">.</span><span class="n">ancestors_start</span><span class="o">.</span><span class="n">set_orthogonal_selection</span><span class="p">(</span>
                <span class="n">index_buffer</span><span class="p">[:</span><span class="n">buffer_pos</span><span class="p">],</span> <span class="n">start_buffer</span><span class="p">[:</span><span class="n">buffer_pos</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">truncated</span><span class="o">.</span><span class="n">ancestors_end</span><span class="o">.</span><span class="n">set_orthogonal_selection</span><span class="p">(</span>
                <span class="n">index_buffer</span><span class="p">[:</span><span class="n">buffer_pos</span><span class="p">],</span> <span class="n">end_buffer</span><span class="p">[:</span><span class="n">buffer_pos</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">truncated</span><span class="o">.</span><span class="n">ancestors_time</span><span class="o">.</span><span class="n">set_orthogonal_selection</span><span class="p">(</span>
                <span class="n">index_buffer</span><span class="p">[:</span><span class="n">buffer_pos</span><span class="p">],</span> <span class="n">time_buffer</span><span class="p">[:</span><span class="n">buffer_pos</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">truncated</span><span class="o">.</span><span class="n">ancestors_focal_sites</span><span class="o">.</span><span class="n">set_orthogonal_selection</span><span class="p">(</span>
                <span class="n">index_buffer</span><span class="p">[:</span><span class="n">buffer_pos</span><span class="p">],</span> <span class="n">focal_sites_buffer</span><span class="p">[:</span><span class="n">buffer_pos</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">truncated</span><span class="o">.</span><span class="n">ancestors_full_haplotype</span><span class="o">.</span><span class="n">set_orthogonal_selection</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">index_buffer</span><span class="p">[:</span><span class="n">buffer_pos</span><span class="p">]),</span>
                <span class="n">haplotype_buffer</span><span class="p">[:,</span> <span class="p">:</span><span class="n">buffer_pos</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">truncated</span><span class="o">.</span><span class="n">ancestors_full_haplotype_mask</span><span class="o">.</span><span class="n">set_orthogonal_selection</span><span class="p">(</span>
                <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">index_buffer</span><span class="p">[:</span><span class="n">buffer_pos</span><span class="p">]),</span>
                <span class="n">haplotype_buffer</span><span class="p">[:,</span> <span class="p">:</span><span class="n">buffer_pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MISSING_DATA</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">anc_index</span><span class="p">,</span> <span class="n">anc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">anc</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="n">upper_time_bound</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">anc</span><span class="o">.</span><span class="n">focal_sites</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">position</span><span class="p">[</span><span class="n">anc</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">position</span><span class="p">[</span><span class="n">anc</span><span class="o">.</span><span class="n">start</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_length</span><span class="p">:</span>
                    <span class="n">left_focal_pos</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">anc</span><span class="o">.</span><span class="n">focal_sites</span><span class="p">)]</span>
                    <span class="n">right_focal_pos</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">anc</span><span class="o">.</span><span class="n">focal_sites</span><span class="p">)]</span>
                    <span class="n">insert_pos_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
                        <span class="n">anc</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">left_focal_pos</span> <span class="o">-</span> <span class="n">max_length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">insert_pos_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span>
                        <span class="n">anc</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">right_focal_pos</span> <span class="o">+</span> <span class="n">max_length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">original_length</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="n">anc</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">position</span><span class="p">[</span><span class="n">anc</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>
                    <span class="n">new_length</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">position</span><span class="p">[</span><span class="n">insert_pos_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">position</span><span class="p">[</span><span class="n">insert_pos_start</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="k">assert</span> <span class="n">new_length</span> <span class="o">&lt;=</span> <span class="n">original_length</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Truncating ancestor </span><span class="si">{</span><span class="n">anc</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> at time </span><span class="si">{</span><span class="n">anc</span><span class="o">.</span><span class="n">time</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;Original length </span><span class="si">{original_length}</span><span class="s2">. New length </span><span class="si">{new_length}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">index_buffer</span><span class="p">[</span><span class="n">buffer_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">anc_index</span>
                    <span class="n">start_buffer</span><span class="p">[</span><span class="n">buffer_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">insert_pos_start</span>
                    <span class="n">end_buffer</span><span class="p">[</span><span class="n">buffer_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">insert_pos_end</span>
                    <span class="n">time_buffer</span><span class="p">[</span><span class="n">buffer_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">anc</span><span class="o">.</span><span class="n">time</span>
                    <span class="n">focal_sites_buffer</span><span class="p">[</span><span class="n">buffer_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">anc</span><span class="o">.</span><span class="n">focal_sites</span>
                    <span class="n">haplotype_buffer</span><span class="p">[</span><span class="n">insert_pos_start</span><span class="p">:</span><span class="n">insert_pos_end</span><span class="p">,</span> <span class="n">buffer_pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">anc</span><span class="o">.</span><span class="n">full_haplotype</span><span class="p">[</span><span class="n">insert_pos_start</span><span class="p">:</span><span class="n">insert_pos_end</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">buffer_pos</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">buffer_pos</span> <span class="o">==</span> <span class="n">buffer_length</span><span class="p">:</span>
                        <span class="n">flush_buffers</span><span class="p">(</span><span class="n">buffer_length</span><span class="p">)</span>
                        <span class="n">buffer_pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">buffer_pos</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">flush_buffers</span><span class="p">(</span><span class="n">buffer_pos</span><span class="p">)</span>
        <span class="n">truncated</span><span class="o">.</span><span class="n">record_provenance</span><span class="p">(</span><span class="n">command</span><span class="o">=</span><span class="s2">&quot;truncate_ancestors&quot;</span><span class="p">)</span>
        <span class="n">truncated</span><span class="o">.</span><span class="n">finalise</span><span class="p">()</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">==</span> <span class="n">truncated</span><span class="o">.</span><span class="n">num_ancestors</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">truncated</span><span class="o">.</span><span class="n">ancestors_time</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">truncated</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:])</span>
        <span class="k">return</span> <span class="n">truncated</span></div>


    <span class="c1">####################################</span>
    <span class="c1"># Write mode (building and editing)</span>
    <span class="c1">####################################</span>

<div class="viewcode-block" id="AncestorData.add_ancestor">
<a class="viewcode-back" href="../../api.html#tsinfer.AncestorData.add_ancestor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_ancestor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">focal_sites</span><span class="p">,</span> <span class="n">haplotype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an ancestor with the specified haplotype, with ancestral material over the</span>
<span class="sd">        interval [start:end], that is associated with the specified timepoint and has new</span>
<span class="sd">        mutations at the specified list of focal sites. Ancestors should be added in time</span>
<span class="sd">        order, with the oldest first. The id of the added ancestor is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_build_mode</span><span class="p">()</span>
        <span class="n">haplotype</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">haplotype</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">focal_sites</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span>
            <span class="n">focal_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Start must be &gt;= 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;end must be &lt;= num_sites&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;start must be &lt; end&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">haplotype</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;haplotypes incorrect shape.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">focal_sites</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">focal_sites</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;focal sites must be between start and end&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;time must be &gt; 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_time</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_time</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;older ancestors must be added before younger ones&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_writer</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">focal_sites</span><span class="o">=</span><span class="n">focal_sites</span><span class="p">,</span>
            <span class="n">haplotype</span><span class="o">=</span><span class="n">haplotype</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="AncestorData.finalise">
<a class="viewcode-back" href="../../api.html#tsinfer.AncestorData.finalise">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">finalise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">BUILD_MODE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_writer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;variant_allele&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;variant_allele&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">([</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="o">.</span><span class="n">chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;U1&quot;</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="o">.</span><span class="n">compressor</span><span class="p">,</span>
            <span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;variants&quot;</span><span class="p">,</span> <span class="s2">&quot;alleles&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;sample_id&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
            <span class="s2">&quot;sample_id&quot;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;tsinf_anc_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_start</span><span class="p">))],</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_start</span><span class="p">),),</span>
            <span class="n">chunks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_start</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">compressor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_start</span><span class="o">.</span><span class="n">compressor</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">finalise</span><span class="p">()</span></div>


    <span class="c1">####################################</span>
    <span class="c1"># Read mode</span>
    <span class="c1">####################################</span>

<div class="viewcode-block" id="AncestorData.ancestor">
<a class="viewcode-back" href="../../api.html#tsinfer.AncestorData.ancestor">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ancestor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the ancestor with the specified ID.</span>

<span class="sd">        :rtype: `Ancestor`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Ancestor</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_start</span><span class="p">[</span><span class="n">id_</span><span class="p">],</span>
            <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_end</span><span class="p">[</span><span class="n">id_</span><span class="p">],</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_time</span><span class="p">[</span><span class="n">id_</span><span class="p">],</span>
            <span class="n">focal_sites</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_focal_sites</span><span class="p">[</span><span class="n">id_</span><span class="p">],</span>
            <span class="n">full_haplotype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_full_haplotype</span><span class="p">[:,</span> <span class="n">id_</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="AncestorData.ancestors">
<a class="viewcode-back" href="../../api.html#tsinfer.AncestorData.ancestors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all the ancestors. If indexes is provided, it should</span>
<span class="sd">        be a sorted list of indexes giving a subset of ancestors to return.</span>
<span class="sd">        For efficiency, the indexes should be a numpy integer array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_start</span><span class="p">[:]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_end</span><span class="p">[:]</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_time</span><span class="p">[:]</span>
        <span class="n">focal_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_focal_sites</span><span class="p">[:]</span>
        <span class="n">haplotypes</span> <span class="o">=</span> <span class="n">chunk_iterator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestors_full_haplotype</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">haplotypes</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">Ancestor</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
                <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">focal_sites</span><span class="o">=</span><span class="n">focal_sites</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="c1"># [0] to remove ploidy dimension</span>
                <span class="n">full_haplotype</span><span class="o">=</span><span class="n">h</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="load">
<a class="viewcode-back" href="../../api.html#tsinfer.load">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads a tsinfer :class:`.AncestorData` file from</span>
<span class="sd">    the specified path. If the file is format not recognised a</span>
<span class="sd">    :class:`.FileFormatError` will be thrown.</span>

<span class="sd">    :param str path: The path of the file we wish to load.</span>
<span class="sd">    :return: The corresponding :class:`.AncestorData`</span>
<span class="sd">        instance opened in read only mode.</span>
<span class="sd">    :rtype: :class:`.AncestorData`.</span>
<span class="sd">    :raises: :class:`.FileFormatError` if the file cannot be read.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO This is pretty inelegant, but it works. Really we should call the</span>
    <span class="c1"># load on the superclass which can dispatch to the registered subclasses</span>
    <span class="c1"># for a given format_name.</span>
    <span class="n">tsinfer_file</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Trying SampleData file&quot;</span><span class="p">)</span>
        <span class="n">tsinfer_file</span> <span class="o">=</span> <span class="n">SampleData</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Loaded SampleData file&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">FileFormatError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SampleData load failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Trying AncestorData file&quot;</span><span class="p">)</span>
        <span class="n">tsinfer_file</span> <span class="o">=</span> <span class="n">AncestorData</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Loaded AncestorData file&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">FileFormatError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AncestorData load failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tsinfer_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exceptions</span><span class="o">.</span><span class="n">FileFormatError</span><span class="p">(</span>
            <span class="s2">&quot;Unrecognised file format. Try running with -vv and check the log &quot;</span>
            <span class="s2">&quot;for more details on what went wrong&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">tsinfer_file</span></div>



<div class="viewcode-block" id="add_ancestral_state_array">
<a class="viewcode-back" href="../../api.html#tsinfer.add_ancestral_state_array">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">add_ancestral_state_array</span><span class="p">(</span>
    <span class="n">zarr_group</span><span class="p">,</span> <span class="n">fasta_string</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">array_name</span><span class="o">=</span><span class="s2">&quot;ancestral_state&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add an ancestral state array to a zarr group from a string of nucleotides</span>
<span class="sd">    representing the ancestral sequence.</span>

<span class="sd">    :param zarr.Group zarr_group: A zarr group to add the ancestral state array to.</span>
<span class="sd">        This should be a VCF Zarr format group containing a &quot;variant_position&quot; array.</span>
<span class="sd">    :param str fasta_string: A string containing the ancestral sequence,</span>
<span class="sd">        from e.g. FASTA.</span>
<span class="sd">    :param str array_name: The name of the array to create in the zarr group.</span>
<span class="sd">        Default is &quot;ancestral_state&quot;.</span>
<span class="sd">    :return: The newly inserted ancestral state array.</span>
<span class="sd">    :rtype: zarr.Array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;variant_position&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">zarr_group</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The zarr group must contain a &#39;variant_position&#39; array&quot;</span><span class="p">)</span>

    <span class="n">positions</span> <span class="o">=</span> <span class="n">zarr_group</span><span class="p">[</span><span class="s2">&quot;variant_position&quot;</span><span class="p">][:]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The variant_position array must contain at least one position&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fasta_string</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The length of the fasta string must be at least as long as the &quot;</span>
            <span class="s2">&quot;maximum position in the positions array.&quot;</span>
        <span class="p">)</span>

    <span class="n">ancestral_sequence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">fasta_string</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;U1&quot;</span><span class="p">)</span>
    <span class="n">ancestral_states</span> <span class="o">=</span> <span class="n">ancestral_sequence</span><span class="p">[</span><span class="n">positions</span><span class="p">]</span>
    <span class="n">ancestral_states_upper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">upper</span><span class="p">(</span><span class="n">ancestral_states</span><span class="p">)</span>

    <span class="c1"># Create the ancestral state array in the zarr group with the</span>
    <span class="c1"># same chunking as positions</span>
    <span class="n">ancestral_array</span> <span class="o">=</span> <span class="n">zarr_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
        <span class="n">array_name</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="n">ancestral_states_upper</span><span class="p">,</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">ancestral_states_upper</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">zarr_group</span><span class="p">[</span><span class="s2">&quot;variant_position&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;U1&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Add dimension attribute for compatibility with xarray/sgkit</span>
    <span class="n">ancestral_array</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;_ARRAY_DIMENSIONS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;variants&quot;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ancestral_array</span></div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Tskit Developers
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
       Copyright 2018.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>