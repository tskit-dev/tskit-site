
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tsinfer.inference &#8212; Tsinfer manual</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/tsinfer/inference';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <script data-goatcounter="https://tskit.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/tsinfer_logo.svg" class="logo__image only-light" alt=""/>
    <script>document.write(`<img src="../../_static/tsinfer_logo.svg" class="logo__image only-dark" alt=""/>`);</script>
  
  
    <p class="title logo__title">Version undefined</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Introduction</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Installation</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Usage</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Inference</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../inference.html">Inference overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../large_scale.html">Large scale inference</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Interfaces</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli.html">Command line interface</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">File Formats</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../file_formats.html">File formats</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Miscellaneous</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Developer documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CITATION.html">Citing tsinfer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../CHANGELOG.html">Changelog</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for tsinfer.inference</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Copyright (C) 2018-2023 University of Oxford</span>
<span class="c1">#</span>
<span class="c1"># This file is part of tsinfer.</span>
<span class="c1">#</span>
<span class="c1"># tsinfer is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># tsinfer is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with tsinfer.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Central module for high-level inference. The actual implementation of</span>
<span class="sd">of the core tasks like ancestor generation and matching are delegated</span>
<span class="sd">to other modules.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dataclasses</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pathlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">queue</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tempfile</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">threading</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">time_</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">humanize</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">_tsinfer</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tsinfer.algorithm</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">algorithm</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tsinfer.ancestors</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ancestors</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tsinfer.constants</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">constants</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tsinfer.formats</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">formats</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tsinfer.progress</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">progress</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tsinfer.provenance</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">provenance</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tsinfer.threads</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">threads</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="n">variant_data_time_metadata_definition</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Time of an individual from the SampleData file.&quot;</span><span class="p">,</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span>
    <span class="c1"># Defaults aren&#39;t currently used, see</span>
    <span class="c1"># https://github.com/tskit-dev/tskit/issues/1073</span>
    <span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">inference_type_metadata_definition</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="p">(</span>
        <span class="s2">&quot;The type of inference used at this site. This can be one of the following: &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_FULL</span><span class="si">}</span><span class="s2">&#39; for sites which used the standard tsinfer &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;algorithm; &#39;</span><span class="si">{</span><span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_NONE</span><span class="si">}</span><span class="s2">&#39; for sites containing only missing &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;data or the ancestral state; &#39;</span><span class="si">{</span><span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_PARSIMONY</span><span class="si">}</span><span class="s2">&#39; for sites &quot;</span>
        <span class="s2">&quot;that used a parsimony algorithm to place mutations based on trees inferred &quot;</span>
        <span class="s2">&quot;from the remaining data.&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
    <span class="s2">&quot;enum&quot;</span><span class="p">:</span> <span class="p">[</span>
        <span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_NONE</span><span class="p">,</span>
        <span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_FULL</span><span class="p">,</span>
        <span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_PARSIMONY</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">}</span>

<span class="n">node_ancestor_data_id_metadata_definition</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="p">(</span>
        <span class="s2">&quot;The ID of the tsinfer ancestor data node from which this node is derived.&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">node_variant_data_id_metadata_definition</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="p">(</span>
        <span class="s2">&quot;The ID of the tsinfer sample data node from which this node is derived. &quot;</span>
        <span class="s2">&quot;Only present for nodes in which historical samples are treated as ancestors.&quot;</span>
    <span class="p">),</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span>
<span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">add_to_schema</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">definition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds the specified metadata name to the schema, with the specified definition.</span>
<span class="sd">    If the metadata name is already in the schema then either will warn about</span>
<span class="sd">    potential overwriting (if the definition is the same and there is a description),</span>
<span class="sd">    or will raise an error otherwise (to avoid conflicting metadata definitions).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">schema</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">definition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">definition</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">schema</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="n">definition</span>
                    <span class="ow">and</span> <span class="n">definition</span><span class="p">[</span><span class="s2">&quot;description&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span>
                <span class="p">):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Metadata </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> with identical description already in schema.&quot;</span>
                        <span class="s2">&quot; Schema left unchanged: existing metadata may be overwritten.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="n">schema</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The metadata </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> is reserved for use by tsinfer&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">schema</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">schema</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">definition</span>
    <span class="k">if</span> <span class="n">required</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;required&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">schema</span><span class="p">:</span>
            <span class="n">schema</span><span class="p">[</span><span class="s2">&quot;required&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">schema</span><span class="p">[</span><span class="s2">&quot;required&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">schema</span>


<span class="k">def</span><span class="w"> </span><span class="nf">is_pc_ancestor</span><span class="p">(</span><span class="n">flags</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if the path compression ancestor flag is set on the specified</span>
<span class="sd">    flags value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">constants</span><span class="o">.</span><span class="n">NODE_IS_PC_ANCESTOR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>


<span class="k">def</span><span class="w"> </span><span class="nf">is_srb_ancestor</span><span class="p">(</span><span class="n">flags</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if the shared recombination breakpoint flag is set on the</span>
<span class="sd">    specified flags value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">constants</span><span class="o">.</span><span class="n">NODE_IS_SRB_ANCESTOR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>


<span class="k">def</span><span class="w"> </span><span class="nf">count_pc_ancestors</span><span class="p">(</span><span class="n">flags</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the number of values in the specified array which have the</span>
<span class="sd">    NODE_IS_PC_ANCESTOR set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">is_pc_ancestor</span><span class="p">(</span><span class="n">flags</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">count_srb_ancestors</span><span class="p">(</span><span class="n">flags</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the number of values in the specified array which have the</span>
<span class="sd">    NODE_IS_SRB_ANCESTOR set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">NODE_IS_SRB_ANCESTOR</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>


<span class="n">AlleleCounts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;AlleleCounts&quot;</span><span class="p">,</span> <span class="s2">&quot;known ancestral derived&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">allele_counts</span><span class="p">(</span><span class="n">genotypes</span><span class="p">,</span> <span class="n">ancestral_allele</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return summary counts of the number of different allele types for a genotypes array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_known</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">genotypes</span> <span class="o">!=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MISSING_DATA</span><span class="p">)</span>
    <span class="n">n_ancestral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">genotypes</span> <span class="o">==</span> <span class="n">ancestral_allele</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AlleleCounts</span><span class="p">(</span>
        <span class="n">known</span><span class="o">=</span><span class="n">n_known</span><span class="p">,</span> <span class="n">ancestral</span><span class="o">=</span><span class="n">n_ancestral</span><span class="p">,</span> <span class="n">derived</span><span class="o">=</span><span class="n">n_known</span> <span class="o">-</span> <span class="n">n_ancestral</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if this really is a ProgressMonitor, if not, return something usable as one</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">,</span> <span class="n">progress</span><span class="o">.</span><span class="n">ProgressMonitor</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">progress_monitor</span>
    <span class="k">if</span> <span class="n">progress_monitor</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">progress</span><span class="o">.</span><span class="n">ProgressMonitor</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">progress</span><span class="o">.</span><span class="n">DummyProgressMonitor</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_encode_raw_metadata</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_update_site_metadata</span><span class="p">(</span><span class="n">current_metadata</span><span class="p">,</span> <span class="n">inference_type</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;inference_type&quot;</span><span class="p">:</span> <span class="n">inference_type</span><span class="p">,</span> <span class="o">**</span><span class="n">current_metadata</span><span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">verify</span><span class="p">(</span><span class="n">variant_data</span><span class="p">,</span> <span class="n">tree_sequence</span><span class="p">,</span> <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    verify(samples, tree_sequence)</span>

<span class="sd">    Verifies that the specified sample data and tree sequence files encode the</span>
<span class="sd">    same data.</span>

<span class="sd">    :param SampleData samples: The input `SampleData` instance</span>
<span class="sd">        representing the observed data that we wish to compare to.</span>
<span class="sd">    :param TreeSequence tree_sequence: The input :class:`tskit.TreeSequence`</span>
<span class="sd">        instance an encoding of the specified samples that we wish to verify.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">!=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_sites</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;numbers of sites not equal&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">!=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;numbers of samples not equal&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sequence lengths not equal&quot;</span><span class="p">)</span>
    <span class="n">progress</span> <span class="o">=</span> <span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;verify&quot;</span><span class="p">,</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">var1</span><span class="p">,</span> <span class="n">var2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
        <span class="n">variant_data</span><span class="o">.</span><span class="n">variants</span><span class="p">(</span><span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">variants</span><span class="p">()</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span> <span class="o">!=</span> <span class="n">var2</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;site positions not equal: </span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="n">var2</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">position</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># First (ancestral) allele should always be the same</span>
        <span class="k">if</span> <span class="n">var1</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">var2</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ancestral allele not equal at site </span><span class="si">{</span><span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">var1</span><span class="o">.</span><span class="n">alleles</span> <span class="o">!=</span> <span class="n">var2</span><span class="o">.</span><span class="n">alleles</span><span class="p">:</span>
            <span class="c1"># Alleles may be in a different order, or even present/absent if not in the</span>
            <span class="c1"># genotype matrix so we need to explicitly compare the decoded values (slow)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">var1</span><span class="o">.</span><span class="n">genotypes</span><span class="p">,</span> <span class="n">var2</span><span class="o">.</span><span class="n">genotypes</span><span class="p">)):</span>
                <span class="c1"># We don&#39;t expect missingness in a tsinfer generated tree sequence</span>
                <span class="k">assert</span> <span class="n">g2</span> <span class="o">!=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span>
                <span class="k">if</span> <span class="n">g1</span> <span class="o">!=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span> <span class="ow">and</span> <span class="n">var1</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="n">g1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">var2</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="n">g2</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Alleles for sample </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> not equal at site </span><span class="si">{</span><span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="n">var1</span><span class="o">.</span><span class="n">genotypes</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">var2</span><span class="o">.</span><span class="n">genotypes</span><span class="p">)</span>
            <span class="n">missing_mask</span> <span class="o">=</span> <span class="n">g1</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span>
            <span class="n">g2</span><span class="p">[</span><span class="n">missing_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Genotypes not equal at site </span><span class="si">{</span><span class="n">var1</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
    <span class="n">progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">check_sample_indexes</span><span class="p">(</span><span class="n">variant_data</span><span class="p">,</span> <span class="n">indexes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks that the specified sample indexes are valid for the specified</span>
<span class="sd">    sample data file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">variant_data</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must supply at least one sample to match&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indexes</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indexes</span> <span class="o">&gt;=</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">num_samples</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample index out of bounds&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">indexes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample indexes must be in increasing order&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">indexes</span>


<div class="viewcode-block" id="infer">
<a class="viewcode-back" href="../../api.html#tsinfer.infer">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">infer</span><span class="p">(</span>
    <span class="n">variant_data</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mismatch_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">path_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">exclude_positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">post_process</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="c1"># Deliberately undocumented parameters below</span>
    <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">likelihood_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
    <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">time_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">simplify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Deprecated</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    infer(variant_data, *, recombination_rate=None, mismatch_ratio=None,\</span>
<span class="sd">            path_compression=True, exclude_positions=None, post_process=None,\</span>
<span class="sd">            num_threads=0)</span>

<span class="sd">    Runs the full :ref:`inference pipeline &lt;sec_inference&gt;` on the specified</span>
<span class="sd">    :class:`VariantData` instance and returns the inferred</span>
<span class="sd">    :class:`tskit.TreeSequence`.  See</span>
<span class="sd">    :ref:`matching ancestors &amp; samples&lt;sec_inference_match_ancestors_and_samples&gt;`</span>
<span class="sd">    in the documentation for details of ``recombination_rate``, ``mismatch_ratio``</span>
<span class="sd">    and ``path_compression``.</span>

<span class="sd">    .. note::</span>
<span class="sd">        For finer grained control over inference, for example to set mismatch</span>
<span class="sd">        ratios when matching ancestors as well as when matching samples, run</span>
<span class="sd">        :func:`tsinfer.generate_ancestors`, :func:`tsinfer.match_ancestors` and</span>
<span class="sd">        :func:`tsinfer.match_samples` separately.</span>

<span class="sd">    :param VariantData variant_data: The input :class:`VariantData` instance</span>
<span class="sd">        representing the observed data that we wish to make inferences from.</span>
<span class="sd">    :param recombination_rate: Either a floating point value giving a constant rate</span>
<span class="sd">        :math:`\\rho` per unit length of genome, or an :class:`msprime.RateMap`</span>
<span class="sd">        object. This is used to calculate the probability of recombination between</span>
<span class="sd">        adjacent sites in the match_samples stage. If ``None``, all matching</span>
<span class="sd">        conflicts are resolved by recombination and all inference sites will have</span>
<span class="sd">        a single mutation (equivalent to mismatch_ratio near zero).</span>
<span class="sd">    :type recombination_rate: float, msprime.RateMap</span>
<span class="sd">    :param float mismatch_ratio: The probability of a mismatch relative to the median</span>
<span class="sd">        probability of recombination between adjacent sites: can only be used if a</span>
<span class="sd">        recombination rate has been set (default: ``None`` treated as 1 if</span>
<span class="sd">        ``recombination_rate`` is set). This is only applied in the match_samples stage.</span>
<span class="sd">    :param bool path_compression: Whether to merge edges that share identical</span>
<span class="sd">        paths (essentially taking advantage of shared recombination breakpoints).</span>
<span class="sd">    :param bool post_process: Whether to run the :func:`post_process` method on the</span>
<span class="sd">        the tree sequence which, among other things, removes ancestral material that</span>
<span class="sd">        does not end up in the current samples (if not specified, defaults to ``True``)</span>
<span class="sd">    :param array_like exclude_positions: A list of site positions to exclude</span>
<span class="sd">        for full inference. Sites with these positions will not be used to generate</span>
<span class="sd">        ancestors, and not used during the copying process. Any such sites that</span>
<span class="sd">        exist in the sample data file will be included in the trees after the</span>
<span class="sd">        main inference process using parsimony. The list does not need to be</span>
<span class="sd">        in to be in any particular order, and can include site positions that</span>
<span class="sd">        are not present in the sample data file.</span>
<span class="sd">    :param int num_threads: The number of worker threads to use in parallelised</span>
<span class="sd">        sections of the algorithm. If &lt;= 0, do not spawn any threads and</span>
<span class="sd">        use simpler sequential algorithms (default).</span>
<span class="sd">    :param bool simplify: When post_processing, only simplify the tree sequence.</span>
<span class="sd">        deprecated but retained for backwards compatibility (default: ``None``).</span>
<span class="sd">    :return: The :class:`tskit.TreeSequence` object inferred from the</span>
<span class="sd">        input sample data.</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">provenance</span><span class="o">.</span><span class="n">TimingAndMemory</span><span class="p">()</span> <span class="k">as</span> <span class="n">timing</span><span class="p">:</span>
        <span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span>
            <span class="n">progress_monitor</span><span class="p">,</span>
            <span class="n">generate_ancestors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">match_ancestors</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">match_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ancestor_data</span> <span class="o">=</span> <span class="n">generate_ancestors</span><span class="p">(</span>
            <span class="n">variant_data</span><span class="p">,</span>
            <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
            <span class="n">exclude_positions</span><span class="o">=</span><span class="n">exclude_positions</span><span class="p">,</span>
            <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
            <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># NB: do not pass or encourage use of the mismatch ratio / recombination rate in</span>
        <span class="c1"># the ancestor matching phase. See</span>
        <span class="c1"># https://github.com/tskit-dev/tsinfer/issues/980</span>
        <span class="n">ancestors_ts</span> <span class="o">=</span> <span class="n">match_ancestors</span><span class="p">(</span>
            <span class="n">variant_data</span><span class="p">,</span>
            <span class="n">ancestor_data</span><span class="p">,</span>
            <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
            <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">likelihood_threshold</span><span class="o">=</span><span class="n">likelihood_threshold</span><span class="p">,</span>
            <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
            <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
            <span class="n">time_units</span><span class="o">=</span><span class="n">time_units</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">inferred_ts</span> <span class="o">=</span> <span class="n">match_samples</span><span class="p">(</span>
            <span class="n">variant_data</span><span class="p">,</span>
            <span class="n">ancestors_ts</span><span class="p">,</span>
            <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
            <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
            <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
            <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">likelihood_threshold</span><span class="o">=</span><span class="n">likelihood_threshold</span><span class="p">,</span>
            <span class="n">post_process</span><span class="o">=</span><span class="n">post_process</span><span class="p">,</span>
            <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
            <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
            <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">inferred_ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span>
            <span class="n">command</span><span class="o">=</span><span class="s2">&quot;infer&quot;</span><span class="p">,</span>
            <span class="n">resources</span><span class="o">=</span><span class="n">timing</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">asdict</span><span class="p">(),</span>
            <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
            <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">,</span>
            <span class="n">post_process</span><span class="o">=</span><span class="n">post_process</span><span class="p">,</span>
            <span class="c1"># TODO: maybe record recombination rate (which could be a RateMap)</span>
        <span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
        <span class="n">inferred_ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">inferred_ts</span></div>



<div class="viewcode-block" id="generate_ancestors">
<a class="viewcode-back" href="../../api.html#tsinfer.generate_ancestors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_ancestors</span><span class="p">(</span>
    <span class="n">variant_data</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">exclude_positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">genotype_encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mmap_temp_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="c1"># Deliberately undocumented parameters below</span>
    <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
    <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    generate_ancestors(variant_data, *, path=None, exclude_positions=None,\</span>
<span class="sd">        num_threads=0, genotype_encoding=None, mmap_temp_dir=None, **kwargs)</span>

<span class="sd">    Runs the ancestor generation :ref:`algorithm &lt;sec_inference_generate_ancestors&gt;`</span>
<span class="sd">    on the specified :class:`VariantData` instance and returns the resulting</span>
<span class="sd">    :class:`AncestorData` instance. If you wish to store generated ancestors</span>
<span class="sd">    persistently on file you must pass the ``path`` keyword argument to this</span>
<span class="sd">    function. For example,</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        ancestor_data = tsinfer.generate_ancestors(variant_data, path=&quot;mydata.ancestors&quot;)</span>

<span class="sd">    Other keyword arguments are passed to the :class:`AncestorData` constructor,</span>
<span class="sd">    which may be used to control the storage properties of the generated file.</span>

<span class="sd">    Ancestor generation involves loading the entire genotype matrix into</span>
<span class="sd">    memory, by default using one byte per haploid genotype, which can be</span>
<span class="sd">    prohibitively large when working with sample sizes of 100,000 or more.</span>
<span class="sd">    There are two options to help mitigate memory usage. The</span>
<span class="sd">    ``genotype_encoding`` parameter allows the user to specify a more compact</span>
<span class="sd">    encoding scheme, which reduces storage space for datasets with small</span>
<span class="sd">    numbers of alleles. Currently, the :attr:`.GenotypeEncoding.ONE_BIT`</span>
<span class="sd">    encoding is supported, which provides 8-fold compression of biallelic,</span>
<span class="sd">    non-missing data. An error is raised if an encoding that does not support</span>
<span class="sd">    the range of values present in a given dataset is provided.</span>

<span class="sd">    The second option for reducing the RAM footprint of this function is to</span>
<span class="sd">    use the ``mmap_temp_dir`` parameter. This allows the genotype data to be</span>
<span class="sd">    cached on file, transparently using the operating system&#39;s virtual memory</span>
<span class="sd">    subsystem to swap in and out the data. This can work well if the encoded</span>
<span class="sd">    genotype matrix *almost* fits in RAM and fast local storage is available.</span>
<span class="sd">    However, if the size of the encoded genotype matrix is more than, say,</span>
<span class="sd">    twice the available RAM it is unlikely that this function will complete</span>
<span class="sd">    in a reasonable time-frame. A temporary file is created in the specified</span>
<span class="sd">    ``mmap_temp_dir``, which is automatically deleted when the function</span>
<span class="sd">    completes.</span>

<span class="sd">    .. warning:: The ``mmap_temp_dir`` option is a silent no-op on Windows!</span>

<span class="sd">    :param VariantData variant_data: The :class:`VariantData` instance that we are</span>
<span class="sd">        generating putative ancestors from.</span>
<span class="sd">    :param str path: The path of the file to store the ancestor data. If None,</span>
<span class="sd">        the information is stored in memory and not persistent.</span>
<span class="sd">    :param array_like exclude_positions: A list of site positions to exclude</span>
<span class="sd">        for full inference. Sites with these positions will not be used to generate</span>
<span class="sd">        ancestors, and not used during the copying process. The list does not</span>
<span class="sd">        need be in any particular order.</span>
<span class="sd">    :param int num_threads: The number of worker threads to use. If &lt; 1, use a</span>
<span class="sd">        simpler synchronous algorithm.</span>
<span class="sd">    :param int genotype_encoding: The encoding to use for genotype data internally</span>
<span class="sd">        when generating ancestors. See the :class:`.GenotypeEncoding` class for</span>
<span class="sd">        the available options. Defaults to one-byte per genotype.</span>
<span class="sd">    :param str mmap_temp_dir: The directory within which to create the</span>
<span class="sd">        temporary backing file when using mmaped memory for bulk genotype</span>
<span class="sd">        storage. If None (the default) allocate memory directly using the</span>
<span class="sd">        standard mechanism. This is an advanced option, usually only relevant</span>
<span class="sd">        when working with very large datasets (see above for more information).</span>
<span class="sd">    :return: The inferred ancestors stored in an :class:`AncestorData` instance.</span>
<span class="sd">    :rtype: AncestorData</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">provenance</span><span class="o">.</span><span class="n">TimingAndMemory</span><span class="p">()</span> <span class="k">as</span> <span class="n">timing</span><span class="p">:</span>
        <span class="n">variant_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">variant_data</span><span class="o">.</span><span class="n">sites_time</span><span class="p">[:]))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="n">tskit</span><span class="o">.</span><span class="n">is_unknown_time</span><span class="p">(</span><span class="n">variant_data</span><span class="o">.</span><span class="n">sites_time</span><span class="p">[:])</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot generate ancestors from a variant_data instance that mixes&quot;</span>
                <span class="s2">&quot; user-specified times with times-as-frequencies. To explicitly&quot;</span>
                <span class="s2">&quot; set an undefined time for a site, permanently excluding it&quot;</span>
                <span class="s2">&quot; from inference, set it to np.nan.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">genotype_encoding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO should we provide some functionality to automatically figure</span>
            <span class="c1"># out what the minimum encoding is?</span>
            <span class="n">genotype_encoding</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">GenotypeEncoding</span><span class="o">.</span><span class="n">EIGHT_BIT</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="n">AncestorsGenerator</span><span class="p">(</span>
            <span class="n">variant_data</span><span class="p">,</span>
            <span class="n">ancestor_data_path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
            <span class="n">ancestor_data_kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
            <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
            <span class="n">genotype_encoding</span><span class="o">=</span><span class="n">genotype_encoding</span><span class="p">,</span>
            <span class="n">mmap_temp_dir</span><span class="o">=</span><span class="n">mmap_temp_dir</span><span class="p">,</span>
            <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">generator</span><span class="o">.</span><span class="n">add_sites</span><span class="p">(</span><span class="n">exclude_positions</span><span class="p">)</span>
        <span class="n">ancestor_data</span> <span class="o">=</span> <span class="n">generator</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">provenances</span><span class="p">():</span>
            <span class="n">ancestor_data</span><span class="o">.</span><span class="n">add_provenance</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
        <span class="n">ancestor_data</span><span class="o">.</span><span class="n">record_provenance</span><span class="p">(</span><span class="s2">&quot;generate_ancestors&quot;</span><span class="p">,</span> <span class="n">timing</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span>
    <span class="n">ancestor_data</span><span class="o">.</span><span class="n">finalise</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ancestor_data</span></div>



<div class="viewcode-block" id="match_ancestors">
<a class="viewcode-back" href="../../api.html#tsinfer.match_ancestors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match_ancestors</span><span class="p">(</span>
    <span class="n">variant_data</span><span class="p">,</span>
    <span class="n">ancestor_data</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mismatch_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">path_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="c1"># Deliberately undocumented parameters below</span>
    <span class="n">recombination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">mismatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">likelihood_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
    <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">extended_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">time_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    match_ancestors(variant_data, ancestor_data, *, recombination_rate=None,\</span>
<span class="sd">        mismatch_ratio=None, path_compression=True, num_threads=0)</span>

<span class="sd">    Run the ancestor matching :ref:`algorithm &lt;sec_inference_match_ancestors&gt;`</span>
<span class="sd">    on the specified :class:`VariantData` and :class:`AncestorData` instances,</span>
<span class="sd">    returning the resulting :class:`tskit.TreeSequence` representing the</span>
<span class="sd">    complete ancestry of the putative ancestors. See</span>
<span class="sd">    :ref:`matching ancestors &amp; samples&lt;sec_inference_match_ancestors_and_samples&gt;`</span>
<span class="sd">    in the documentation for details of ``recombination_rate``, ``mismatch_ratio``</span>
<span class="sd">    and ``path_compression``.</span>

<span class="sd">    :param VariantData variant_data: The :class:`VariantData` instance</span>
<span class="sd">        representing the input data.</span>
<span class="sd">    :param AncestorData ancestor_data: The :class:`AncestorData` instance</span>
<span class="sd">        representing the set of ancestral haplotypes for which we are finding</span>
<span class="sd">        a history.</span>
<span class="sd">    :param recombination_rate: Either a floating point value giving a constant rate</span>
<span class="sd">        :math:`\\rho` per unit length of genome, or an :class:`msprime.RateMap`</span>
<span class="sd">        object. This is used to calculate the probability of recombination between</span>
<span class="sd">        adjacent sites. If ``None``, all matching conflicts are resolved by</span>
<span class="sd">        recombination and all inference sites will have a single mutation</span>
<span class="sd">        (equivalent to mismatch_ratio near zero)</span>
<span class="sd">    :type recombination_rate: float, msprime.RateMap</span>
<span class="sd">    :param float mismatch_ratio: The probability of a mismatch relative to the median</span>
<span class="sd">        probability of recombination between adjacent sites: can only be used if a</span>
<span class="sd">        recombination rate has been set (default: ``None`` treated as 1 if</span>
<span class="sd">        ``recombination_rate`` is set).</span>
<span class="sd">    :param bool path_compression: Whether to merge edges that share identical</span>
<span class="sd">        paths (essentially taking advantage of shared recombination breakpoints).</span>
<span class="sd">    :param int num_threads: The number of match worker threads to use. If</span>
<span class="sd">        this is &lt;= 0 then a simpler sequential algorithm is used (default).</span>
<span class="sd">    :return: The ancestors tree sequence representing the inferred history</span>
<span class="sd">        of the set of ancestors.</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">     &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">provenance</span><span class="o">.</span><span class="n">TimingAndMemory</span><span class="p">()</span> <span class="k">as</span> <span class="n">timing</span><span class="p">:</span>
        <span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">,</span> <span class="n">match_ancestors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">variant_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
        <span class="n">ancestor_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>

        <span class="n">matcher</span> <span class="o">=</span> <span class="n">AncestorMatcher</span><span class="p">(</span>
            <span class="n">variant_data</span><span class="p">,</span>
            <span class="n">ancestor_data</span><span class="p">,</span>
            <span class="n">time_units</span><span class="o">=</span><span class="n">time_units</span><span class="p">,</span>
            <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
            <span class="n">recombination</span><span class="o">=</span><span class="n">recombination</span><span class="p">,</span>
            <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
            <span class="n">mismatch</span><span class="o">=</span><span class="n">mismatch</span><span class="p">,</span>
            <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
            <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">likelihood_threshold</span><span class="o">=</span><span class="n">likelihood_threshold</span><span class="p">,</span>
            <span class="n">extended_checks</span><span class="o">=</span><span class="n">extended_checks</span><span class="p">,</span>
            <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
            <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ancestor_grouping</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">group_by_linesweep</span><span class="p">()</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">match_ancestors</span><span class="p">(</span><span class="n">ancestor_grouping</span><span class="p">)</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">ancestor_data</span><span class="o">.</span><span class="n">provenances</span><span class="p">():</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span>
            <span class="n">command</span><span class="o">=</span><span class="s2">&quot;match_ancestors&quot;</span><span class="p">,</span>
            <span class="n">resources</span><span class="o">=</span><span class="n">timing</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">asdict</span><span class="p">(),</span>
            <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
            <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="c1"># TODO: maybe record recombination rate (which could be a RateMap)</span>
        <span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ts</span></div>



<div class="viewcode-block" id="match_ancestors_batch_init">
<a class="viewcode-back" href="../../api.html#tsinfer.match_ancestors_batch_init">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match_ancestors_batch_init</span><span class="p">(</span>
    <span class="n">work_dir</span><span class="p">,</span>
    <span class="n">variant_data_path</span><span class="p">,</span>
    <span class="n">ancestral_state</span><span class="p">,</span>
    <span class="n">ancestor_data_path</span><span class="p">,</span>
    <span class="n">min_work_per_job</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">max_num_partitions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sample_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">site_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mismatch_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">path_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="c1"># Deliberately undocumented parameters below</span>
    <span class="n">recombination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">mismatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
    <span class="n">extended_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">time_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    match_ancestors_batch_init(work_dir, variant_data_path, ancestral_state,</span>
<span class="sd">    ancestor_data_path, min_work_per_job, \\*, max_num_partitions=None,</span>
<span class="sd">    sample_mask=None, site_mask=None, recombination_rate=None, mismatch_ratio=None,</span>
<span class="sd">    path_compression=True)</span>

<span class="sd">    Initialise a batched ancestor matching job. This function is used to</span>
<span class="sd">    prepare a working directory for running a batched ancestor matching job. The</span>
<span class="sd">    job is split into groups of ancestors, with each group further split into</span>
<span class="sd">    partitions of ancestors if necessary. `work_dir` is created and details</span>
<span class="sd">    are written to `metadata.json` in `work_dir`. The job can then be run</span>
<span class="sd">    using :meth:`match_ancestors_batch_groups` and</span>
<span class="sd">    :meth:`match_ancestors_batch_group_partition` then finally</span>
<span class="sd">    :meth:`match_ancestors_batch_group_finalise`. See</span>
<span class="sd">    :ref:`large scale inference&lt;sec_large_scale&gt;` for more details about how these</span>
<span class="sd">    methods work together. See :meth:`match_ancestors` for details on</span>
<span class="sd">    ancestor matching.</span>

<span class="sd">    :param str work_dir: The directory in which to store the working files.</span>
<span class="sd">    :param str variant_data_path: The input dataset in</span>
<span class="sd">        `VCF Zarr &lt;https://github.com/sgkit-dev/vcf-zarr-spec&gt;`_ format.</span>
<span class="sd">        Path to the Zarr dataset saved on disk. See :class:`VariantData`.</span>
<span class="sd">    :param Union(array, str) ancestral_state: A numpy array of strings specifying</span>
<span class="sd">        the ancestral states (alleles) used in inference. This must be the same length</span>
<span class="sd">        as the number of unmasked sites in the dataset. Alternatively, a single string</span>
<span class="sd">        can be provided, giving the name of an array in the input dataset which contains</span>
<span class="sd">        the ancestral states. Unknown ancestral states can be specified using &quot;N&quot;.</span>
<span class="sd">        Any ancestral states which do not match any of the known alleles at that site,</span>
<span class="sd">        will be tallied, and a warning issued summarizing the unknown ancestral states.</span>
<span class="sd">    :param str ancestor_data_path: The path to the file containing the ancestors</span>
<span class="sd">        generated by :meth:`generate_ancestors`.</span>
<span class="sd">    :param int min_work_per_job: The minimum amount of work (as a count of genotypes) to</span>
<span class="sd">        allocate to a single parallel job. If the amount of work in a group of ancestors</span>
<span class="sd">        exceeds this level it will be broken up into parallel partitions, subject to</span>
<span class="sd">        the constraint of `max_num_partitions`.</span>
<span class="sd">    :param int max_num_partitions: The maximum number of partitions to split a group of</span>
<span class="sd">        ancestors into. Useful for limiting the number of jobs in a workflow to</span>
<span class="sd">        avoid job overhead. Defaults to 1000.</span>
<span class="sd">    :param Union(array, str) sample_mask: A numpy array of booleans specifying which</span>
<span class="sd">        samples to mask out (exclude) from the dataset. Alternatively, a string</span>
<span class="sd">        can be provided, giving the name of an array in the input dataset which contains</span>
<span class="sd">        the sample mask. If ``None`` (default), all samples are included.</span>
<span class="sd">    :param Union(array, str) site_mask: A numpy array of booleans specifying which</span>
<span class="sd">        sites to mask out (exclude) from the dataset. Alternatively, a string</span>
<span class="sd">        can be provided, giving the name of an array in the input dataset which contains</span>
<span class="sd">        the site mask. If ``None`` (default), all sites are included.</span>
<span class="sd">    :param int sequence_length: An integer specifying the resulting `sequence_length`</span>
<span class="sd">        attribute of the output tree sequence. If not specified the `contig_length`</span>
<span class="sd">        attribute from the undelying zarr store for the contig of the selected variants.</span>
<span class="sd">        is used. If that is not present then the maximum position plus one of the used</span>
<span class="sd">        variants is used.</span>
<span class="sd">    :param recombination_rate: Either a floating point value giving a constant rate</span>
<span class="sd">        :math:`\\rho` per unit length of genome, or an :class:`msprime.RateMap`</span>
<span class="sd">        object. This is used to calculate the probability of recombination between</span>
<span class="sd">        adjacent sites. If ``None``, all matching conflicts are resolved by</span>
<span class="sd">        recombination and all inference sites will have a single mutation</span>
<span class="sd">        (equivalent to mismatch_ratio near zero)</span>
<span class="sd">    :type recombination_rate: float, msprime.RateMap</span>
<span class="sd">    :param float mismatch_ratio: The probability of a mismatch relative to the median</span>
<span class="sd">        probability of recombination between adjacent sites: can only be used if a</span>
<span class="sd">        recombination rate has been set (default: ``None`` treated as 1 if</span>
<span class="sd">        ``recombination_rate`` is set).</span>
<span class="sd">    :param bool path_compression: Whether to merge edges that share identical</span>
<span class="sd">        paths (essentially taking advantage of shared recombination breakpoints).</span>
<span class="sd">    :return: A dictionary of the job metadata, as written to `metadata.json`</span>
<span class="sd">        in `work_dir`. `ancestor_grouping` in this dict contains the grouping</span>
<span class="sd">        of ancestors into groups and should be used to guide calling</span>
<span class="sd">        :meth:`match_ancestors_batch_groups` and</span>
<span class="sd">        :meth:`match_ancestors_batch_group_partition`.</span>
<span class="sd">    :rtype: dict</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">max_num_partitions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_num_partitions</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time_</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

    <span class="n">work_dir</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">work_dir</span><span class="p">)</span>
    <span class="n">work_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">ancestors</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">AncestorData</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">ancestor_data_path</span><span class="p">)</span>
    <span class="n">variant_data</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">VariantData</span><span class="p">(</span>
        <span class="n">variant_data_path</span><span class="p">,</span>
        <span class="n">ancestral_state</span><span class="o">=</span><span class="n">ancestral_state</span><span class="p">,</span>
        <span class="n">sample_mask</span><span class="o">=</span><span class="n">sample_mask</span><span class="p">,</span>
        <span class="n">site_mask</span><span class="o">=</span><span class="n">site_mask</span><span class="p">,</span>
        <span class="n">sequence_length</span><span class="o">=</span><span class="n">sequence_length</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ancestors</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
    <span class="n">variant_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>

    <span class="n">matcher</span> <span class="o">=</span> <span class="n">AncestorMatcher</span><span class="p">(</span>
        <span class="n">variant_data</span><span class="p">,</span>
        <span class="n">ancestors</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ancestor_grouping</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ancestor_lengths</span> <span class="o">=</span> <span class="n">ancestors</span><span class="o">.</span><span class="n">ancestors_length</span>
    <span class="k">for</span> <span class="n">group_index</span><span class="p">,</span> <span class="n">group_ancestors</span> <span class="ow">in</span> <span class="n">matcher</span><span class="o">.</span><span class="n">group_by_linesweep</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># Make ancestor_ids JSON serialisable</span>
        <span class="n">group_ancestors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">group_ancestors</span><span class="p">))</span>
        <span class="c1"># The first group is trivial so never partition</span>
        <span class="k">if</span> <span class="n">group_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">partitions</span> <span class="o">=</span> <span class="p">[</span><span class="n">group_ancestors</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">total_work</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ancestor_lengths</span><span class="p">[</span><span class="n">ancestor</span><span class="p">]</span> <span class="k">for</span> <span class="n">ancestor</span> <span class="ow">in</span> <span class="n">group_ancestors</span><span class="p">)</span>
            <span class="n">partition_count</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">total_work</span> <span class="o">/</span> <span class="n">min_work_per_job</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">partition_count</span> <span class="o">&gt;</span> <span class="n">max_num_partitions</span><span class="p">:</span>
                <span class="n">partition_count</span> <span class="o">=</span> <span class="n">max_num_partitions</span>

            <span class="c1"># Partition into roughly equal sized bins (by work)</span>
            <span class="n">sorted_ancestors</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">group_ancestors</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ancestor_lengths</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="c1"># Use greedy bin packing - place each ancestor in the bin with</span>
            <span class="c1"># lowest total length</span>
            <span class="n">heap</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">partition_count</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">ancestor</span> <span class="ow">in</span> <span class="n">sorted_ancestors</span><span class="p">:</span>
                <span class="n">sum_len</span><span class="p">,</span> <span class="n">partition</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span>
                <span class="n">partition</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ancestor</span><span class="p">)</span>
                <span class="n">sum_len</span> <span class="o">+=</span> <span class="n">ancestor_lengths</span><span class="p">[</span><span class="n">ancestor</span><span class="p">]</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="p">(</span><span class="n">sum_len</span><span class="p">,</span> <span class="n">partition</span><span class="p">))</span>
            <span class="n">partitions</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">sorted</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span> <span class="k">for</span> <span class="n">sum_len</span><span class="p">,</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">heap</span> <span class="k">if</span> <span class="n">sum_len</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">partitions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">group_dir</span> <span class="o">=</span> <span class="n">work_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;group_</span><span class="si">{</span><span class="n">group_index</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">group_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">()</span>

        <span class="n">group</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;ancestors&quot;</span><span class="p">:</span> <span class="n">group_ancestors</span><span class="p">,</span>
            <span class="s2">&quot;partitions&quot;</span><span class="p">:</span> <span class="n">partitions</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">partitions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">ancestor_grouping</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;variant_data_path&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">variant_data_path</span><span class="p">),</span>
        <span class="s2">&quot;ancestral_state&quot;</span><span class="p">:</span> <span class="n">ancestral_state</span><span class="p">,</span>
        <span class="s2">&quot;ancestor_data_path&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">ancestor_data_path</span><span class="p">),</span>
        <span class="s2">&quot;sample_mask&quot;</span><span class="p">:</span> <span class="n">sample_mask</span><span class="p">,</span>
        <span class="s2">&quot;site_mask&quot;</span><span class="p">:</span> <span class="n">site_mask</span><span class="p">,</span>
        <span class="s2">&quot;recombination_rate&quot;</span><span class="p">:</span> <span class="n">recombination_rate</span><span class="p">,</span>
        <span class="s2">&quot;mismatch_ratio&quot;</span><span class="p">:</span> <span class="n">mismatch_ratio</span><span class="p">,</span>
        <span class="s2">&quot;path_compression&quot;</span><span class="p">:</span> <span class="n">path_compression</span><span class="p">,</span>
        <span class="s2">&quot;recombination&quot;</span><span class="p">:</span> <span class="n">recombination</span><span class="p">,</span>
        <span class="s2">&quot;mismatch&quot;</span><span class="p">:</span> <span class="n">mismatch</span><span class="p">,</span>
        <span class="s2">&quot;precision&quot;</span><span class="p">:</span> <span class="n">precision</span><span class="p">,</span>
        <span class="s2">&quot;engine&quot;</span><span class="p">:</span> <span class="n">engine</span><span class="p">,</span>
        <span class="s2">&quot;extended_checks&quot;</span><span class="p">:</span> <span class="n">extended_checks</span><span class="p">,</span>
        <span class="s2">&quot;time_units&quot;</span><span class="p">:</span> <span class="n">time_units</span><span class="p">,</span>
        <span class="s2">&quot;record_provenance&quot;</span><span class="p">:</span> <span class="n">record_provenance</span><span class="p">,</span>
        <span class="s2">&quot;ancestor_grouping&quot;</span><span class="p">:</span> <span class="n">ancestor_grouping</span><span class="p">,</span>
        <span class="s2">&quot;start_time&quot;</span><span class="p">:</span> <span class="n">start_time</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">metadata_path</span> <span class="o">=</span> <span class="n">work_dir</span> <span class="o">/</span> <span class="s2">&quot;metadata.json&quot;</span>
    <span class="n">metadata_path</span><span class="o">.</span><span class="n">write_text</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">metadata</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">metadata</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">initialize_ancestor_matcher</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">ancestors_ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">variant_data</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">VariantData</span><span class="p">(</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;variant_data_path&quot;</span><span class="p">],</span>
        <span class="n">ancestral_state</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ancestral_state&quot;</span><span class="p">],</span>
        <span class="n">sample_mask</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;sample_mask&quot;</span><span class="p">],</span>
        <span class="n">site_mask</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;site_mask&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="n">ancestors</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">AncestorData</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ancestor_data_path&quot;</span><span class="p">])</span>
    <span class="n">variant_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
    <span class="n">ancestors</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">AncestorMatcher</span><span class="p">(</span>
        <span class="n">variant_data</span><span class="p">,</span>
        <span class="n">ancestors</span><span class="p">,</span>
        <span class="n">ancestors_ts</span><span class="o">=</span><span class="n">ancestors_ts</span><span class="p">,</span>
        <span class="n">time_units</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;time_units&quot;</span><span class="p">],</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;recombination_rate&quot;</span><span class="p">],</span>
        <span class="n">recombination</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;recombination&quot;</span><span class="p">],</span>
        <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;mismatch_ratio&quot;</span><span class="p">],</span>
        <span class="n">mismatch</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;mismatch&quot;</span><span class="p">],</span>
        <span class="n">path_compression</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;path_compression&quot;</span><span class="p">],</span>
        <span class="n">precision</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;precision&quot;</span><span class="p">],</span>
        <span class="n">extended_checks</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;extended_checks&quot;</span><span class="p">],</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;engine&quot;</span><span class="p">],</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span>


<div class="viewcode-block" id="match_ancestors_batch_groups">
<a class="viewcode-back" href="../../api.html#tsinfer.match_ancestors_batch_groups">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match_ancestors_batch_groups</span><span class="p">(</span>
    <span class="n">work_dir</span><span class="p">,</span> <span class="n">group_index_start</span><span class="p">,</span> <span class="n">group_index_end</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    match_ancestors_batch_groups(work_dir, group_index_start,</span>
<span class="sd">    group_index_end, num_threads=0)</span>

<span class="sd">    Match a set of ancestor groups from `group_index_start`(inclusive) to</span>
<span class="sd">    `group_index_end`(exclusive) in a batched ancestor matching job. See</span>
<span class="sd">    :ref:`large scale inference&lt;sec_large_scale&gt;` for more details.</span>

<span class="sd">    A tree sequence file for `group_index_start - 1` must exist in `work_dir`, unless</span>
<span class="sd">    `group_index_start` is 0. After matching the tree sequence for `group_index_end - 1`</span>
<span class="sd">    is written to `work_dir`.</span>

<span class="sd">    :param str work_dir: The working directory for the batch job, as written by</span>
<span class="sd">        :meth:`match_ancestors_batch_init`.</span>
<span class="sd">    :param int group_index_start: The first group index to match.</span>
<span class="sd">    :param int group_index_end: The group index to stop matching at.</span>
<span class="sd">    :param int num_threads: The number of worker threads to use. If this is &lt;= 1 then</span>
<span class="sd">        match sequentially.</span>
<span class="sd">    :return: The tree sequence representing the inferred ancestors for the last group</span>
<span class="sd">        matched</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="s2">&quot;metadata.json&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">metadata_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">group_index_start</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ancestor_grouping&quot;</span><span class="p">])</span> <span class="ow">or</span> <span class="n">group_index_start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Group </span><span class="si">{</span><span class="n">group_index_start</span><span class="si">}</span><span class="s2"> is out of range&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">group_index_end</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ancestor_grouping&quot;</span><span class="p">])</span> <span class="ow">or</span> <span class="n">group_index_end</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Group </span><span class="si">{</span><span class="n">group_index_end</span><span class="si">}</span><span class="s2"> is out of range&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">group_index_end</span> <span class="o">&lt;=</span> <span class="n">group_index_start</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Group index end must be greater than start&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">provenance</span><span class="o">.</span><span class="n">TimingAndMemory</span><span class="p">()</span> <span class="k">as</span> <span class="n">timing</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">group_index_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ancestors_ts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ancestors_ts</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;ancestors_</span><span class="si">{</span><span class="n">group_index_start</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">.trees&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">matcher</span> <span class="o">=</span> <span class="n">initialize_ancestor_matcher</span><span class="p">(</span>
            <span class="n">metadata</span><span class="p">,</span> <span class="n">ancestors_ts</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span>
        <span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">match_ancestors</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="n">group_index</span><span class="p">:</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ancestor_grouping&quot;</span><span class="p">][</span><span class="n">group_index</span><span class="p">][</span><span class="s2">&quot;ancestors&quot;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">group_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">group_index_start</span><span class="p">,</span> <span class="n">group_index_end</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;ancestors_</span><span class="si">{</span><span class="n">group_index_end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">.trees&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dumping to </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s2">&quot;.resources&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">timing</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">asdict</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">ts</span></div>



<div class="viewcode-block" id="match_ancestors_batch_group_partition">
<a class="viewcode-back" href="../../api.html#tsinfer.match_ancestors_batch_group_partition">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match_ancestors_batch_group_partition</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="n">group_index</span><span class="p">,</span> <span class="n">partition_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    match_ancestors_batch_group_partition(work_dir, group_index, partition_index)</span>

<span class="sd">    Match a single partition of ancestors from a group in a batched ancestor matching</span>
<span class="sd">    job. See :ref:`large scale inference&lt;sec_large_scale&gt;` for more details. The</span>
<span class="sd">    tree sequence for the group before must exist in `work_dir`. After matching the</span>
<span class="sd">    results for the partition are written to `work_dir`. Once all partitions for a</span>
<span class="sd">    group have been matched, the group can be finalised using</span>
<span class="sd">    :meth:`match_ancestors_batch_group_finalise`. The number of partitions in a</span>
<span class="sd">    group is recorded in `metadata.json` in the work dir under the</span>
<span class="sd">    `ancestor_grouping` key. This method uses a single thread.</span>

<span class="sd">    :param str work_dir: The working directory for the batch job, as written by</span>
<span class="sd">        :meth:`match_ancestors_batch_init`.</span>
<span class="sd">    :param int group_index: The group index that contains the partition to match.</span>
<span class="sd">    :param int partition_index: The partition index to match. Must be less than the</span>
<span class="sd">        number of partitions in the batch job metadata for this group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time_</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">metadata_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="s2">&quot;metadata.json&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">metadata_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">group</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ancestor_grouping&quot;</span><span class="p">][</span><span class="n">group_index</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;partitions&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Group </span><span class="si">{</span><span class="n">group_index</span><span class="si">}</span><span class="s2"> has no partitions&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">partition_index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s2">&quot;partitions&quot;</span><span class="p">])</span> <span class="ow">or</span> <span class="n">partition_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Partition </span><span class="si">{</span><span class="n">partition_index</span><span class="si">}</span><span class="s2"> is out of range&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">provenance</span><span class="o">.</span><span class="n">TimingAndMemory</span><span class="p">()</span> <span class="k">as</span> <span class="n">timing</span><span class="p">:</span>
        <span class="n">ancestors_ts</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;ancestors_</span><span class="si">{</span><span class="n">group_index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">.trees&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">matcher</span> <span class="o">=</span> <span class="n">initialize_ancestor_matcher</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">ancestors_ts</span><span class="p">)</span>
        <span class="n">ancestors_to_match</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;partitions&quot;</span><span class="p">][</span><span class="n">partition_index</span><span class="p">]</span>

        <span class="n">results</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">match_partition</span><span class="p">(</span>
            <span class="n">ancestors_to_match</span><span class="p">,</span> <span class="n">group_index</span><span class="p">,</span> <span class="n">partition_index</span>
        <span class="p">)</span>
    <span class="n">partition_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">work_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;group_</span><span class="si">{</span><span class="n">group_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;partition_</span><span class="si">{</span><span class="n">partition_index</span><span class="si">}</span><span class="s2">.pkl&quot;</span>
    <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dumping to </span><span class="si">{</span><span class="n">partition_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">partition_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">((</span><span class="n">start_time</span><span class="p">,</span> <span class="n">timing</span><span class="o">.</span><span class="n">metrics</span><span class="p">,</span> <span class="n">ancestors_to_match</span><span class="p">,</span> <span class="n">results</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span></div>



<div class="viewcode-block" id="match_ancestors_batch_group_finalise">
<a class="viewcode-back" href="../../api.html#tsinfer.match_ancestors_batch_group_finalise">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match_ancestors_batch_group_finalise</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="n">group_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    match_ancestors_batch_group_finalise(work_dir, group_index)</span>

<span class="sd">    Finalise a group of partitioned ancestors in a batched ancestor matching job. See</span>
<span class="sd">    :ref:`large scale inference&lt;sec_large_scale&gt;` for more details. The tree sequence</span>
<span class="sd">    for the group before must exist in `work_dir`, along with the results for all</span>
<span class="sd">    partitions in this group. Writes the tree sequence for the group to `work_dir`.</span>

<span class="sd">    :param str work_dir: The working directory for the batch job, as written by</span>
<span class="sd">        :meth:`match_ancestors_batch_init`.</span>
<span class="sd">    :param int group_index: The group index to finalise.</span>
<span class="sd">    :return: The tree sequence representing the inferred ancestors for the group</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">provenance</span><span class="o">.</span><span class="n">TimingAndMemory</span><span class="p">()</span> <span class="k">as</span> <span class="n">timing</span><span class="p">:</span>
        <span class="n">metadata_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="s2">&quot;metadata.json&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">metadata_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ancestor_grouping&quot;</span><span class="p">][</span><span class="n">group_index</span><span class="p">]</span>
        <span class="n">ancestors_ts</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;ancestors_</span><span class="si">{</span><span class="n">group_index</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">.trees&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">matcher</span> <span class="o">=</span> <span class="n">initialize_ancestor_matcher</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">ancestors_ts</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Finalising group </span><span class="si">{</span><span class="n">group_index</span><span class="si">}</span><span class="s2">, loading &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s1">&#39;partitions&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2"> partitions&quot;</span>
        <span class="p">)</span>
        <span class="n">start_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">timings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">partition_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="s2">&quot;partitions&quot;</span><span class="p">])):</span>
            <span class="n">partition_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">work_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;group_</span><span class="si">{</span><span class="n">group_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;partition_</span><span class="si">{</span><span class="n">partition_index</span><span class="si">}</span><span class="s2">.pkl&quot;</span>
            <span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">partition_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">start_time</span><span class="p">,</span> <span class="n">part_timing</span><span class="p">,</span> <span class="n">ancestors</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="n">start_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_time</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ancestor</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ancestors</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">ancestor</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
                <span class="n">timings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part_timing</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">finalise_group</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">group_index</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;ancestors_</span><span class="si">{</span><span class="n">group_index</span><span class="si">}</span><span class="s2">.trees&quot;</span><span class="p">)</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="n">combined_metrics</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">ResourceMetrics</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">timings</span> <span class="o">+</span> <span class="p">[</span><span class="n">timing</span><span class="o">.</span><span class="n">metrics</span><span class="p">])</span>
    <span class="n">combined_metrics</span><span class="o">.</span><span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time_</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">start_times</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="s2">&quot;.resources&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">combined_metrics</span><span class="o">.</span><span class="n">asdict</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">ts</span></div>



<div class="viewcode-block" id="match_ancestors_batch_finalise">
<a class="viewcode-back" href="../../api.html#tsinfer.match_ancestors_batch_finalise">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match_ancestors_batch_finalise</span><span class="p">(</span><span class="n">work_dir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    match_ancestors_batch_finalise(work_dir)</span>

<span class="sd">    Finalise a batched ancestor matching job. This method should be called after all</span>
<span class="sd">    groups have been matched, either by :meth:`match_ancestors_batch_groups` or</span>
<span class="sd">    :meth:`match_ancestors_batch_group_finalise`. Returns the final ancestors</span>
<span class="sd">    tree sequence for the batch job. `work_dir` is retained and not deleted.</span>

<span class="sd">    :param str work_dir: The working directory for the batch job, as written by</span>
<span class="sd">        :meth:`match_ancestors_batch_init`.</span>
<span class="sd">    :return: The tree sequence representing the inferred ancestors for the batch job</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">provenance</span><span class="o">.</span><span class="n">TimingAndMemory</span><span class="p">()</span> <span class="k">as</span> <span class="n">timing</span><span class="p">:</span>
        <span class="n">metadata_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="s2">&quot;metadata.json&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">metadata_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">ancestor_data</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">AncestorData</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ancestor_data_path&quot;</span><span class="p">])</span>
        <span class="n">final_group</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;ancestor_grouping&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;ancestors_</span><span class="si">{</span><span class="n">final_group</span><span class="si">}</span><span class="s2">.trees&quot;</span><span class="p">))</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">ancestor_data</span><span class="o">.</span><span class="n">provenances</span><span class="p">():</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;record_provenance&quot;</span><span class="p">]:</span>
        <span class="c1"># Find all the .resources files and combine them</span>
        <span class="n">resources</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">work_dir</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.resources&quot;</span><span class="p">):</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">file</span><span class="p">))</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                        <span class="n">resource</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">ResourceMetrics</span><span class="p">(</span><span class="o">**</span><span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
                        <span class="n">resources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resource</span><span class="p">)</span>
        <span class="n">combined_resources</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">ResourceMetrics</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span>
            <span class="n">resources</span> <span class="o">+</span> <span class="p">[</span><span class="n">timing</span><span class="o">.</span><span class="n">metrics</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">combined_resources</span><span class="o">.</span><span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time_</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;start_time&quot;</span><span class="p">]</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span>
            <span class="n">command</span><span class="o">=</span><span class="s2">&quot;match_ancestors&quot;</span><span class="p">,</span>
            <span class="n">resources</span><span class="o">=</span><span class="n">combined_resources</span><span class="o">.</span><span class="n">asdict</span><span class="p">(),</span>
            <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;mismatch_ratio&quot;</span><span class="p">],</span>
            <span class="n">path_compression</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;path_compression&quot;</span><span class="p">],</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;precision&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ts</span></div>



<div class="viewcode-block" id="augment_ancestors">
<a class="viewcode-back" href="../../api.html#tsinfer.augment_ancestors">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">augment_ancestors</span><span class="p">(</span>
    <span class="n">variant_data</span><span class="p">,</span>
    <span class="n">ancestors_ts</span><span class="p">,</span>
    <span class="n">indexes</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mismatch_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">path_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="c1"># Deliberately undocumented parameters below</span>
    <span class="n">recombination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">mismatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">extended_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
    <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    augment_ancestors(variant_data, ancestors_ts, indexes, *, recombination_rate=None,\</span>
<span class="sd">        mismatch_ratio=None, path_compression=True, num_threads=0)</span>

<span class="sd">    Runs the sample matching :ref:`algorithm &lt;sec_inference_match_samples&gt;`</span>
<span class="sd">    on the specified :class:`VariantData` instance and ancestors tree sequence,</span>
<span class="sd">    for the specified subset of sample indexes, returning the</span>
<span class="sd">    :class:`tskit.TreeSequence` instance including these samples. This</span>
<span class="sd">    tree sequence can then be used as an ancestors tree sequence for subsequent</span>
<span class="sd">    matching against all samples.  See</span>
<span class="sd">    :ref:`matching ancestors &amp; samples&lt;sec_inference_match_ancestors_and_samples&gt;`</span>
<span class="sd">    in the documentation for details of ``recombination_rate``, ``mismatch_ratio``</span>
<span class="sd">    and ``path_compression``.</span>

<span class="sd">    :param VariantData variant_data: The :class:`VariantData` instance</span>
<span class="sd">        representing the input data.</span>
<span class="sd">    :param tskit.TreeSequence ancestors_ts: The</span>
<span class="sd">        :class:`tskit.TreeSequence` instance representing the inferred</span>
<span class="sd">        history among ancestral ancestral haplotypes.</span>
<span class="sd">    :param array indexes: The sample indexes to insert into the ancestors</span>
<span class="sd">        tree sequence, in increasing order.</span>
<span class="sd">    :param recombination_rate: Either a floating point value giving a constant rate</span>
<span class="sd">        :math:`\\rho` per unit length of genome, or an :class:`msprime.RateMap`</span>
<span class="sd">        object. This is used to calculate the probability of recombination between</span>
<span class="sd">        adjacent sites. If ``None``, all matching conflicts are resolved by</span>
<span class="sd">        recombination and all inference sites will have a single mutation</span>
<span class="sd">        (equivalent to mismatch_ratio near zero)</span>
<span class="sd">    :type recombination_rate: float, msprime.RateMap</span>
<span class="sd">    :param float mismatch_ratio: The probability of a mismatch relative to the median</span>
<span class="sd">        probability of recombination between adjacent sites: can only be used if a</span>
<span class="sd">        recombination rate has been set (default: ``None`` treated as 1 if</span>
<span class="sd">        ``recombination_rate`` is set).</span>
<span class="sd">    :param bool path_compression: Whether to merge edges that share identical</span>
<span class="sd">        paths (essentially taking advantage of shared recombination breakpoints).</span>
<span class="sd">    :param int num_threads: The number of match worker threads to use. If</span>
<span class="sd">        this is &lt;= 0 then a simpler sequential algorithm is used (default).</span>
<span class="sd">    :return: The specified ancestors tree sequence augmented with copying</span>
<span class="sd">        paths for the specified sample.</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variant_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
    <span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">,</span> <span class="n">augment_ancestors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">manager</span> <span class="o">=</span> <span class="n">SampleMatcher</span><span class="p">(</span>
        <span class="n">variant_data</span><span class="p">,</span>
        <span class="n">ancestors_ts</span><span class="p">,</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
        <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
        <span class="n">recombination</span><span class="o">=</span><span class="n">recombination</span><span class="p">,</span>
        <span class="n">mismatch</span><span class="o">=</span><span class="n">mismatch</span><span class="p">,</span>
        <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
        <span class="n">extended_checks</span><span class="o">=</span><span class="n">extended_checks</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
        <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">sample_indexes</span> <span class="o">=</span> <span class="n">check_sample_indexes</span><span class="p">(</span><span class="n">variant_data</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>
    <span class="n">sample_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">variant_data</span><span class="o">.</span><span class="n">individuals_time</span><span class="o">.</span><span class="n">dtype</span>
    <span class="p">)</span>
    <span class="n">manager</span><span class="o">.</span><span class="n">match_samples</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">,</span> <span class="n">sample_times</span><span class="p">)</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">get_augmented_ancestors_tree_sequence</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span>
            <span class="n">command</span><span class="o">=</span><span class="s2">&quot;augment_ancestors&quot;</span><span class="p">,</span>
            <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
            <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ts</span></div>



<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SampleBatchWorkDescriptor</span><span class="p">:</span>
    <span class="n">variant_data_path</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">ancestral_state</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">sample_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">site_mask</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">sites_time</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">individuals_time</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">individuals_location</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">individuals_population</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">individuals_flags</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">sequence_length</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">ancestor_ts_path</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">recombination_rate</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">mismatch_ratio</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">path_compression</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">recombination</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">mismatch</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">precision</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">engine</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">extended_checks</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">post_process</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">force_sample_times</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">overlay_non_inference_sites</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">record_provenance</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">sample_indexes</span><span class="p">:</span> <span class="nb">list</span>
    <span class="n">sample_times</span><span class="p">:</span> <span class="nb">list</span>
    <span class="n">num_samples_per_partition</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">num_partitions</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">start_time</span><span class="p">:</span> <span class="nb">float</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">common_params</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;recombination_rate&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">recombination_rate</span><span class="p">,</span>
            <span class="s2">&quot;mismatch_ratio&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mismatch_ratio</span><span class="p">,</span>
            <span class="s2">&quot;path_compression&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">path_compression</span><span class="p">,</span>
            <span class="s2">&quot;recombination&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">recombination</span><span class="p">,</span>
            <span class="s2">&quot;mismatch&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">,</span>
            <span class="s2">&quot;precision&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span>
            <span class="s2">&quot;engine&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">engine</span><span class="p">,</span>
            <span class="s2">&quot;extended_checks&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">extended_checks</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">numpy_encoder</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">{</span>
                    <span class="s2">&quot;__numpy__&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                    <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="k">return</span> <span class="n">obj</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">dataclasses</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">numpy_encoder</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">numpy_decoder</span><span class="p">(</span><span class="n">dct</span><span class="p">):</span>
            <span class="k">if</span> <span class="s2">&quot;__numpy__&quot;</span> <span class="ow">in</span> <span class="n">dct</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dct</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">dct</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">wd_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">object_hook</span><span class="o">=</span><span class="n">numpy_decoder</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">wd_dict</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">load_variant_data_and_ancestors_ts</span><span class="p">(</span><span class="n">wd</span><span class="p">:</span> <span class="n">SampleBatchWorkDescriptor</span><span class="p">):</span>
    <span class="n">variant_data</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">VariantData</span><span class="p">(</span>
        <span class="n">wd</span><span class="o">.</span><span class="n">variant_data_path</span><span class="p">,</span>
        <span class="n">wd</span><span class="o">.</span><span class="n">ancestral_state</span><span class="p">,</span>
        <span class="n">sample_mask</span><span class="o">=</span><span class="n">wd</span><span class="o">.</span><span class="n">sample_mask</span><span class="p">,</span>
        <span class="n">site_mask</span><span class="o">=</span><span class="n">wd</span><span class="o">.</span><span class="n">site_mask</span><span class="p">,</span>
        <span class="n">sites_time</span><span class="o">=</span><span class="n">wd</span><span class="o">.</span><span class="n">sites_time</span><span class="p">,</span>
        <span class="n">individuals_time</span><span class="o">=</span><span class="n">wd</span><span class="o">.</span><span class="n">individuals_time</span><span class="p">,</span>
        <span class="n">individuals_location</span><span class="o">=</span><span class="n">wd</span><span class="o">.</span><span class="n">individuals_location</span><span class="p">,</span>
        <span class="n">individuals_population</span><span class="o">=</span><span class="n">wd</span><span class="o">.</span><span class="n">individuals_population</span><span class="p">,</span>
        <span class="n">individuals_flags</span><span class="o">=</span><span class="n">wd</span><span class="o">.</span><span class="n">individuals_flags</span><span class="p">,</span>
        <span class="n">sequence_length</span><span class="o">=</span><span class="n">wd</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">variant_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
    <span class="n">ancestor_ts</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">wd</span><span class="o">.</span><span class="n">ancestor_ts_path</span><span class="p">)</span>
    <span class="n">matcher</span> <span class="o">=</span> <span class="n">SampleMatcher</span><span class="p">(</span>
        <span class="n">variant_data</span><span class="p">,</span>
        <span class="n">ancestor_ts</span><span class="p">,</span>
        <span class="o">**</span><span class="n">wd</span><span class="o">.</span><span class="n">common_params</span><span class="p">(),</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">variant_data</span><span class="p">,</span> <span class="n">ancestor_ts</span><span class="p">,</span> <span class="n">matcher</span>


<div class="viewcode-block" id="match_samples_batch_init">
<a class="viewcode-back" href="../../api.html#tsinfer.match_samples_batch_init">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match_samples_batch_init</span><span class="p">(</span>
    <span class="n">work_dir</span><span class="p">,</span>
    <span class="n">variant_data_path</span><span class="p">,</span>
    <span class="n">ancestral_state</span><span class="p">,</span>
    <span class="n">ancestor_ts_path</span><span class="p">,</span>
    <span class="n">min_work_per_job</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">sample_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">site_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sites_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">individuals_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">individuals_location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">individuals_population</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">individuals_flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mismatch_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">path_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">post_process</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">force_sample_times</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">overlay_non_inference_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="c1"># Deliberately undocumented parameters below</span>
    <span class="n">recombination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">mismatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">extended_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    match_samples_batch_init(work_dir, variant_data_path, ancestral_state,</span>
<span class="sd">    ancestor_ts_path, min_work_per_job, \\*,</span>
<span class="sd">    sample_mask=None, site_mask=None, recombination_rate=None, mismatch_ratio=None,</span>
<span class="sd">    path_compression=True, indexes=None, post_process=None, force_sample_times=False)</span>

<span class="sd">    Initialise a batched sample matching job. Creates `work_dir` and writes job</span>
<span class="sd">    details to `metadata.json`. The job can then be run using parallel calls to</span>
<span class="sd">    :meth:`match_samples_batch_partition` and once those are complete</span>
<span class="sd">    finally :meth:`match_samples_batch_finalise`.</span>

<span class="sd">    The `num_partitions` key in the metadata dict contains the number of partitions</span>
<span class="sd">    that need to be processed.</span>

<span class="sd">    :param str work_dir: The directory in which to store the working files.</span>
<span class="sd">    :param str variant_data_path: The input dataset in</span>
<span class="sd">        `VCF Zarr &lt;https://github.com/sgkit-dev/vcf-zarr-spec&gt;`_ format.</span>
<span class="sd">        Path to the Zarr dataset saved on disk. See :class:`VariantData`.</span>
<span class="sd">    :param Union(array, str) ancestral_state: A numpy array of strings specifying</span>
<span class="sd">        the ancestral states (alleles) used in inference. This must be the same</span>
<span class="sd">        length as the number of unmasked sites in the dataset. Alternatively, a</span>
<span class="sd">        single string can be provided, giving the name of an array in the input</span>
<span class="sd">        dataset which contains the ancestral states. Unknown ancestral states can</span>
<span class="sd">        be specified using &quot;N&quot;. Any ancestral states which do not match any of the</span>
<span class="sd">        known alleles at that site, will be tallied, and a warning issued</span>
<span class="sd">        summarizing the unknown ancestral states.</span>
<span class="sd">    :param str ancestor_ts_path: The path to the tree sequence file containing the</span>
<span class="sd">        ancestors generated by :meth:`match_ancestors_batch_finalise`, or</span>
<span class="sd">        :meth:`match_ancestors`.</span>
<span class="sd">    :param int min_work_per_job: The minimum amount of work (as a count of</span>
<span class="sd">        genotypes) to allocate to a single parallel job. If the amount of work in</span>
<span class="sd">        a group of samples exceeds this level it will be broken up into parallel</span>
<span class="sd">        partitions, subject to the constraint of `max_num_partitions`.</span>
<span class="sd">    :param Union(array, str) sample_mask: A numpy array of booleans specifying</span>
<span class="sd">        which samples to mask out (exclude) from the dataset. Alternatively, a</span>
<span class="sd">        string can be provided, giving the name of an array in the input dataset</span>
<span class="sd">        which contains the sample mask. If ``None`` (default), all samples are</span>
<span class="sd">        included.</span>
<span class="sd">    :param Union(array, str) site_mask: A numpy array of booleans specifying which</span>
<span class="sd">        sites to mask out (exclude) from the dataset. Alternatively, a string can</span>
<span class="sd">        be provided, giving the name of an array in the input dataset which</span>
<span class="sd">        contains the site mask. If ``None`` (default), all sites are included.</span>
<span class="sd">    :param Union(array, str) sites_time: A numpy array of floats specifying the relative</span>
<span class="sd">        time of occurrence of the mutation to the derived state at each site. This must</span>
<span class="sd">        be of the same length as the number of unmasked sites. Alternatively, a</span>
<span class="sd">        string can be provided, giving the name of an array in the input dataset</span>
<span class="sd">        which contains the site times. If ``None`` (default), the frequency of the</span>
<span class="sd">        derived allele is used as a proxy for the time of occurrence: this is usually a</span>
<span class="sd">        reasonable approximation to the relative order of ancestors used for inference.</span>
<span class="sd">        Time values are ignored for sites not used in inference, such as singletons,</span>
<span class="sd">        sites with more than two alleles, or sites with an unknown ancestral state.</span>
<span class="sd">    :param Union(array, str) individuals_time: A numpy array of floats specifying</span>
<span class="sd">        the time of each individual in the dataset. This must be the same length</span>
<span class="sd">        as the number of unmasked individuals. Alternatively, a string can be provided,</span>
<span class="sd">        giving the name of an array in the input dataset which contains the individual</span>
<span class="sd">        times. If ``None`` (default), individuals are assumed to have</span>
<span class="sd">        ``tskit.UNKNOWN_TIME``.</span>
<span class="sd">    :param Union(array, str) individuals_location: A numpy array specifying</span>
<span class="sd">        the location of each individual in the dataset. This must be the same length</span>
<span class="sd">        as the number of unmasked individuals. Alternatively, a string can be provided,</span>
<span class="sd">        giving the name of an array in the input dataset which contains the individual</span>
<span class="sd">        locations. If ``None`` (default), individuals are assumed to have empty</span>
<span class="sd">        location arrays.</span>
<span class="sd">    :param Union(array, str) individuals_population: A numpy array of integers specifying</span>
<span class="sd">        the population of each individual in the dataset. This must be the same length</span>
<span class="sd">        as the number of unmasked individuals. Alternatively, a string can be provided,</span>
<span class="sd">        giving the name of an array in the input dataset which contains the individual</span>
<span class="sd">        populations. If ``None`` (default), individuals are assumed to have</span>
<span class="sd">        ``tskit.NULL`` as their population.</span>
<span class="sd">    :param Union(array, str) individuals_flags: A numpy array of integers specifying</span>
<span class="sd">        the flags of each individual in the dataset. This must be the same length</span>
<span class="sd">        as the number of unmasked individuals. Alternatively, a string can be provided,</span>
<span class="sd">        giving the name of an array in the input dataset which contains the individual</span>
<span class="sd">        flags. If ``None`` (default), individuals are assumed to have flags set to 0.</span>
<span class="sd">    :param int sequence_length: An integer specifying the resulting `sequence_length`</span>
<span class="sd">        attribute of the output tree sequence. If not specified the `contig_length`</span>
<span class="sd">        attribute from the undelying zarr store for the contig of the selected variants.</span>
<span class="sd">        is used. If that is not present then the maximum position plus one of the used</span>
<span class="sd">        variants is used.</span>
<span class="sd">    :param recombination_rate: Either a floating point value giving a constant</span>
<span class="sd">        rate :math:`\\rho` per unit length of genome, or an</span>
<span class="sd">        :class:`msprime.RateMap` object. This is used to calculate the</span>
<span class="sd">        probability of recombination between adjacent sites. If ``None``, all</span>
<span class="sd">        matching conflicts are resolved by recombination and all inference sites</span>
<span class="sd">        will have a single mutation (equivalent to mismatch_ratio near zero)</span>
<span class="sd">    :type recombination_rate: float, msprime.RateMap</span>
<span class="sd">    :param float mismatch_ratio: The probability of a mismatch relative to the</span>
<span class="sd">        median probability of recombination between adjacent sites: can only be</span>
<span class="sd">        used if a recombination rate has been set (default: ``None`` treated as 1</span>
<span class="sd">        if ``recombination_rate`` is set).</span>
<span class="sd">    :param bool path_compression: Whether to merge edges that share identical paths</span>
<span class="sd">        (essentially taking advantage of shared recombination breakpoints).</span>
<span class="sd">    :param indexes: The sample indexes to match. If ``None`` (default), all</span>
<span class="sd">        samples are matched.</span>
<span class="sd">    :type indexes: arraylike</span>
<span class="sd">    :param bool post_process: Whether to run the :func:`post_process` method on</span>
<span class="sd">        the the tree sequence which, among other things, removes ancestral</span>
<span class="sd">        material that does not end up in the current samples (if not specified,</span>
<span class="sd">        defaults to ``True``)</span>
<span class="sd">    :param bool force_sample_times: After matching, should an attempt be made to</span>
<span class="sd">        adjust the time of &quot;historical samples&quot; (those associated with an</span>
<span class="sd">        individual having a non-zero time) such that the sample nodes in the tree</span>
<span class="sd">        sequence appear at the time of the individual with which they are</span>
<span class="sd">        associated.</span>
<span class="sd">    :param bool overlay_non_inference_sites: If True, sites that were included in</span>
<span class="sd">        the selected sites, but were not used for inference, will be added to the</span>
<span class="sd">        tree sequence by mapping their mutations over the inferred topology.</span>
<span class="sd">        Defaults to True.</span>
<span class="sd">    :return: A dictionary of the job metadata, as written to `metadata.json` in</span>
<span class="sd">        `work_dir`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert working_dir to pathlib.Path</span>
    <span class="n">work_dir</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">work_dir</span><span class="p">)</span>

    <span class="c1"># Create work dir</span>
    <span class="n">work_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">wd</span> <span class="o">=</span> <span class="n">SampleBatchWorkDescriptor</span><span class="p">(</span>
        <span class="n">variant_data_path</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">variant_data_path</span><span class="p">),</span>
        <span class="n">ancestral_state</span><span class="o">=</span><span class="n">ancestral_state</span><span class="p">,</span>
        <span class="n">sample_mask</span><span class="o">=</span><span class="n">sample_mask</span><span class="p">,</span>
        <span class="n">site_mask</span><span class="o">=</span><span class="n">site_mask</span><span class="p">,</span>
        <span class="n">sites_time</span><span class="o">=</span><span class="n">sites_time</span><span class="p">,</span>
        <span class="n">individuals_time</span><span class="o">=</span><span class="n">individuals_time</span><span class="p">,</span>
        <span class="n">individuals_location</span><span class="o">=</span><span class="n">individuals_location</span><span class="p">,</span>
        <span class="n">individuals_population</span><span class="o">=</span><span class="n">individuals_population</span><span class="p">,</span>
        <span class="n">individuals_flags</span><span class="o">=</span><span class="n">individuals_flags</span><span class="p">,</span>
        <span class="n">sequence_length</span><span class="o">=</span><span class="n">sequence_length</span><span class="p">,</span>
        <span class="n">ancestor_ts_path</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">ancestor_ts_path</span><span class="p">),</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
        <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
        <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
        <span class="n">recombination</span><span class="o">=</span><span class="n">recombination</span><span class="p">,</span>
        <span class="n">mismatch</span><span class="o">=</span><span class="n">mismatch</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
        <span class="n">extended_checks</span><span class="o">=</span><span class="n">extended_checks</span><span class="p">,</span>
        <span class="n">post_process</span><span class="o">=</span><span class="n">post_process</span><span class="p">,</span>
        <span class="n">force_sample_times</span><span class="o">=</span><span class="n">force_sample_times</span><span class="p">,</span>
        <span class="n">overlay_non_inference_sites</span><span class="o">=</span><span class="n">overlay_non_inference_sites</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
        <span class="n">sample_indexes</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">sample_times</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">num_samples_per_partition</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">num_partitions</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">start_time</span><span class="o">=</span><span class="n">time_</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">(),</span>
    <span class="p">)</span>
    <span class="n">variant_data</span><span class="p">,</span> <span class="n">ancestor_ts</span><span class="p">,</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">load_variant_data_and_ancestors_ts</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
    <span class="n">sample_indexes</span> <span class="o">=</span> <span class="n">check_sample_indexes</span><span class="p">(</span><span class="n">variant_data</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">sample_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">variant_data</span><span class="o">.</span><span class="n">individuals_time</span><span class="o">.</span><span class="n">dtype</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">force_sample_times</span><span class="p">:</span>
        <span class="n">individuals</span> <span class="o">=</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">samples_individual</span><span class="p">[:][</span><span class="n">sample_indexes</span><span class="p">]</span>
        <span class="c1"># By construction all samples in an sd file have an individual: but check anyway</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">individuals</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">sample_times</span> <span class="o">=</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">individuals_time</span><span class="p">[:][</span><span class="n">individuals</span><span class="p">]</span>

        <span class="c1"># Here we might want to re-order sample_indexes and sample_times</span>
        <span class="c1"># so that any historical ones come first, any we bomb out early if they conflict</span>
        <span class="c1"># but that would mean re-ordering the sample nodes in the final ts, and</span>
        <span class="c1"># we sometimes assume they are in the same order as in the file</span>
    <span class="n">sample_times</span> <span class="o">=</span> <span class="n">sample_times</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="n">wd</span><span class="o">.</span><span class="n">sample_indexes</span> <span class="o">=</span> <span class="n">sample_indexes</span>
    <span class="n">wd</span><span class="o">.</span><span class="n">sample_times</span> <span class="o">=</span> <span class="n">sample_times</span>
    <span class="n">num_samples_per_partition</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
        <span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">min_work_per_job</span> <span class="o">//</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">wd</span><span class="o">.</span><span class="n">num_samples_per_partition</span> <span class="o">=</span> <span class="n">num_samples_per_partition</span>
    <span class="n">wd</span><span class="o">.</span><span class="n">num_partitions</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_samples_per_partition</span><span class="p">)</span>
    <span class="n">wd_path</span> <span class="o">=</span> <span class="n">work_dir</span> <span class="o">/</span> <span class="s2">&quot;metadata.json&quot;</span>
    <span class="n">wd</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">wd_path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wd</span></div>



<div class="viewcode-block" id="match_samples_batch_partition">
<a class="viewcode-back" href="../../api.html#tsinfer.match_samples_batch_partition">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match_samples_batch_partition</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="n">partition_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    match_samples_batch_partition(work_dir, partition_index)</span>

<span class="sd">    Match a single partition of samples in a batched sample matching job. See</span>
<span class="sd">    :ref:`large scale inference&lt;sec_large_scale&gt;` for more details. Match data</span>
<span class="sd">    for the partition is written to `work_dir`. Uses a single thread to perform</span>
<span class="sd">    matching.</span>

<span class="sd">    :param str work_dir: The working directory for the batch job, as written by</span>
<span class="sd">        :meth:`match_samples_batch_init`.</span>
<span class="sd">    :param int partition_index: The partition index to match. Must be less than</span>
<span class="sd">        the number of partitions in the batch job metadata key `num_partitions`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wd_path</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">work_dir</span><span class="p">)</span> <span class="o">/</span> <span class="s2">&quot;metadata.json&quot;</span>
    <span class="n">wd</span> <span class="o">=</span> <span class="n">SampleBatchWorkDescriptor</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">wd_path</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">partition_index</span> <span class="o">&gt;=</span> <span class="n">wd</span><span class="o">.</span><span class="n">num_partitions</span> <span class="ow">or</span> <span class="n">partition_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Partition </span><span class="si">{</span><span class="n">partition_index</span><span class="si">}</span><span class="s2"> is out of range&quot;</span><span class="p">)</span>
    <span class="n">sample_indexes</span> <span class="o">=</span> <span class="n">wd</span><span class="o">.</span><span class="n">sample_indexes</span>
    <span class="n">sample_times</span> <span class="o">=</span> <span class="n">wd</span><span class="o">.</span><span class="n">sample_times</span>
    <span class="n">partition_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span>
        <span class="n">partition_index</span> <span class="o">*</span> <span class="n">wd</span><span class="o">.</span><span class="n">num_samples_per_partition</span><span class="p">,</span>
        <span class="nb">min</span><span class="p">(</span>
            <span class="p">(</span><span class="n">partition_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">wd</span><span class="o">.</span><span class="n">num_samples_per_partition</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">),</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Matching partition </span><span class="si">{</span><span class="n">partition_index</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">partition_slice</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2"> to&quot;</span>
        <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">partition_slice</span><span class="o">.</span><span class="n">stop</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">)</span><span class="si">}</span><span class="s2"> samples&quot;</span>
    <span class="p">)</span>
    <span class="k">with</span> <span class="n">provenance</span><span class="o">.</span><span class="n">TimingAndMemory</span><span class="p">()</span> <span class="k">as</span> <span class="n">timing</span><span class="p">:</span>
        <span class="n">variant_data</span><span class="p">,</span> <span class="n">ancestor_ts</span><span class="p">,</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">load_variant_data_and_ancestors_ts</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">match_samples</span><span class="p">(</span>
            <span class="n">sample_indexes</span><span class="p">,</span> <span class="n">sample_times</span><span class="p">,</span> <span class="n">slice_</span><span class="o">=</span><span class="n">partition_slice</span>
        <span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;partition_</span><span class="si">{</span><span class="n">partition_index</span><span class="si">}</span><span class="s2">.pkl&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dumping to </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">((</span><span class="n">timing</span><span class="o">.</span><span class="n">metrics</span><span class="p">,</span> <span class="n">results</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span></div>



<div class="viewcode-block" id="match_samples_batch_finalise">
<a class="viewcode-back" href="../../api.html#tsinfer.match_samples_batch_finalise">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match_samples_batch_finalise</span><span class="p">(</span><span class="n">work_dir</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    match_samples_batch_finalise(work_dir)</span>

<span class="sd">    Finalise a batched sample matching job. This method should be called after all</span>
<span class="sd">    partitions have been matched by :meth:`match_samples_batch_partition`. Returns</span>
<span class="sd">    the final tree sequence for the batch job. `work_dir` is retained and not deleted.</span>

<span class="sd">    :param str work_dir: The working directory for the batch job, as written by</span>
<span class="sd">        :meth:`match_samples_batch_init`.</span>
<span class="sd">    :return: The tree sequence representing the inferred history of the samples.</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">provenance</span><span class="o">.</span><span class="n">TimingAndMemory</span><span class="p">()</span> <span class="k">as</span> <span class="n">timing</span><span class="p">:</span>
        <span class="n">wd_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="s2">&quot;metadata.json&quot;</span><span class="p">)</span>
        <span class="n">wd</span> <span class="o">=</span> <span class="n">SampleBatchWorkDescriptor</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">wd_path</span><span class="p">)</span>
        <span class="n">variant_data</span><span class="p">,</span> <span class="n">ancestor_ts</span><span class="p">,</span> <span class="n">matcher</span> <span class="o">=</span> <span class="n">load_variant_data_and_ancestors_ts</span><span class="p">(</span><span class="n">wd</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">timings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">partition_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">wd</span><span class="o">.</span><span class="n">num_partitions</span><span class="p">):</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">work_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;partition_</span><span class="si">{</span><span class="n">partition_index</span><span class="si">}</span><span class="s2">.pkl&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">part_timing</span><span class="p">,</span> <span class="n">part_results</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="n">results</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">part_results</span><span class="p">)</span>
                <span class="n">timings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part_timing</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">match_samples</span><span class="p">(</span>
            <span class="n">variant_data</span><span class="p">,</span>
            <span class="n">ancestor_ts</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">wd</span><span class="o">.</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">post_process</span><span class="o">=</span><span class="n">wd</span><span class="o">.</span><span class="n">post_process</span><span class="p">,</span>
            <span class="n">force_sample_times</span><span class="o">=</span><span class="n">wd</span><span class="o">.</span><span class="n">force_sample_times</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">wd</span><span class="o">.</span><span class="n">record_provenance</span><span class="p">,</span>
            <span class="n">overlay_non_inference_sites</span><span class="o">=</span><span class="n">wd</span><span class="o">.</span><span class="n">overlay_non_inference_sites</span><span class="p">,</span>
            <span class="n">results</span><span class="o">=</span><span class="n">results</span><span class="p">,</span>
            <span class="o">**</span><span class="n">wd</span><span class="o">.</span><span class="n">common_params</span><span class="p">(),</span>
        <span class="p">)</span>
    <span class="c1"># Rewrite the last provenance with the correct info</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">wd</span><span class="o">.</span><span class="n">start_time</span>
    <span class="n">combined_metrics</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">ResourceMetrics</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">timings</span> <span class="o">+</span> <span class="p">[</span><span class="n">timing</span><span class="o">.</span><span class="n">metrics</span><span class="p">])</span>
    <span class="n">combined_metrics</span><span class="o">.</span><span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time_</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
    <span class="n">tables</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
    <span class="n">prov</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">record</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">prov</span><span class="o">.</span><span class="n">record</span><span class="p">)</span>
    <span class="n">record</span><span class="p">[</span><span class="s2">&quot;resources&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">combined_metrics</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">prov</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>



<div class="viewcode-block" id="match_samples">
<a class="viewcode-back" href="../../api.html#tsinfer.match_samples">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match_samples</span><span class="p">(</span>
    <span class="n">variant_data</span><span class="p">,</span>
    <span class="n">ancestors_ts</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mismatch_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">path_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">post_process</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">force_sample_times</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">overlay_non_inference_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="c1"># Deliberately undocumented parameters below</span>
    <span class="n">recombination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">mismatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># See :class:`Matcher`</span>
    <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">likelihood_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">extended_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
    <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">simplify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># deprecated</span>
    <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">results</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    match_samples(variant_data, ancestors_ts, *, recombination_rate=None,\</span>
<span class="sd">        mismatch_ratio=None, path_compression=True, post_process=None,\</span>
<span class="sd">        indexes=None, force_sample_times=False, num_threads=0)</span>

<span class="sd">    Runs the sample matching :ref:`algorithm &lt;sec_inference_match_samples&gt;`</span>
<span class="sd">    on the specified :class:`VariantData` instance and ancestors tree sequence,</span>
<span class="sd">    returning the final :class:`tskit.TreeSequence` instance containing</span>
<span class="sd">    the full inferred history for all samples and sites. See</span>
<span class="sd">    :ref:`matching ancestors &amp; samples&lt;sec_inference_match_ancestors_and_samples&gt;`</span>
<span class="sd">    in the documentation for details of ``recombination_rate``, ``mismatch_ratio``</span>
<span class="sd">    and ``path_compression``.</span>

<span class="sd">    :param VariantData variant_data: The :class:`VariantData` instance</span>
<span class="sd">        representing the input data.</span>
<span class="sd">    :param tskit.TreeSequence ancestors_ts: The</span>
<span class="sd">        :class:`tskit.TreeSequence` instance representing the inferred</span>
<span class="sd">        history among ancestral ancestral haplotypes.</span>
<span class="sd">    :param recombination_rate: Either a floating point value giving a constant rate</span>
<span class="sd">        :math:`\\rho` per unit length of genome, or an :class:`msprime.RateMap`</span>
<span class="sd">        object. This is used to calculate the probability of recombination between</span>
<span class="sd">        adjacent sites. If ``None``, all matching conflicts are resolved by</span>
<span class="sd">        recombination and all inference sites will have a single mutation</span>
<span class="sd">        (equivalent to mismatch_ratio near zero)</span>
<span class="sd">    :type recombination_rate: float, msprime.RateMap</span>
<span class="sd">    :param float mismatch_ratio: The probability of a mismatch relative to the median</span>
<span class="sd">        probability of recombination between adjacent sites: can only be used if a</span>
<span class="sd">        recombination rate has been set (default: ``None`` treated as 1 if</span>
<span class="sd">        ``recombination_rate`` is set).</span>
<span class="sd">    :param bool path_compression: Whether to merge edges that share identical</span>
<span class="sd">        paths (essentially taking advantage of shared recombination breakpoints).</span>
<span class="sd">    :param array_like indexes: An array of indexes into the variant_data file of</span>
<span class="sd">        the samples to match (in increasing order) or None for all samples.</span>
<span class="sd">    :param bool post_process: Whether to run the :func:`post_process` method on the</span>
<span class="sd">        the tree sequence which, among other things, removes ancestral material that</span>
<span class="sd">        does not end up in the current samples (if not specified, defaults to ``True``)</span>
<span class="sd">    :param bool force_sample_times: After matching, should an attempt be made to</span>
<span class="sd">        adjust the time of &quot;historical samples&quot; (those associated with an individual</span>
<span class="sd">        having a non-zero time) such that the sample nodes in the tree sequence</span>
<span class="sd">        appear at the time of the individual with which they are associated.</span>
<span class="sd">    :param int num_threads: The number of match worker threads to use. If</span>
<span class="sd">        this is &lt;= 0 then a simpler sequential algorithm is used (default).</span>
<span class="sd">    :param bool simplify: Treated as an alias for ``post_process``, deprecated but</span>
<span class="sd">        currently retained for backwards compatibility if set to ``False``.</span>
<span class="sd">    :param bool overlay_non_inference_sites: If True, sites that were included in</span>
<span class="sd">        the selected sites, but were not used for inference, will be added to the</span>
<span class="sd">        tree sequence by mapping their mutations over the inferred topology.</span>
<span class="sd">        Defaults to True.</span>
<span class="sd">    :return: The tree sequence representing the inferred history</span>
<span class="sd">        of the sample.</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">simplify_only</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># if true, carry out &quot;old&quot; (deprecated) simplify behaviour</span>
    <span class="k">if</span> <span class="n">simplify</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">post_process</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">post_process</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">post_process</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t specify both `simplify` and `post_process`&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;The `simplify` parameter is deprecated in favour of `post_process`&quot;</span>
                <span class="p">)</span>
                <span class="n">simplify_only</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">post_process</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">post_process</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">overlay_non_inference_sites</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">overlay_non_inference_sites</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">overlay_non_inference_sites</span> <span class="o">=</span> <span class="n">overlay_non_inference_sites</span>

    <span class="k">with</span> <span class="n">provenance</span><span class="o">.</span><span class="n">TimingAndMemory</span><span class="p">()</span> <span class="k">as</span> <span class="n">timing</span><span class="p">:</span>
        <span class="n">variant_data</span><span class="o">.</span><span class="n">_check_finalised</span><span class="p">()</span>
        <span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">,</span> <span class="n">match_samples</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">manager</span> <span class="o">=</span> <span class="n">SampleMatcher</span><span class="p">(</span>
            <span class="n">variant_data</span><span class="p">,</span>
            <span class="n">ancestors_ts</span><span class="p">,</span>
            <span class="n">recombination_rate</span><span class="o">=</span><span class="n">recombination_rate</span><span class="p">,</span>
            <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
            <span class="n">recombination</span><span class="o">=</span><span class="n">recombination</span><span class="p">,</span>
            <span class="n">mismatch</span><span class="o">=</span><span class="n">mismatch</span><span class="p">,</span>
            <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
            <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">likelihood_threshold</span><span class="o">=</span><span class="n">likelihood_threshold</span><span class="p">,</span>
            <span class="n">extended_checks</span><span class="o">=</span><span class="n">extended_checks</span><span class="p">,</span>
            <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span>
            <span class="n">progress_monitor</span><span class="o">=</span><span class="n">progress_monitor</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sample_indexes</span> <span class="o">=</span> <span class="n">check_sample_indexes</span><span class="p">(</span><span class="n">variant_data</span><span class="p">,</span> <span class="n">indexes</span><span class="p">)</span>
        <span class="n">sample_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">variant_data</span><span class="o">.</span><span class="n">individuals_time</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">force_sample_times</span><span class="p">:</span>
            <span class="n">individuals</span> <span class="o">=</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">samples_individual</span><span class="p">[:][</span><span class="n">sample_indexes</span><span class="p">]</span>
            <span class="c1"># By construction all samples in an sd file have an</span>
            <span class="c1"># individual: but check anyway</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">individuals</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">sample_times</span> <span class="o">=</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">individuals_time</span><span class="p">[:][</span><span class="n">individuals</span><span class="p">]</span>

            <span class="c1"># Here we might want to re-order sample_indexes and sample_times</span>
            <span class="c1"># so that any historical ones come first, any we bomb out early</span>
            <span class="c1"># if they conflict but that would mean re-ordering the sample</span>
            <span class="c1"># nodes in the final ts, and we sometimes assume they are in</span>
            <span class="c1"># the same order as in the file</span>
        <span class="n">manager</span><span class="o">.</span><span class="n">match_samples</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">,</span> <span class="n">sample_times</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">finalise</span><span class="p">(</span><span class="n">overlay_non_inference_sites</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">post_process</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">_post_process</span><span class="p">(</span>
                <span class="n">ts</span><span class="p">,</span> <span class="n">warn_if_unexpected_format</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simplify_only</span><span class="o">=</span><span class="n">simplify_only</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="c1"># We don&#39;t have a source here because tree sequence files don&#39;t have a UUID yet.</span>
        <span class="n">record</span> <span class="o">=</span> <span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span>
            <span class="n">command</span><span class="o">=</span><span class="s2">&quot;match_samples&quot;</span><span class="p">,</span>
            <span class="n">resources</span><span class="o">=</span><span class="n">timing</span><span class="o">.</span><span class="n">metrics</span><span class="o">.</span><span class="n">asdict</span><span class="p">(),</span>
            <span class="n">mismatch_ratio</span><span class="o">=</span><span class="n">mismatch_ratio</span><span class="p">,</span>
            <span class="n">path_compression</span><span class="o">=</span><span class="n">path_compression</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">,</span>
            <span class="n">post_process</span><span class="o">=</span><span class="n">post_process</span><span class="p">,</span>
            <span class="c1"># TODO: maybe record recombination rate (which could be a RateMap)</span>
        <span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">record</span><span class="p">))</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ts</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">insert_missing_sites</span><span class="p">(</span>
    <span class="n">variant_data</span><span class="p">,</span> <span class="n">tree_sequence</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sample_id_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new tree sequence containing extra sites that are present in a</span>
<span class="sd">    :class:`VariantData` instance but are missing from a corresponding tree sequence.</span>
<span class="sd">    At each newly inserted site, mutations are overlaid parsimoneously, using</span>
<span class="sd">    :meth:`tskit.Tree.map_mutations`,</span>
<span class="sd">    such that the realised variation at that site corresponds to the allelic</span>
<span class="sd">    distribution seen in the variant_data file. Sites that have mutations overlaid</span>
<span class="sd">    in this way can be identified in the output tree sequence as their</span>
<span class="sd">    :ref:`metadata&lt;tskit.sec_metadata_definition&gt;` will contain a key named</span>
<span class="sd">    ``inference`` set to ``tsinfer.INFERENCE_PARSIMONY``. Newly inserted sites</span>
<span class="sd">    that do not require mutations will have this set to `tsinfer.INFERENCE_NONE`</span>
<span class="sd">    instead. Sites in ``variant_data`` that already exist in the tree sequence are</span>
<span class="sd">    left untouched.</span>

<span class="sd">    By default, sample 0 in ``variant_data`` is assumed to correspond to the first</span>
<span class="sd">    sample node in the input tree sequence (i.e. ``tree_sequence.samples()[0]``),</span>
<span class="sd">    sample 1 to the second sample node, and so on. If this is not the case, a map</span>
<span class="sd">    can be provided, which specifies the sample ids in ``variant_data`` that</span>
<span class="sd">    correspond to the sample nodes in the tree sequence. This also allows the use</span>
<span class="sd">    of :class:`VariantData` instances that contain samples in addition to those</span>
<span class="sd">    in the original tree sequence.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Sample states observed as missing in the input ``variant_data`` need</span>
<span class="sd">        not correspond to samples whose nodes are actually &quot;missing&quot; (i.e.</span>
<span class="sd">        :ref:`isolated&lt;tskit.sec_data_model_missing_data&gt;`) in the input tree</span>
<span class="sd">        sequence. In this case, the allelic state of the sample in the returned</span>
<span class="sd">        tree sequence will be imputed to the most parsimonious state.</span>

<span class="sd">    .. note::</span>
<span class="sd">        If the ancestral state at a site is unknown (i.e. ``tskit.MISSING_DATA``),</span>
<span class="sd">        it will be inferred by parsimony. If it is unknown and all sample data</span>
<span class="sd">        is missing at that site, the site will be created with an ancestral state</span>
<span class="sd">        set to the empty string.</span>

<span class="sd">    :param VariantData variant_data: The :class:`VariantData` instance</span>
<span class="sd">        containing some sites that are not in the input tree sequence.</span>
<span class="sd">    :param tskit.TreeSequence tree_sequence: The input :class:`tskit.TreeSequence`</span>
<span class="sd">        whose sample nodes correspond to a set of samples in the variant_data.</span>
<span class="sd">    :param sample_id_map array: An array of length `tree_sequence.num_samples`</span>
<span class="sd">        specifying the indexes of samples in the variant_data file that correspond</span>
<span class="sd">        to sample nodes ``0..(num_samples-1)`` in the tree sequence. If None,</span>
<span class="sd">        assume that all the samples in variant_data correspond to the sample nodes</span>
<span class="sd">        in the tree sequence, and are in the same order.</span>
<span class="sd">    :return: The input tree sequence with additional sites and mutations.</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;variant_data and tree_sequence must have the same sequence length&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">sample_id_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sample_id_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">variant_data</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_id_map</span><span class="p">)</span> <span class="o">!=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;You must specify the same number of samples in variant_data &quot;</span>
            <span class="s2">&quot;as in the tree_sequence&quot;</span>
        <span class="p">)</span>
    <span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">)</span>
    <span class="n">tables</span> <span class="o">=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
    <span class="n">trees</span> <span class="o">=</span> <span class="n">tree_sequence</span><span class="o">.</span><span class="n">trees</span><span class="p">()</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:]</span>
    <span class="n">new_sd_sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">schema</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">schema</span>

    <span class="c1"># Create new sites and add the mutations</span>
    <span class="n">progress</span> <span class="o">=</span> <span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ms_extra_sites&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_sd_sites</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">variant</span> <span class="ow">in</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">variants</span><span class="p">(</span><span class="n">sites</span><span class="o">=</span><span class="n">new_sd_sites</span><span class="p">,</span> <span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">site</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">site</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">position</span>
        <span class="n">anc_state</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">ancestral_state</span>
        <span class="n">anc_value</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># variant(recode_ancestral=True) always has 0 as the anc index</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">genotypes</span><span class="p">[</span><span class="n">sample_id_map</span><span class="p">]</span>
        <span class="c1"># We can&#39;t perform parsimony inference if all sites are missing, and there&#39;s no</span>
        <span class="c1"># point if all non-missing sites are the ancestral state, so skip these cases</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">G</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MISSING_DATA</span><span class="p">,</span> <span class="n">G</span> <span class="o">==</span> <span class="n">anc_value</span><span class="p">)):</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">_update_site_metadata</span><span class="p">(</span>
                <span class="n">site</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">inference_type</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_NONE</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">_encode_raw_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">position</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">ancestral_state</span><span class="o">=</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">anc_state</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">anc_state</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">tree</span><span class="o">.</span><span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pos</span><span class="p">:</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees</span><span class="p">)</span>
            <span class="n">anc_state</span><span class="p">,</span> <span class="n">mapped_mutations</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">map_mutations</span><span class="p">(</span>
                <span class="n">G</span><span class="p">,</span> <span class="n">variant</span><span class="o">.</span><span class="n">alleles</span><span class="p">,</span> <span class="n">ancestral_state</span><span class="o">=</span><span class="n">anc_state</span>
            <span class="p">)</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">_update_site_metadata</span><span class="p">(</span>
                <span class="n">site</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">inference_type</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_PARSIMONY</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">_encode_raw_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">new_site_id</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">position</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">ancestral_state</span><span class="o">=</span><span class="n">anc_state</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">mut_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">:</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mutation</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mapped_mutations</span><span class="p">):</span>
                <span class="n">mut_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                    <span class="n">site</span><span class="o">=</span><span class="n">new_site_id</span><span class="p">,</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">mutation</span><span class="o">.</span><span class="n">node</span><span class="p">,</span>
                    <span class="n">derived_state</span><span class="o">=</span><span class="n">mutation</span><span class="o">.</span><span class="n">derived_state</span><span class="p">,</span>
                    <span class="n">parent</span><span class="o">=</span><span class="n">mut_map</span><span class="p">[</span><span class="n">mutation</span><span class="o">.</span><span class="n">parent</span><span class="p">],</span>
                <span class="p">)</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
    <span class="n">progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">tables</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AncestorsGenerator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manages the process of building ancestors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variant_data</span><span class="p">,</span>
        <span class="n">ancestor_data_path</span><span class="p">,</span>
        <span class="n">ancestor_data_kwargs</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
        <span class="n">genotype_encoding</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">GenotypeEncoding</span><span class="o">.</span><span class="n">EIGHT_BIT</span><span class="p">,</span>
        <span class="n">mmap_temp_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span> <span class="o">=</span> <span class="n">variant_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data_path</span> <span class="o">=</span> <span class="n">ancestor_data_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data_kwargs</span> <span class="o">=</span> <span class="n">ancestor_data_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span>
            <span class="n">progress_monitor</span><span class="p">,</span> <span class="n">generate_ancestors</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_sites</span> <span class="o">=</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">num_sites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inference_site_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="n">num_threads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mmap_temp_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">mmap_fd</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">genotype_matrix_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sites</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="k">if</span> <span class="n">genotype_encoding</span> <span class="o">==</span> <span class="n">constants</span><span class="o">.</span><span class="n">GenotypeEncoding</span><span class="o">.</span><span class="n">ONE_BIT</span><span class="p">:</span>
            <span class="n">genotype_matrix_size</span> <span class="o">/=</span> <span class="mi">8</span>
        <span class="n">genotype_mem</span> <span class="o">=</span> <span class="n">humanize</span><span class="o">.</span><span class="n">naturalsize</span><span class="p">(</span><span class="n">genotype_matrix_size</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Max encoded genotype matrix size=</span><span class="si">{</span><span class="n">genotype_mem</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mmap_temp_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mmap_temp_file</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span>
                <span class="nb">dir</span><span class="o">=</span><span class="n">mmap_temp_dir</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;tsinfer-mmap-genotypes-&quot;</span>
            <span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using mmapped </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mmap_temp_file</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> for genotypes&quot;</span><span class="p">)</span>
            <span class="n">mmap_fd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mmap_temp_file</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">engine</span> <span class="o">==</span> <span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using C AncestorBuilder implementation&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_builder</span> <span class="o">=</span> <span class="n">_tsinfer</span><span class="o">.</span><span class="n">AncestorBuilder</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_sites</span><span class="p">,</span>
                <span class="n">genotype_encoding</span><span class="o">=</span><span class="n">genotype_encoding</span><span class="p">,</span>
                <span class="n">mmap_fd</span><span class="o">=</span><span class="n">mmap_fd</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">engine</span> <span class="o">==</span> <span class="n">constants</span><span class="o">.</span><span class="n">PY_ENGINE</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using Python AncestorBuilder implementation&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_builder</span> <span class="o">=</span> <span class="n">algorithm</span><span class="o">.</span><span class="n">AncestorBuilder</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_sites</span><span class="p">,</span>
                <span class="n">genotype_encoding</span><span class="o">=</span><span class="n">genotype_encoding</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown engine:</span><span class="si">{</span><span class="n">engine</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude_positions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add all sites that are suitable for inference into the ancestor builder</span>
<span class="sd">        (and subsequent inference), unless they are held in the specified list of</span>
<span class="sd">        excluded site positions. Suitable sites have only 2 listed alleles, one of</span>
<span class="sd">        which is defined as the ancestral_state, and where at least two samples</span>
<span class="sd">        carry the derived allele and at least one sample carries the ancestral allele.</span>

<span class="sd">        Suitable sites will be added at the time given by site.time, unless</span>
<span class="sd">        site.time is  ``np.nan`` or ``tskit.UNKNOWN_TIME``. In the first case,</span>
<span class="sd">        the site will simply excluded as if it were in the list of</span>
<span class="sd">        ``excluded_positions``. In the second case, then the time associated with</span>
<span class="sd">        the site will be the frequency of the derived allele (i.e. the number</span>
<span class="sd">        of samples with the derived allele divided by the total number of samples</span>
<span class="sd">        with non-missing alleles).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exclude_positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude_positions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exclude_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">exclude_positions</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exclude_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;exclude_positions must be a 1D array of numbers&quot;</span><span class="p">)</span>
        <span class="n">exclude_positions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude_positions</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting addition of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_sites</span><span class="si">}</span><span class="s2"> sites&quot;</span><span class="p">)</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ga_add_sites&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_sites</span><span class="p">)</span>
        <span class="n">inference_site_id</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">variant</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">variants</span><span class="p">(</span><span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># If there&#39;s missing data the last allele is None</span>
            <span class="n">num_alleles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

            <span class="n">counts</span> <span class="o">=</span> <span class="n">allele_counts</span><span class="p">(</span><span class="n">variant</span><span class="o">.</span><span class="n">genotypes</span><span class="p">)</span>
            <span class="n">use_site</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">site</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">site</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">site</span><span class="o">.</span><span class="n">position</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_positions</span>
                <span class="ow">and</span> <span class="n">num_alleles</span> <span class="o">==</span> <span class="mi">2</span>  <span class="c1"># This will ensure that the derived state is &quot;1&quot;</span>
                <span class="ow">and</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">counts</span><span class="o">.</span><span class="n">derived</span> <span class="o">&lt;</span> <span class="n">counts</span><span class="o">.</span><span class="n">known</span>
                <span class="ow">and</span> <span class="n">site</span><span class="o">.</span><span class="n">ancestral_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">):</span>
                <span class="n">use_site</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">time</span>
                <span class="k">if</span> <span class="n">tskit</span><span class="o">.</span><span class="n">is_unknown_time</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
                    <span class="c1"># Non-variable sites have no obvious freq-as-time values</span>
                    <span class="k">assert</span> <span class="n">counts</span><span class="o">.</span><span class="n">known</span> <span class="o">!=</span> <span class="n">counts</span><span class="o">.</span><span class="n">derived</span>
                    <span class="k">assert</span> <span class="n">counts</span><span class="o">.</span><span class="n">known</span> <span class="o">!=</span> <span class="n">counts</span><span class="o">.</span><span class="n">ancestral</span>
                    <span class="n">time</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">derived</span> <span class="o">/</span> <span class="n">counts</span><span class="o">.</span><span class="n">known</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">time</span><span class="p">):</span>
                    <span class="n">use_site</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Site with meaningless time value: skip inference</span>
            <span class="k">if</span> <span class="n">use_site</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_builder</span><span class="o">.</span><span class="n">add_site</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">variant</span><span class="o">.</span><span class="n">genotypes</span><span class="p">)</span>
                <span class="n">inference_site_id</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inference_site_ids</span> <span class="o">=</span> <span class="n">inference_site_id</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finished adding sites&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_run_synchronous</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">progress</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptors</span><span class="p">:</span>
            <span class="n">before</span> <span class="o">=</span> <span class="n">time_</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_builder</span><span class="o">.</span><span class="n">make_ancestor</span><span class="p">(</span><span class="n">focal_sites</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="n">duration</span> <span class="o">=</span> <span class="n">time_</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">before</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Made ancestor in </span><span class="si">{:.2f}</span><span class="s2">s at timepoint </span><span class="si">{}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2"> (len=</span><span class="si">{}</span><span class="s2">) with </span><span class="si">{}</span><span class="s2"> focal sites (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">duration</span><span class="p">,</span>
                    <span class="n">t</span><span class="p">,</span>
                    <span class="n">start</span><span class="p">,</span>
                    <span class="n">end</span><span class="p">,</span>
                    <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">focal_sites</span><span class="p">),</span>
                    <span class="n">focal_sites</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">add_ancestor</span><span class="p">(</span>
                <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
                <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                <span class="n">focal_sites</span><span class="o">=</span><span class="n">focal_sites</span><span class="p">,</span>
                <span class="n">haplotype</span><span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_run_threaded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">progress</span><span class="p">):</span>
        <span class="c1"># This works by pushing the ancestor descriptors onto the build_queue,</span>
        <span class="c1"># which the worker threads pop off and process. We need to add ancestors</span>
        <span class="c1"># in the the ancestor_data object in the correct order, so we maintain</span>
        <span class="c1"># a priority queue (add_queue) which allows us to track the next smallest</span>
        <span class="c1"># index of the generated ancestor. We add build ancestors to this queue</span>
        <span class="c1"># as they are built, and drain it when we can.</span>
        <span class="n">queue_depth</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span>  <span class="c1"># Seems like a reasonable limit</span>
        <span class="n">build_queue</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">queue_depth</span><span class="p">)</span>
        <span class="n">add_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
        <span class="n">next_add_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">add_queue</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">drain_add_queue</span><span class="p">():</span>
            <span class="k">nonlocal</span> <span class="n">next_add_index</span>
            <span class="n">num_drained</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">add_queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">add_queue</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">next_add_index</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">haplotype</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">add_queue</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">add_ancestor</span><span class="p">(</span>
                    <span class="n">start</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">e</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span><span class="o">=</span><span class="n">focal_sites</span><span class="p">,</span> <span class="n">haplotype</span><span class="o">=</span><span class="n">haplotype</span>
                <span class="p">)</span>
                <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
                <span class="n">next_add_index</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">num_drained</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Drained </span><span class="si">{</span><span class="n">num_drained</span><span class="si">}</span><span class="s2"> ancestors from add queue&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">build_worker</span><span class="p">(</span><span class="n">thread_index</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">work</span> <span class="o">=</span> <span class="n">build_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">work</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span> <span class="o">=</span> <span class="n">work</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_builder</span><span class="o">.</span><span class="n">make_ancestor</span><span class="p">(</span><span class="n">focal_sites</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">add_lock</span><span class="p">:</span>
                    <span class="n">haplotype</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span>
                        <span class="n">add_queue</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">haplotype</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">drain_add_queue</span><span class="p">()</span>
                <span class="n">build_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
            <span class="n">build_queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>

        <span class="n">build_threads</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">threads</span><span class="o">.</span><span class="n">queue_consumer_thread</span><span class="p">(</span>
                <span class="n">build_worker</span><span class="p">,</span> <span class="n">build_queue</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;build-worker-</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">j</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Started </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="si">}</span><span class="s2"> build worker threads&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptors</span><span class="p">):</span>
            <span class="n">build_queue</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span><span class="p">))</span>

        <span class="c1"># Stop the the worker threads.</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">):</span>
            <span class="n">build_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">):</span>
            <span class="n">build_threads</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
        <span class="n">drain_add_queue</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">descriptors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_builder</span><span class="o">.</span><span class="n">ancestor_descriptors</span><span class="p">()</span>
        <span class="n">peak_ram</span> <span class="o">=</span> <span class="n">humanize</span><span class="o">.</span><span class="n">naturalsize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestor_builder</span><span class="o">.</span><span class="n">mem_size</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ancestor builder peak RAM: </span><span class="si">{</span><span class="n">peak_ram</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Sort the descriptors so that we deterministically create ancestors</span>
        <span class="c1"># in the same order across implementations</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">focal_sites</span><span class="p">))</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">focal_sites</span> <span class="ow">in</span> <span class="n">descriptors</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descriptors</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptors</span><span class="p">)</span>
        <span class="c1"># Maps epoch numbers to their corresponding ancestor times.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timepoint_to_epoch</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptors</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">timepoint_to_epoch</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">timepoint_to_epoch</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timepoint_to_epoch</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span> <span class="o">=</span> <span class="n">formats</span><span class="o">.</span><span class="n">AncestorData</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:][</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_site_ids</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span>
            <span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data_path</span><span class="p">,</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data_kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting build for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span><span class="si">}</span><span class="s2"> ancestors&quot;</span><span class="p">)</span>
            <span class="n">progress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ga_generate&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span><span class="p">)</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
            <span class="n">root_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timepoint_to_epoch</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">av_timestep</span> <span class="o">=</span> <span class="n">root_time</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timepoint_to_epoch</span><span class="p">)</span>
            <span class="n">root_time</span> <span class="o">+=</span> <span class="n">av_timestep</span>  <span class="c1"># Add a root a bit older than the oldest ancestor</span>
            <span class="c1"># Add an extra ancestor to act as a type of &quot;virtual root&quot; for the matching</span>
            <span class="c1"># algorithm: rather an awkward hack, but also allows the ancestor IDs to</span>
            <span class="c1"># line up. It&#39;s normally removed when processing the final tree sequence.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">add_ancestor</span><span class="p">(</span>
                <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">root_time</span> <span class="o">+</span> <span class="n">av_timestep</span><span class="p">,</span>
                <span class="n">focal_sites</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">haplotype</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># This is the the &quot;ultimate ancestor&quot; of all zeros</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">add_ancestor</span><span class="p">(</span>
                <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">root_time</span><span class="p">,</span>
                <span class="n">focal_sites</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="n">haplotype</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_run_synchronous</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_run_threaded</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
            <span class="n">progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finished building ancestors&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mmap_temp_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mmap_temp_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>  <span class="c1"># noqa</span>
                <span class="k">pass</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Matcher</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A matching instance, used in both ``tsinfer.match_ancestors`` and</span>
<span class="sd">    ``tsinfer.match_samples``. For details of the ``path_compression``,</span>
<span class="sd">    `recombination_rate`` and ``mismatch_ratio`` parameters, see</span>
<span class="sd">    :ref:`matching ancestors &amp; samples&lt;sec_inference_match_ancestors_and_samples&gt;`.</span>

<span class="sd">    Note that the ``recombination`` and ``mismatch`` parameters can be used in</span>
<span class="sd">    ``match_ancestors`` and ``match_samples`` and are passed directly to this</span>
<span class="sd">    function, but are deliberately not publicly documented in those methods.</span>
<span class="sd">    They are expected to be numpy arrays of length ``num_inference_sites - 1`` and</span>
<span class="sd">    ``num_inference_sites`` respectively, containing values between 0 and 1, and</span>
<span class="sd">    allow recombination and mismatch probabilities to be set directly. The</span>
<span class="sd">    ``recombination`` probabilities measure the probability of a recombination event</span>
<span class="sd">    between adjacent inference sites, used to calculate the HMM transition probabilities</span>
<span class="sd">    in the L&amp;S-like matching algorithm. The ``mismatch`` probabilities are used</span>
<span class="sd">    to calculate the emission probabilities in the HMM. Note that values &gt; 0.5 in</span>
<span class="sd">    the recombination and (particularly) the mutation arrays are likely to lead to</span>
<span class="sd">    pathological behaviour  - for example, a mismatch probability of 1 means that a</span>
<span class="sd">    mismatch is *required* at every site. For this reason, the probabilities</span>
<span class="sd">    created for recombination and mismatch when using the the public-facing</span>
<span class="sd">    ``recombination_rate`` and ``mismatch_ratio`` parameters are never &gt; 0.5.</span>
<span class="sd">    TODO: include deliberately non-public details of precision here.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variant_data</span><span class="p">,</span>
        <span class="n">inference_site_position</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">path_compression</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">recombination_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mismatch_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">recombination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mismatch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">likelihood_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extended_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">engine</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">,</span>
        <span class="n">progress_monitor</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_multiallele</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span> <span class="o">=</span> <span class="n">variant_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="n">num_threads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path_compression</span> <span class="o">=</span> <span class="n">path_compression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inference_site_position</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No sites used for inference&quot;</span><span class="p">)</span>
        <span class="n">num_intervals</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span> <span class="o">=</span> <span class="n">_get_progress_monitor</span><span class="p">(</span><span class="n">progress_monitor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Allocated by subclass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extended_checks</span> <span class="o">=</span> <span class="n">extended_checks</span>

        <span class="n">all_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">all_sites</span><span class="p">,</span> <span class="n">inference_site_position</span><span class="p">)</span>
        <span class="n">num_alleles</span> <span class="o">=</span> <span class="n">variant_data</span><span class="o">.</span><span class="n">num_alleles</span><span class="p">()[</span><span class="n">index</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_alleles</span> <span class="o">=</span> <span class="n">num_alleles</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">all_sites</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">inference_site_position</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Site positions for inference must be a subset of those in &quot;</span>
                <span class="s2">&quot;the sample data file.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inference_site_id</span> <span class="o">=</span> <span class="n">index</span>

        <span class="c1"># Map of site index to tree sequence position. Bracketing</span>
        <span class="c1"># values of 0 and L are used for simplicity.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">inference_site_position</span><span class="p">,</span> <span class="p">[</span><span class="n">variant_data</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">]]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recombination</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>  <span class="c1"># TODO: reduce len by 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">recombination</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mismatch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">recombination</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mismatch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Directly setting probabilities requires specifying &quot;</span>
                    <span class="s2">&quot;both &#39;recombination&#39; and &#39;mismatch&#39;&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">recombination_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mismatch_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot simultaneously specify recombination &amp; recombination_rate, &quot;</span>
                    <span class="s2">&quot;or mismatch and mismatch_ratio&quot;</span>
                <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Recombination and mismatch probabilities given by user&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Must set recombination and mismatch arrays</span>
            <span class="k">if</span> <span class="n">recombination_rate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mismatch_ratio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot use mismatch without setting recombination&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">recombination_rate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mismatch_ratio</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">)</span> <span class="ow">or</span> <span class="n">num_intervals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Special case: revert to tsinfer 0.1 behaviour with no mismatch allowed</span>
                <span class="n">default_recombination_prob</span> <span class="o">=</span> <span class="mf">1e-2</span>
                <span class="n">default_mismatch_prob</span> <span class="o">=</span> <span class="mf">1e-20</span>  <span class="c1"># Substantially &lt; the value above</span>
                <span class="n">recombination</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">num_intervals</span><span class="p">,</span> <span class="n">default_recombination_prob</span><span class="p">)</span>
                <span class="n">mismatch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">default_mismatch_prob</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Mismatch prevented by setting constant high recombination and &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;low mismatch probabilities&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">genetic_dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recombination_rate_to_dist</span><span class="p">(</span>
                    <span class="n">recombination_rate</span><span class="p">,</span> <span class="n">inference_site_position</span>
                <span class="p">)</span>
                <span class="n">recombination</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recombination_dist_to_prob</span><span class="p">(</span><span class="n">genetic_dists</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mismatch_ratio</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">mismatch_ratio</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">mismatch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mismatch_ratio_to_prob</span><span class="p">(</span>
                        <span class="n">mismatch_ratio</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">genetic_dists</span><span class="p">),</span> <span class="n">num_alleles</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Recombination and mismatch probabilities calculated from &quot;</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;specified recomb rates with mismatch ratio = </span><span class="si">{</span><span class="n">mismatch_ratio</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">recombination</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_intervals</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad length for recombination array&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mismatch</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bad length for mismatch array&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">recombination</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">recombination</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Underlying recombination probabilities not between 0 &amp; 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mismatch</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mismatch</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Underlying mismatch probabilities not between 0 &amp; 1&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">likelihood_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify likelihood_threshold and precision&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">likelihood_threshold</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="n">precision</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">likelihood_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">likelihood_threshold</span> <span class="o">=</span> <span class="mf">1e-13</span>  <span class="c1"># ~Same as previous precision default.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recombination</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">recombination</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mismatch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">likelihood_threshold</span> <span class="o">=</span> <span class="n">likelihood_threshold</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">recombination</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fewer than two inference sites: no recombination possible&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Summary of recombination probabilities between sites: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;min=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">recombination</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;max=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">recombination</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;median=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">recombination</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;mean=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">recombination</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mismatch</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No inference sites: no mismatch possible&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Summary of mismatch probabilities over sites: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;min=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mismatch</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;max=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mismatch</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;median=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">mismatch</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;mean=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mismatch</span><span class="p">)</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Matching using likelihood_threshold of </span><span class="si">{</span><span class="n">likelihood_threshold</span><span class="si">:</span><span class="s2">.5g</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="n">engine</span>
        <span class="k">if</span> <span class="n">engine</span> <span class="o">==</span> <span class="n">constants</span><span class="o">.</span><span class="n">C_ENGINE</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using C matcher implementation&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder_class</span> <span class="o">=</span> <span class="n">_tsinfer</span><span class="o">.</span><span class="n">TreeSequenceBuilder</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_matcher_class</span> <span class="o">=</span> <span class="n">_tsinfer</span><span class="o">.</span><span class="n">AncestorMatcher</span>
        <span class="k">elif</span> <span class="n">engine</span> <span class="o">==</span> <span class="n">constants</span><span class="o">.</span><span class="n">PY_ENGINE</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Using Python matcher implementation&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder_class</span> <span class="o">=</span> <span class="n">algorithm</span><span class="o">.</span><span class="n">TreeSequenceBuilder</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_matcher_class</span> <span class="o">=</span> <span class="n">algorithm</span><span class="o">.</span><span class="n">AncestorMatcher</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown engine:</span><span class="si">{</span><span class="n">engine</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Allocate 64K nodes and edges initially. This will double as needed and will</span>
        <span class="c1"># quickly be big enough even for very large instances.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_edges</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">num_alleles</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_multiallele</span><span class="p">:</span>
            <span class="c1"># Currently only used for unsupported extend operation. We can</span>
            <span class="c1"># remove in future versions.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot currently match with &gt; 2 alleles.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder_class</span><span class="p">(</span>
            <span class="n">num_alleles</span><span class="o">=</span><span class="n">num_alleles</span><span class="p">,</span> <span class="n">max_nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="p">,</span> <span class="n">max_edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_edges</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Allocated tree sequence builder with max_nodes=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">max_nodes</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_path</span><span class="p">(</span><span class="n">matcher</span><span class="p">,</span> <span class="n">child_id</span><span class="p">,</span> <span class="n">haplotype</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the path of the specified haplotype and returns the MatchResult object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="n">haplotype</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MISSING_DATA</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">haplotype</span><span class="p">),</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MISSING_DATA</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">matcher</span><span class="o">.</span><span class="n">find_path</span><span class="p">(</span><span class="n">haplotype</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
        <span class="k">match</span><span class="p">[</span><span class="n">missing</span><span class="p">]</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MISSING_DATA</span>
        <span class="n">diffs</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">haplotype</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">!=</span> <span class="n">match</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">derived_state</span> <span class="o">=</span> <span class="n">haplotype</span><span class="p">[</span><span class="n">diffs</span><span class="p">]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">MatchResult</span><span class="p">(</span>
            <span class="n">node</span><span class="o">=</span><span class="n">child_id</span><span class="p">,</span>
            <span class="n">path</span><span class="o">=</span><span class="n">Path</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">),</span>
            <span class="n">mutations_site</span><span class="o">=</span><span class="n">diffs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">mutations_derived_state</span><span class="o">=</span><span class="n">derived_state</span><span class="p">,</span>
            <span class="n">mean_traceback_size</span><span class="o">=</span><span class="n">matcher</span><span class="o">.</span><span class="n">mean_traceback_size</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Matched node </span><span class="si">{}</span><span class="s2">; &quot;</span>
            <span class="s2">&quot;num_edges=</span><span class="si">{}</span><span class="s2"> tb_size=</span><span class="si">{:.2f}</span><span class="s2"> match_mem=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">child_id</span><span class="p">,</span>
                <span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">matcher</span><span class="o">.</span><span class="n">mean_traceback_size</span><span class="p">,</span>
                <span class="n">humanize</span><span class="o">.</span><span class="n">naturalsize</span><span class="p">(</span><span class="n">matcher</span><span class="o">.</span><span class="n">total_memory</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">recombination_rate_to_dist</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the mean number of recombinations between adjacent positions (i.e.</span>
<span class="sd">        the genetic distance in Morgans) given either a fixed rate or a RateMap</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rho</span><span class="o">.</span><span class="n">get_cumulative_mass</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">*</span> <span class="n">rho</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">recombination_dist_to_prob</span><span class="p">(</span><span class="n">genetic_distances</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert genetic distances (in Morgans) to a probability of recombination,</span>
<span class="sd">        (i.e. an odd number of events) assuming a Poisson distribution,</span>
<span class="sd">        see Haldane, 1919 J. Genetics 8: 299-309. This maxes out at 0.5 as dist -&gt; inf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">genetic_distances</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mismatch_ratio_to_prob</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="n">genetic_distances</span><span class="p">,</span> <span class="n">num_alleles</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a mismatch ratio, relative to a genetic distance, to a probability</span>
<span class="sd">        of mismatch. A mismatch probability of 1 means that the emitted allele has a</span>
<span class="sd">        100% probability of being different from the allele implied by the hidden</span>
<span class="sd">        state. For all allele types to be emitted with equal probability, regardless</span>
<span class="sd">        of the copying haplotype, the mismatch probability should be set to</span>
<span class="sd">        1/num_alleles.</span>

<span class="sd">        For a small genetic_distance d, setting a ratio of X should give a</span>
<span class="sd">        probability of approximately X * r, where r is the recombination probability</span>
<span class="sd">        given by recombination_dist_to_prob(d)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">genetic_distances</span> <span class="o">*</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">num_alleles</span><span class="p">))</span> <span class="o">/</span> <span class="n">num_alleles</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">create_matcher_instance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_matcher_class</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="p">,</span>
            <span class="n">recombination</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">recombination</span><span class="p">,</span>
            <span class="n">mismatch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mismatch</span><span class="p">,</span>
            <span class="n">likelihood_threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">likelihood_threshold</span><span class="p">,</span>
            <span class="n">extended_checks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extended_checks</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">convert_inference_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tables</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the mutations stored in the tree sequence builder into the output</span>
<span class="sd">        format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mut_site</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">derived_state</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">dump_mutations</span><span class="p">()</span>
        <span class="n">mutation_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">num_mutations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mut_site</span><span class="p">)</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;ms_full_mutations&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_site_id</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">schema</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">sites</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_site_id</span><span class="p">):</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">_update_site_metadata</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">constants</span><span class="o">.</span><span class="n">INFERENCE_FULL</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">_encode_raw_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">site_id</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">site</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                <span class="n">ancestral_state</span><span class="o">=</span><span class="n">site</span><span class="o">.</span><span class="n">ancestral_state</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">while</span> <span class="n">mutation_id</span> <span class="o">&lt;</span> <span class="n">num_mutations</span> <span class="ow">and</span> <span class="n">mut_site</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">site_id</span><span class="p">:</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                    <span class="n">site_id</span><span class="p">,</span>
                    <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">],</span>
                    <span class="n">derived_state</span><span class="o">=</span><span class="n">site</span><span class="o">.</span><span class="n">reorder_alleles</span><span class="p">()[</span><span class="n">derived_state</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]],</span>
                <span class="p">)</span>
                <span class="n">mutation_id</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">restore_tree_sequence_builder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_ts_tables</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Ancestors tree sequence not compatible: sequence length is different to&quot;</span>
                <span class="s2">&quot; sample data file.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All nodes must have time &gt; 0&quot;</span><span class="p">)</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">edges</span>
        <span class="c1"># Get the indexes into the position array.</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">,</span> <span class="n">edges</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">!=</span> <span class="n">edges</span><span class="o">.</span><span class="n">left</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid left coordinates&quot;</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">,</span> <span class="n">edges</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">!=</span> <span class="n">edges</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid right coordinates&quot;</span><span class="p">)</span>

        <span class="c1"># Need to sort by child ID here and left so that we can efficiently</span>
        <span class="c1"># insert the child paths.</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">edges</span><span class="o">.</span><span class="n">child</span><span class="p">))</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">restore_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">time</span><span class="p">,</span> <span class="n">nodes</span><span class="o">.</span><span class="n">flags</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">restore_edges</span><span class="p">(</span>
            <span class="n">left</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">right</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">num_match_nodes</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">mutations</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span>
        <span class="n">derived_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mutations</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">mutation_site</span> <span class="o">=</span> <span class="n">mutations</span><span class="o">.</span><span class="n">site</span>
        <span class="n">site_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">mutation_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">sites</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_site_id</span><span class="p">):</span>
            <span class="k">while</span> <span class="p">(</span>
                <span class="n">mutation_id</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">mutations</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mutation_site</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">site_id</span>
            <span class="p">):</span>
                <span class="n">allele</span> <span class="o">=</span> <span class="n">mutations</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]</span><span class="o">.</span><span class="n">derived_state</span>
                <span class="n">derived_state</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">site</span><span class="o">.</span><span class="n">reorder_alleles</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">allele</span><span class="p">)</span>
                <span class="n">mutation_id</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">site_id</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">restore_mutations</span><span class="p">(</span>
            <span class="n">mutation_site</span><span class="p">,</span> <span class="n">mutations</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">derived_state</span><span class="p">,</span> <span class="n">mutations</span><span class="o">.</span><span class="n">parent</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Loaded </span><span class="si">{}</span><span class="s2"> samples </span><span class="si">{}</span><span class="s2"> nodes; </span><span class="si">{}</span><span class="s2"> edges; </span><span class="si">{}</span><span class="s2"> sites; </span><span class="si">{}</span><span class="s2"> mutations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">mutations</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AncestorMatcher</span><span class="p">(</span><span class="n">Matcher</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">variant_data</span><span class="p">,</span> <span class="n">ancestor_data</span><span class="p">,</span> <span class="n">ancestors_ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">variant_data</span><span class="p">,</span> <span class="n">ancestor_data</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[:],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span> <span class="o">=</span> <span class="n">ancestor_data</span>
        <span class="k">if</span> <span class="n">time_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_units</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TIME_UNITS_UNCALIBRATED</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_units</span> <span class="o">=</span> <span class="n">time_units</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">num_ancestors</span>

        <span class="k">if</span> <span class="n">ancestors_ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Add nodes for all the ancestors so that the ancestor IDs are equal</span>
            <span class="c1"># to the node IDs.</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">ancestors_time</span><span class="p">[:]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_ts_tables</span> <span class="o">=</span> <span class="n">ancestors_ts</span><span class="o">.</span><span class="n">tables</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restore_tree_sequence_builder</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">group_by_linesweep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time_</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">ancestors_start</span><span class="p">[:]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">ancestors_end</span><span class="p">[:]</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">ancestors_time</span><span class="p">[:]</span>

        <span class="c1"># We only need to perform the grouping for the small epochs at earlier times.</span>
        <span class="c1"># Skipping the later epochs _really_ helps as later ancestors are dependent on</span>
        <span class="c1"># almost all the earlier ones, so the dependency graph becomes intractable.</span>
        <span class="n">breaks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">time</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">epoch_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="n">breaks</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">epoch_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">breaks</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span><span class="p">]])</span>
        <span class="n">time_slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">epoch_start</span><span class="p">,</span> <span class="n">epoch_end</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">epoch_sizes</span> <span class="o">=</span> <span class="n">time_slices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">time_slices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">median_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">epoch_sizes</span><span class="p">)</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">*</span> <span class="n">median_size</span>
        <span class="c1"># Zero out the first half so that an initial large epoch doesn&#39;t</span>
        <span class="c1"># get selected as the cutoff</span>
        <span class="n">epoch_sizes</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="n">epoch_sizes</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># To choose a cutoff point find the first epoch that is 50 times larger than</span>
        <span class="c1"># the median epoch size. For a large set of human genomes the median epoch</span>
        <span class="c1"># size is around 10, so we&#39;ll stop grouping by linesweep at 5000.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">epoch_sizes</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">cutoff</span><span class="p">:</span>
            <span class="n">large_epoch</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_slices</span><span class="p">)</span>
            <span class="n">large_epoch_first_ancestor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">large_epoch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">epoch_sizes</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">large_epoch_first_ancestor</span> <span class="o">=</span> <span class="n">time_slices</span><span class="p">[</span><span class="n">large_epoch</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">time_slices</span><span class="p">)</span><span class="si">}</span><span class="s2"> epochs with </span><span class="si">{</span><span class="n">median_size</span><span class="si">}</span><span class="s2"> median size.&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;First large (&gt;</span><span class="si">{</span><span class="n">cutoff</span><span class="si">}</span><span class="s2">) epoch is </span><span class="si">{</span><span class="n">large_epoch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grouping </span><span class="si">{</span><span class="n">large_epoch_first_ancestor</span><span class="si">}</span><span class="s2"> ancestors by linesweep&quot;</span><span class="p">)</span>
        <span class="n">ancestor_grouping</span> <span class="o">=</span> <span class="n">ancestors</span><span class="o">.</span><span class="n">group_ancestors_by_linesweep</span><span class="p">(</span>
            <span class="n">start</span><span class="p">[:</span><span class="n">large_epoch_first_ancestor</span><span class="p">],</span>
            <span class="n">end</span><span class="p">[:</span><span class="n">large_epoch_first_ancestor</span><span class="p">],</span>
            <span class="n">time</span><span class="p">[:</span><span class="n">large_epoch_first_ancestor</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># Add on the remaining epochs, grouped by time</span>
        <span class="n">next_epoch</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancestor_grouping</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">large_epoch</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_slices</span><span class="p">)):</span>
            <span class="n">ancestor_grouping</span><span class="p">[</span><span class="n">next_epoch</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">*</span><span class="n">time_slices</span><span class="p">[</span><span class="n">epoch</span><span class="p">])</span>
            <span class="n">next_epoch</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Remove the &quot;virtual root&quot; ancestor</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">ancestor_grouping</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ancestor_grouping</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Finished grouping into </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ancestor_grouping</span><span class="p">)</span><span class="si">}</span><span class="s2"> groups in &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">time_</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ancestor_grouping</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__start_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">ancestor_ids</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">[(</span><span class="s2">&quot;level&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">level</span><span class="p">)),</span> <span class="p">(</span><span class="s2">&quot;nanc&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ancestor_ids</span><span class="p">)))]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">set_detail</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">freeze_indexes</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__complete_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">ancestor_ids</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
        <span class="n">nodes_before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">num_nodes</span>
        <span class="n">match_nodes_before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">num_match_nodes</span>

        <span class="k">for</span> <span class="n">child_id</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ancestor_ids</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">result</span><span class="o">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">child_id</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">child_id</span><span class="p">),</span>
                <span class="n">result</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">left</span><span class="p">,</span>
                <span class="n">result</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">right</span><span class="p">,</span>
                <span class="n">result</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                <span class="n">compress</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path_compression</span><span class="p">,</span>
                <span class="n">extended_checks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">extended_checks</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">add_mutations</span><span class="p">(</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">child_id</span><span class="p">),</span> <span class="n">result</span><span class="o">.</span><span class="n">mutations_site</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">mutations_derived_state</span>
            <span class="p">)</span>

        <span class="n">extra_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">num_nodes</span> <span class="o">-</span> <span class="n">nodes_before</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">num_match_nodes</span>
            <span class="o">==</span> <span class="n">match_nodes_before</span> <span class="o">+</span> <span class="n">extra_nodes</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancestor_ids</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Finished group </span><span class="si">{}</span><span class="s2"> with </span><span class="si">{}</span><span class="s2"> ancestors; </span><span class="si">{}</span><span class="s2"> extra nodes inserted; &quot;</span>
            <span class="s2">&quot;mean_tb_size=</span><span class="si">{:.2f}</span><span class="s2"> edges=</span><span class="si">{}</span><span class="s2">;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">group</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">ancestor_ids</span><span class="p">),</span>
                <span class="n">extra_nodes</span><span class="p">,</span>
                <span class="p">(</span>
                    <span class="nb">sum</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">mean_traceback_size</span> <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span><span class="o">.</span><span class="n">num_edges</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match_locally</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ancestor_ids</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">thread_worker_function</span><span class="p">(</span><span class="n">ancestor</span><span class="p">):</span>
            <span class="n">local_data</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">local_data</span><span class="p">,</span> <span class="s2">&quot;matcher&quot;</span><span class="p">):</span>
                <span class="n">local_data</span><span class="o">.</span><span class="n">matcher</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_matcher_instance</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_path</span><span class="p">(</span>
                <span class="n">matcher</span><span class="o">=</span><span class="n">local_data</span><span class="o">.</span><span class="n">matcher</span><span class="p">,</span>
                <span class="n">child_id</span><span class="o">=</span><span class="n">ancestor</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                <span class="n">haplotype</span><span class="o">=</span><span class="n">ancestor</span><span class="o">.</span><span class="n">full_haplotype</span><span class="p">,</span>
                <span class="n">start</span><span class="o">=</span><span class="n">ancestor</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                <span class="n">end</span><span class="o">=</span><span class="n">ancestor</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">threads</span><span class="o">.</span><span class="n">threaded_map</span><span class="p">(</span>  <span class="c1"># noqa E731</span>
                    <span class="n">thread_worker_function</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">indexes</span><span class="o">=</span><span class="n">ancestor_ids</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span>
                    <span class="n">thread_worker_function</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">indexes</span><span class="o">=</span><span class="n">ancestor_ids</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ancestor_grouping</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting ancestor matching for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ancestor_grouping</span><span class="p">)</span><span class="si">}</span><span class="s2"> groups&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;ma_match&quot;</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="k">for</span> <span class="n">ids</span> <span class="ow">in</span> <span class="n">ancestor_grouping</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">group</span><span class="p">,</span> <span class="n">ancestor_ids</span> <span class="ow">in</span> <span class="n">ancestor_grouping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">time_</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Starting group </span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ancestor_grouping</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ancestor_ids</span><span class="p">)</span><span class="si">}</span><span class="s2"> ancestors&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__start_group</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">ancestor_ids</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_locally</span><span class="p">(</span><span class="n">ancestor_ids</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__complete_group</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">ancestor_ids</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Finished group </span><span class="si">{</span><span class="n">group</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ancestor_grouping</span><span class="p">)</span><span class="si">}</span><span class="s2"> in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">time_</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span>
            <span class="p">)</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_output</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finished ancestor matching&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match_partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ancestors_to_match</span><span class="p">,</span> <span class="n">group_index</span><span class="p">,</span> <span class="n">partition_index</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Matching group </span><span class="si">{</span><span class="n">group_index</span><span class="si">}</span><span class="s2"> partition </span><span class="si">{</span><span class="n">partition_index</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ancestors_to_match</span><span class="p">)</span><span class="si">}</span><span class="s2"> ancestors&quot;</span>
        <span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time_</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_group</span><span class="p">(</span><span class="n">group_index</span><span class="p">,</span> <span class="n">ancestors_to_match</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;ma_match&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ancestors_to_match</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_locally</span><span class="p">(</span><span class="n">ancestors_to_match</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Matching took </span><span class="si">{</span><span class="n">time_</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">finalise_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="n">group_index</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finalising group </span><span class="si">{</span><span class="n">group_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__start_group</span><span class="p">(</span><span class="n">group_index</span><span class="p">,</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;ancestors&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__complete_group</span><span class="p">(</span><span class="n">group_index</span><span class="p">,</span> <span class="n">group</span><span class="p">[</span><span class="s2">&quot;ancestors&quot;</span><span class="p">],</span> <span class="n">results</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_output</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finalised group </span><span class="si">{</span><span class="n">group_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fill_ancestors_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tables</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ancestors tree sequence tables. Only inference sites are included in</span>
<span class="sd">        this tree sequence. All nodes have the sample flag bit set, and if a node</span>
<span class="sd">        corresponds to an ancestor in the ancestors file, it is indicated via metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Building ancestors tree sequence&quot;</span><span class="p">)</span>
        <span class="n">tsb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span>

        <span class="n">flags</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">.</span><span class="n">dump_nodes</span><span class="p">()</span>
        <span class="n">pc_ancestors</span> <span class="o">=</span> <span class="n">is_pc_ancestor</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">)</span>

        <span class="c1"># Add metadata for any non-PC node, pointing to the original ancestor</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ancestor</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">is_pc</span> <span class="ow">in</span> <span class="n">pc_ancestors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_pc</span><span class="p">:</span>
                <span class="n">metadata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">metadata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_encode_raw_metadata</span><span class="p">({</span><span class="s2">&quot;ancestor_data_id&quot;</span><span class="p">:</span> <span class="n">ancestor</span><span class="p">}))</span>
                <span class="n">ancestor</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">packset_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">.</span><span class="n">dump_edges</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="n">left</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">left</span><span class="p">],</span>
            <span class="n">right</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">right</span><span class="p">],</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
            <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">convert_inference_mutations</span><span class="p">(</span><span class="n">tables</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sorting ancestors tree sequence&quot;</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c1"># Note: it&#39;s probably possible to compute the mutation parents from the</span>
        <span class="c1"># tsb data structures but we&#39;re not doing it for now.</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">build_index</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">compute_mutation_parents</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sorting ancestors tree sequence done&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Built ancestors tree sequence: </span><span class="si">{}</span><span class="s2"> nodes (</span><span class="si">{}</span><span class="s2"> pc ancestors); </span><span class="si">{}</span><span class="s2"> edges; &quot;</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> sites; </span><span class="si">{}</span><span class="s2"> mutations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pc_ancestors</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">store_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span>
            <span class="n">sequence_length</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestor_data</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="p">)</span>
        <span class="c1"># We decided to use a permissive schema for the metadata, for flexibility</span>
        <span class="n">dict_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="o">.</span><span class="n">permissive_json</span><span class="p">()</span><span class="o">.</span><span class="n">schema</span>
        <span class="n">dict_schema</span> <span class="o">=</span> <span class="n">add_to_schema</span><span class="p">(</span>
            <span class="n">dict_schema</span><span class="p">,</span> <span class="s2">&quot;ancestor_data_id&quot;</span><span class="p">,</span> <span class="n">node_ancestor_data_id_metadata_definition</span>
        <span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="n">dict_schema</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_ancestors</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fill_ancestors_tables</span><span class="p">(</span><span class="n">tables</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">time_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_units</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SampleMatcher</span><span class="p">(</span><span class="n">Matcher</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variant_data</span><span class="p">,</span> <span class="n">ancestors_ts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_ts_tables</span> <span class="o">=</span> <span class="n">ancestors_ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">variant_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_ts_tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">restore_tree_sequence_builder</span><span class="p">()</span>
        <span class="c1"># Map from input sample indexes (IDs in the SampleData file) to the</span>
        <span class="c1"># node ID in the tree sequence.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match_locally</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_indexes</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">thread_worker_function</span><span class="p">(</span><span class="n">j_haplotype</span><span class="p">):</span>
            <span class="n">j</span><span class="p">,</span> <span class="n">haplotype</span> <span class="o">=</span> <span class="n">j_haplotype</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">haplotype</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span>
            <span class="n">local_data</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">local_data</span><span class="p">,</span> <span class="s2">&quot;matcher&quot;</span><span class="p">):</span>
                <span class="n">local_data</span><span class="o">.</span><span class="n">matcher</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_matcher_instance</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">time_</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="si">}</span><span class="s2">Thread </span><span class="si">{</span><span class="n">threading</span><span class="o">.</span><span class="n">get_ident</span><span class="p">()</span><span class="si">}</span><span class="s2"> starting haplotype </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_path</span><span class="p">(</span>
                <span class="n">matcher</span><span class="o">=</span><span class="n">local_data</span><span class="o">.</span><span class="n">matcher</span><span class="p">,</span>
                <span class="n">child_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="n">haplotype</span><span class="o">=</span><span class="n">haplotype</span><span class="p">,</span>
                <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">time_</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="si">}</span><span class="s2">Thread </span><span class="si">{</span><span class="n">threading</span><span class="o">.</span><span class="n">get_ident</span><span class="p">()</span><span class="si">}</span><span class="s2"> finished haplotype </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="n">sample_haplotypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">haplotypes</span><span class="p">(</span>
            <span class="n">sample_indexes</span><span class="p">,</span>
            <span class="n">sites</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inference_site_id</span><span class="p">,</span>
            <span class="n">recode_ancestral</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">threads</span><span class="o">.</span><span class="n">threaded_map</span><span class="p">(</span>
                <span class="n">thread_worker_function</span><span class="p">,</span> <span class="n">sample_haplotypes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_threads</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">thread_worker_function</span><span class="p">,</span> <span class="n">sample_haplotypes</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_match_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_indexes</span><span class="p">,</span> <span class="n">results</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">)</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">dump_nodes</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Started matching for </span><span class="si">{</span><span class="n">num_samples</span><span class="si">}</span><span class="s2"> samples&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">results</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ms_match&quot;</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">time_</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">match_locally</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Finished matching for all samples in </span><span class="si">{</span><span class="n">time_</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">match_progress</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Inserting sample paths: </span><span class="si">{}</span><span class="s2"> edges in total&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">results</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">progress_monitor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ms_paths&quot;</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
            <span class="n">node_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">node_id</span> <span class="o">==</span> <span class="n">result</span><span class="o">.</span><span class="n">node</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">times</span><span class="p">[</span><span class="n">result</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">parent</span><span class="p">]):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="n">result</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">parent</span><span class="p">])]</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Failed to put sample </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2"> (node </span><span class="si">{</span><span class="n">node_id</span><span class="si">}</span><span class="s2">) at time &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">times</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span><span class="si">}</span><span class="s2"> as it has a younger parent (node </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">add_path</span><span class="p">(</span>
                <span class="n">result</span><span class="o">.</span><span class="n">node</span><span class="p">,</span>
                <span class="n">result</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">left</span><span class="p">,</span>
                <span class="n">result</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">right</span><span class="p">,</span>
                <span class="n">result</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
                <span class="n">compress</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path_compression</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">builder</span><span class="o">.</span><span class="n">add_mutations</span><span class="p">(</span>
                <span class="n">result</span><span class="o">.</span><span class="n">node</span><span class="p">,</span>
                <span class="n">result</span><span class="o">.</span><span class="n">mutations_site</span><span class="p">,</span>
                <span class="n">result</span><span class="o">.</span><span class="n">mutations_derived_state</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">progress_monitor</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
        <span class="n">progress_monitor</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">match_samples</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_indexes</span><span class="p">,</span> <span class="n">sample_times</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">results</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">slice_</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">sample_times</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">))</span>
        <span class="n">builder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">,</span> <span class="n">sample_times</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">builder</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">slice_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">slice_</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_match_samples</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">[</span><span class="n">slice_</span><span class="p">],</span> <span class="n">results</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">finalise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overlay_non_inference_sites</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Finalising tree sequence&quot;</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_samples_tree_sequence</span><span class="p">(</span><span class="n">overlay_non_inference_sites</span><span class="p">)</span>
        <span class="c1"># Check that there are the same number of samples as expected</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="p">)</span> <span class="o">==</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_samples</span>
        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_samples_tree_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overlay_non_inference_sites</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the current state of the build tree sequence. Sample nodes will have the</span>
<span class="sd">        sample node flag set and be in the same order as passed the order of</span>
<span class="sd">        sample_indexes passed to match_samples. For correct sample reconstruction,</span>
<span class="sd">        the non-inference sites also need to be placed into the resulting tree sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tsb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_ts_tables</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">metadata_schema</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">metadata</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">populations_metadata_schema</span>
        <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">metadata</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">populations_metadata</span><span class="p">[:]:</span>
            <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Use the default json encoding to avoid breaking old code.</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">_encode_raw_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">individuals_metadata_schema</span>
        <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">schema</span> <span class="o">=</span> <span class="n">add_to_schema</span><span class="p">(</span>
                <span class="n">schema</span><span class="p">,</span>
                <span class="s2">&quot;variant_data_time&quot;</span><span class="p">,</span>
                <span class="n">definition</span><span class="o">=</span><span class="n">variant_data_time_metadata_definition</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>

        <span class="n">num_ancestral_individuals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">individuals</span><span class="p">():</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">ind</span><span class="o">.</span><span class="n">metadata</span>
            <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">time</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;variant_data_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ind</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">_encode_raw_metadata</span><span class="p">(</span><span class="n">ind</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">individuals</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">location</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">location</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">flags</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding tree sequence nodes&quot;</span><span class="p">)</span>
        <span class="n">flags</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">.</span><span class="n">dump_nodes</span><span class="p">()</span>
        <span class="n">num_pc_ancestors</span> <span class="o">=</span> <span class="n">count_pc_ancestors</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

        <span class="c1"># All true ancestors are samples in the ancestors tree sequence. We unset</span>
        <span class="c1"># the SAMPLE flag but keep other flags intact.</span>
        <span class="n">new_flags</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flags</span>
        <span class="n">new_flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span>
            <span class="n">new_flags</span><span class="p">,</span> <span class="o">~</span><span class="n">new_flags</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">new_flags</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="n">sample_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="n">sample_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">individuals_population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">individuals_population</span><span class="p">[:]</span>
        <span class="n">samples_individual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">samples_individual</span><span class="p">[:]</span>
        <span class="n">individuals_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">individuals_time</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">sample_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">individual</span> <span class="o">=</span> <span class="n">samples_individual</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">individuals_time</span><span class="p">[</span><span class="n">individual</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">flags</span><span class="p">[</span><span class="n">sample_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span>
                    <span class="n">flags</span><span class="p">[</span><span class="n">sample_id</span><span class="p">],</span> <span class="n">constants</span><span class="o">.</span><span class="n">NODE_IS_HISTORICAL_SAMPLE</span>
                <span class="p">)</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">individuals_population</span><span class="p">[</span><span class="n">individual</span><span class="p">]</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">[</span><span class="n">sample_id</span><span class="p">],</span>
                <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="n">sample_id</span><span class="p">],</span>
                <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
                <span class="n">individual</span><span class="o">=</span><span class="n">num_ancestral_individuals</span> <span class="o">+</span> <span class="n">individual</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># Add in the remaining non-sample nodes.</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sample_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tsb</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">):</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding tree sequence edges&quot;</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">.</span><span class="n">dump_edges</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># We have no inference sites, so no edges have been estimated. To ensure</span>
            <span class="c1"># we have a rooted tree, we add in edges for each sample to an artificial</span>
            <span class="c1"># root.</span>
            <span class="k">assert</span> <span class="n">left</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">max_node_time</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">max_node_time</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ultimate</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">max_node_time</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span> <span class="n">ultimate</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">sample_id</span> <span class="ow">in</span> <span class="n">sample_ids</span><span class="p">:</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">sample_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
                <span class="n">left</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">left</span><span class="p">],</span>
                <span class="n">right</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">right</span><span class="p">],</span>
                <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sorting and building intermediate tree sequence.&quot;</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">sites_metadata_schema</span>
        <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">schema</span> <span class="o">=</span> <span class="n">add_to_schema</span><span class="p">(</span>
                <span class="n">schema</span><span class="p">,</span>
                <span class="s2">&quot;inference_type&quot;</span><span class="p">,</span>
                <span class="n">definition</span><span class="o">=</span><span class="n">inference_type_metadata_definition</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_inference_mutations</span><span class="p">(</span><span class="n">tables</span><span class="p">)</span>

        <span class="c1"># FIXME this is a shortcut. We should be computing the mutation parent above</span>
        <span class="c1"># during insertion (probably)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">build_index</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">compute_mutation_parents</span><span class="p">()</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Built samples tree sequence: </span><span class="si">{}</span><span class="s2"> nodes (</span><span class="si">{}</span><span class="s2"> pc); </span><span class="si">{}</span><span class="s2"> edges; &quot;</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> sites; </span><span class="si">{}</span><span class="s2"> mutations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span>
                <span class="n">num_pc_ancestors</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
        <span class="n">num_additional_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span>
        <span class="k">if</span> <span class="n">overlay_non_inference_sites</span> <span class="ow">and</span> <span class="n">num_additional_sites</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Mapping additional sites&quot;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">samples</span><span class="p">(),</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">insert_missing_sites</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variant_data</span><span class="p">,</span>
                <span class="n">ts</span><span class="p">,</span>
                <span class="n">sample_id_map</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_id_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())),</span>
                <span class="n">progress_monitor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">progress_monitor</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Skipping additional site mapping&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ts</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_augmented_ancestors_tree_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_indexes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ancestors tree sequence augmented with samples as extra ancestors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Building augmented ancestors tree sequence&quot;</span><span class="p">)</span>
        <span class="n">tsb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence_builder</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestors_ts_tables</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dict_schema</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">schema</span>
        <span class="k">assert</span> <span class="n">dict_schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">dict_schema</span> <span class="o">=</span> <span class="n">add_to_schema</span><span class="p">(</span>
            <span class="n">dict_schema</span><span class="p">,</span> <span class="s2">&quot;variant_data_id&quot;</span><span class="p">,</span> <span class="n">node_variant_data_id_metadata_definition</span>
        <span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="n">dict_schema</span><span class="p">)</span>

        <span class="n">flags</span><span class="p">,</span> <span class="n">times</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">.</span><span class="n">dump_nodes</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">num_pc_ancestors</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">flags</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">times</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="c1"># This is an augmented ancestor node.</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                    <span class="n">flags</span><span class="o">=</span><span class="n">constants</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE_ANCESTOR</span><span class="p">,</span>
                    <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;variant_data_id&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">[</span><span class="n">s</span><span class="p">])},</span>
                <span class="p">)</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This is a path compressed node</span>
                <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">time</span><span class="o">=</span><span class="n">times</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">assert</span> <span class="n">is_pc_ancestor</span><span class="p">(</span><span class="n">flags</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">num_pc_ancestors</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">s</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_indexes</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

        <span class="c1"># Increment the time for all nodes so the augmented samples are no longer</span>
        <span class="c1"># at timepoint 0.</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># TODO - check this works for augmented ancestors with missing data</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span> <span class="o">=</span> <span class="n">tsb</span><span class="o">.</span><span class="n">dump_edges</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="n">left</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">left</span><span class="p">],</span>
            <span class="n">right</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">position_map</span><span class="p">[</span><span class="n">right</span><span class="p">],</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
            <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convert_inference_mutations</span><span class="p">(</span><span class="n">tables</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sorting ancestors tree sequence&quot;</span><span class="p">)</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sorting ancestors tree sequence done&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Augmented ancestors tree sequence: </span><span class="si">{}</span><span class="s2"> nodes (</span><span class="si">{}</span><span class="s2"> extra pc ancestors); &quot;</span>
            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> edges; </span><span class="si">{}</span><span class="s2"> sites; </span><span class="si">{}</span><span class="s2"> mutations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span>
                <span class="n">num_pc_ancestors</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>


<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Path</span><span class="p">:</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">parent</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>


<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MatchResult</span><span class="p">:</span>
    <span class="n">node</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">path</span><span class="p">:</span> <span class="n">Path</span>
    <span class="n">mutations_site</span><span class="p">:</span> <span class="nb">list</span>
    <span class="n">mutations_derived_state</span><span class="p">:</span> <span class="nb">list</span>
    <span class="n">mean_traceback_size</span><span class="p">:</span> <span class="nb">int</span>


<span class="k">def</span><span class="w"> </span><span class="nf">has_single_edge_over_grand_root</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
    <span class="c1"># Internal function to check if this is a &quot;raw&quot; inferred tree sequence.</span>
    <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_edges</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># must have edge to grand root and above grand root</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">last_edge</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">last_edge</span><span class="o">.</span><span class="n">left</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">last_edge</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Not a single edge spanning the entire genome</span>
    <span class="k">if</span> <span class="n">ts</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span> <span class="o">==</span> <span class="n">last_edge</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># other edges point to the oldest node =&gt; not a virtual-like root</span>
    <span class="k">return</span> <span class="kc">True</span>


<span class="k">def</span><span class="w"> </span><span class="nf">has_same_root_everywhere</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
    <span class="n">roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">trees</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tree</span><span class="o">.</span><span class="n">has_single_root</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">roots</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="post_process">
<a class="viewcode-back" href="../../api.html#tsinfer.post_process">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">post_process</span><span class="p">(</span>
    <span class="n">ts</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">split_ultimate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">erase_flanks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="c1"># Parameters below deliberately undocumented</span>
    <span class="n">warn_if_unexpected_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">simplify_only</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    post_process(ts, *, split_ultimate=None, erase_flanks=None)</span>

<span class="sd">    Post-process a tsinferred tree sequence into a more conventional form. This is</span>
<span class="sd">    the function run by default on the final tree sequence output by</span>
<span class="sd">    :func:`match_samples`. It involves the following 4 steps:</span>

<span class="sd">    #. If the oldest node is connected to a single child via an edge that spans the</span>
<span class="sd">       entire tree sequence, this oldest node is removed, so that its child becomes</span>
<span class="sd">       the new root (this step is undertaken to remove the &quot;virtual-root-like node&quot;</span>
<span class="sd">       which is added to ancestor tree sequences to enable matching).</span>
<span class="sd">    #. If the oldest node is removed in the first step and the new root spans the</span>
<span class="sd">       entire genome, it is treated as the &quot;ultimate ancestor&quot; and (unless</span>
<span class="sd">       ``split_ultimate`` is ``False``) the node is split into multiple coexisiting</span>
<span class="sd">       nodes with the splits occurring whenever the children of the ultimate ancestor</span>
<span class="sd">       change. The rationale is that tsinfer creates a single ancestral haplotype with</span>
<span class="sd">       all inference sites in the ancestral state: this is, however, unlikely to</span>
<span class="sd">       represent a single ancestor in the past. If the tree sequence is then dated,</span>
<span class="sd">       the fact that ultimate ancestor is split into separate nodes allows these nodes</span>
<span class="sd">       to be dated to different times.</span>
<span class="sd">    #. Often, extensive regions of genome exist before the first defined site and after</span>
<span class="sd">       the last defined site. Since no data exists in these sections of the genome, post</span>
<span class="sd">       processing by default erases the inferred topology in these regions. However,</span>
<span class="sd">       if ``erase_flanks`` is False, the flanking regions at the start and end will be</span>
<span class="sd">       assigned the same topology as inferred at the first and last site respectively.</span>
<span class="sd">    #. The sample nodes are reordered such that they are the first nodes listed in the</span>
<span class="sd">       node table,  removing tree nodes and edges that are not on a path between the</span>
<span class="sd">       root and any of the samples (by applying the :meth:`~tskit.TreeSequence.simplify`</span>
<span class="sd">       method with ``keep_unary`` set to True but ``filter_sites``,</span>
<span class="sd">       ``filter_populations`` and ``filter_individuals`` set to False).</span>

<span class="sd">    :param bool split_ultimate: If ``True`` (default) and the oldest node is the only</span>
<span class="sd">        parent to a single &quot;ultimate ancestor&quot; node, attempt to split this node into</span>
<span class="sd">        many separate nodes (see above). If ``False`` do not attempt to identify or</span>
<span class="sd">        split an ultimate ancestor node.</span>
<span class="sd">    :param bool erase_flanks: If ``True`` (default), keep only the</span>
<span class="sd">        inferred topology between the first and last sites. If ``False``,</span>
<span class="sd">        output regions of topology inferred before the first site and after</span>
<span class="sd">        the last site.</span>
<span class="sd">    :return: The post-processed tree sequence.</span>
<span class="sd">    :rtype: tskit.TreeSequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">split_ultimate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">split_ultimate</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">erase_flanks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">erase_flanks</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">tables</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">simplify_only</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">has_single_edge_over_grand_root</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Removing the oldest edge to detach the virtual-root-like ancestor&quot;</span>
            <span class="p">)</span>
            <span class="n">last_edge</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Edge with oldest parent is last in the edge table</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># move any mutations above the virtual-root-like ancestor to above the</span>
            <span class="c1"># ultimate ancestor instead (these will be mutations placed by parsimony)</span>
            <span class="n">mutations_node</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">node</span>
            <span class="n">mutations_node</span><span class="p">[</span><span class="n">mutations_node</span> <span class="o">==</span> <span class="n">last_edge</span><span class="o">.</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_edge</span><span class="o">.</span><span class="n">child</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">mutations_node</span>

            <span class="k">if</span> <span class="n">split_ultimate</span><span class="p">:</span>
                <span class="n">split_ultimate_ancestor</span><span class="p">(</span><span class="n">tables</span><span class="p">,</span> <span class="n">warn_if_unexpected_format</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">warn_if_unexpected_format</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Cannot find a virtual-root-like ancestor during preprocessing&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">erase_flanks</span> <span class="ow">and</span> <span class="n">ts</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># So that the last site falls within a tree, we must add one to the</span>
            <span class="c1"># site position (or simply extend to the end of the ts)</span>
            <span class="n">keep_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">keep_intervals</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">ts</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">keep_max</span><span class="p">]],</span>
                <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">erased</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">-</span> <span class="n">keep_max</span>
            <span class="n">erased</span> <span class="o">*=</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Erased flanks covering </span><span class="si">{</span><span class="n">erased</span><span class="si">}</span><span class="s2">% of the genome: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ts</span><span class="o">.</span><span class="n">sites_position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> units at the start and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">keep_max</span><span class="si">}</span><span class="s2"> units at the end&quot;</span>
            <span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Simplifying with filter_sites=False, filter_populations=False, &quot;</span>
        <span class="s2">&quot;filter_individuals=False, and keep_unary=True on &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">num_rows</span><span class="si">}</span><span class="s2"> nodes and </span><span class="si">{</span><span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">num_rows</span><span class="si">}</span><span class="s2"> edges&quot;</span>
    <span class="p">)</span>
    <span class="c1"># NB: if this is an inferred TS, match_samples is guaranteed to produce samples</span>
    <span class="c1"># in the same order as passed in to sample_indexes, and simplification will</span>
    <span class="c1"># simply stick all those at the start but keep their order the same</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
        <span class="n">filter_sites</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_populations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_individuals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_unary</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Finished simplify; now have </span><span class="si">{}</span><span class="s2"> nodes and </span><span class="si">{}</span><span class="s2"> edges&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">num_rows</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_post_process</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">post_process</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">split_ultimate_ancestor</span><span class="p">(</span><span class="n">tables</span><span class="p">,</span> <span class="n">warn_if_unexpected_format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># Internal function: if a single oldest node is a root across the entire genome,</span>
    <span class="c1"># split it up into a set of contemporaneous nodes whenever the node children change</span>

    <span class="n">ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">has_same_root_everywhere</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">warn_if_unexpected_format</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot find a single contiguous ultimate ancestor to split&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Split into multiple contemporaneous nodes whenever the node children change</span>
    <span class="n">genomewide_ultimate_ancestor_id</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span>
    <span class="n">genomewide_ultimate_ancestor</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">genomewide_ultimate_ancestor_id</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Located the all zeros ultimate ancestor&quot;</span><span class="p">)</span>
    <span class="n">root_breaks</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">edges</span>
    <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># the last edges are the ones connecting to the genomewide UA</span>
    <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span> <span class="o">==</span> <span class="n">genomewide_ultimate_ancestor_id</span><span class="p">:</span>
        <span class="n">root_breaks</span> <span class="o">|=</span> <span class="p">{</span><span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">right</span><span class="p">}</span>
        <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">root_breaks</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">root_breaks</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">root_breaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">root_breaks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
        <span class="c1"># Only a single edge: no splitting needed</span>
        <span class="k">return</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Splitting ultimate ancestor into </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">root_breaks</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> nodes&quot;</span><span class="p">)</span>
    <span class="c1"># detach the ultimate ancestor from all its children, so it can be simplified out</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Move the mutations above the ultimate ancestor to the new nodes</span>
    <span class="n">mutation_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">genomewide_ultimate_ancestor_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mutation_positions</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">site</span><span class="p">[</span><span class="n">mutation_ids</span><span class="p">]]</span>
    <span class="n">mut_iter</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mutation_ids</span><span class="p">,</span> <span class="n">mutation_positions</span><span class="p">)</span>
    <span class="n">mutation_id</span><span class="p">,</span> <span class="n">mutation_pos</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">mut_iter</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">))</span>

    <span class="c1"># Go through the trees, making a new root node whereever we hit a root_break</span>
    <span class="c1"># and recreating the edges to the children each time</span>
    <span class="n">trees_iter</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">trees</span><span class="p">()</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees_iter</span><span class="p">)</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">root_breaks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">root_breaks</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">while</span> <span class="n">tree</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees_iter</span><span class="p">)</span>
        <span class="n">new_root</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">genomewide_ultimate_ancestor</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">genomewide_ultimate_ancestor_id</span><span class="p">):</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="n">new_root</span><span class="p">,</span> <span class="n">child</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">mutation_pos</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">mutations</span><span class="p">[</span><span class="n">mutation_id</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="n">node</span><span class="o">=</span><span class="n">new_root</span>
            <span class="p">)</span>
            <span class="n">mutation_id</span><span class="p">,</span> <span class="n">mutation_pos</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">mut_iter</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">ts</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">))</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">right</span>
    <span class="n">tables</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">minimise</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a tree sequence with the minimal information required to represent</span>
<span class="sd">    the tree topologies at its sites.</span>

<span class="sd">    This is a convenience function used when we wish to use a subset of the</span>
<span class="sd">    sites in a tree sequence for ancestor matching. It is a thin-wrapper</span>
<span class="sd">    over the simplify method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ts</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
        <span class="n">reduce_to_site_topology</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">filter_sites</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_individuals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_populations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Tskit Developers
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2018.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>