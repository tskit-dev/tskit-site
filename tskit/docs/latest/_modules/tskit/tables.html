
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tskit.tables &#8212; Tskit manual</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=9c3e77be" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/bespoke.css?v=00f581dd" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=1ae7504c"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/tskit/tables';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <script data-goatcounter="https://tskit.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../introduction.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.svg" class="logo__image only-light" alt=""/>
    <script>document.write(`<img src="../../_static/logo.svg" class="logo__image only-dark" alt=""/>`);</script>
  
  
    <p class="title logo__title">Version 1.0.2.dev1</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Concepts</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data-model.html">Data model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../provenance.html">Provenance</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Analysis</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../stats.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../topological-analysis.html">Topological analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ibd.html">Identity by descent</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../export.html">Data export</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Interfaces</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../python-api.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../numba.html">Numba Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../c-api.html">C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../file-formats.html">File formats</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">For developers</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelogs.html">Changelogs</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Miscellaneous</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../citation.html">Citing tskit</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/tskit-dev/tskit" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/tskit-dev/tskit/issues/new?title=Issue%20on%20page%20%2F_modules/tskit/tables.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for tskit.tables</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># MIT License</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2018-2024 Tskit Developers</span>
<span class="c1"># Copyright (c) 2017 University of Oxford</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="c1"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="c1"># in the Software without restriction, including without limitation the rights</span>
<span class="c1"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="c1"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="c1"># furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in all</span>
<span class="c1"># copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c1"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c1"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c1"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c1"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="c1"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="c1"># SOFTWARE.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Tree sequence IO via the tables API.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dataclasses</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numbers</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">_tskit</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit.metadata</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">metadata</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit.provenance</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">provenance</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit.util</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">util</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tskit</span><span class="w"> </span><span class="kn">import</span> <span class="n">UNKNOWN_TIME</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tskit.exceptions</span><span class="w"> </span><span class="kn">import</span> <span class="n">ImmutableTableError</span>

<span class="n">dataclass_options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;frozen&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ragged_selection_indices</span><span class="p">(</span><span class="n">indexed_offsets</span><span class="p">,</span> <span class="n">lengths64</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return absolute indices into a ragged column for the provided row selection.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lengths64</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">total</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">row_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">lengths64</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="n">lengths64</span><span class="p">)</span>
    <span class="n">start_offsets</span> <span class="o">=</span> <span class="n">indexed_offsets</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="n">row_ids</span><span class="p">]</span>
    <span class="n">within_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lengths64</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">-</span> <span class="n">lengths64</span><span class="p">,</span> <span class="n">lengths64</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">start_offsets</span> <span class="o">+</span> <span class="n">within_row</span>


<div class="viewcode-block" id="IndividualTableRow">
<a class="viewcode-back" href="../../python-api.html#tskit.IndividualTableRow">[docs]</a>
<span class="nd">@metadata</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">()</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="o">**</span><span class="n">dataclass_options</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">IndividualTableRow</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A row in an :class:`IndividualTable`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;flags&quot;</span><span class="p">,</span> <span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;parents&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
    <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Individual.flags`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">location</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Individual.location`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parents</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Individual.parents`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Individual.metadata`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># We need a custom eq for the numpy arrays</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">IndividualTableRow</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">flags</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">location</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">metadata</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="NodeTableRow">
<a class="viewcode-back" href="../../python-api.html#tskit.NodeTableRow">[docs]</a>
<span class="nd">@metadata</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">()</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="o">**</span><span class="n">dataclass_options</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NodeTableRow</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A row in a :class:`NodeTable`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;flags&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;population&quot;</span><span class="p">,</span> <span class="s2">&quot;individual&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
    <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Node.flags`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Node.time`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">population</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Node.population`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">individual</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Node.individual`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Node.metadata`</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="EdgeTableRow">
<a class="viewcode-back" href="../../python-api.html#tskit.EdgeTableRow">[docs]</a>
<span class="nd">@metadata</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">()</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="o">**</span><span class="n">dataclass_options</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">EdgeTableRow</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A row in an :class:`EdgeTable`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="s2">&quot;child&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
    <span class="n">left</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Edge.left`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">right</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Edge.right`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parent</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Edge.parent`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">child</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Edge.child`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Edge.metadata`</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="MigrationTableRow">
<a class="viewcode-back" href="../../python-api.html#tskit.MigrationTableRow">[docs]</a>
<span class="nd">@metadata</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">()</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="o">**</span><span class="n">dataclass_options</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MigrationTableRow</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A row in a :class:`MigrationTable`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;node&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;dest&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
    <span class="n">left</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Migration.left`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">right</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Migration.right`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">node</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Migration.node`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">source</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Migration.source`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dest</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Migration.dest`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Migration.time`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Migration.metadata`</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="SiteTableRow">
<a class="viewcode-back" href="../../python-api.html#tskit.SiteTableRow">[docs]</a>
<span class="nd">@metadata</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">()</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="o">**</span><span class="n">dataclass_options</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SiteTableRow</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A row in a :class:`SiteTable`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="s2">&quot;ancestral_state&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
    <span class="n">position</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Site.position`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ancestral_state</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Site.ancestral_state`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Site.metadata`</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="MutationTableRow">
<a class="viewcode-back" href="../../python-api.html#tskit.MutationTableRow">[docs]</a>
<span class="nd">@metadata</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">()</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="o">**</span><span class="n">dataclass_options</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MutationTableRow</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A row in a :class:`MutationTable`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="s2">&quot;node&quot;</span><span class="p">,</span> <span class="s2">&quot;derived_state&quot;</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">]</span>
    <span class="n">site</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Mutation.site`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">node</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Mutation.node`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">derived_state</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Mutation.derived_state`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parent</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Mutation.parent`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Mutation.metadata`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Mutation.time`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># We need a custom eq here as we have unknown times (nans) to check</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MutationTableRow</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">site</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">site</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">node</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_state</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">derived_state</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">parent</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">metadata</span>
            <span class="ow">and</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span>
                <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">util</span><span class="o">.</span><span class="n">is_unknown_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="ow">and</span> <span class="n">util</span><span class="o">.</span><span class="n">is_unknown_time</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="PopulationTableRow">
<a class="viewcode-back" href="../../python-api.html#tskit.PopulationTableRow">[docs]</a>
<span class="nd">@metadata</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">()</span>
<span class="nd">@dataclass</span><span class="p">(</span><span class="o">**</span><span class="n">dataclass_options</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PopulationTableRow</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A row in a :class:`PopulationTable`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Population.metadata`</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="ProvenanceTableRow">
<a class="viewcode-back" href="../../python-api.html#tskit.ProvenanceTableRow">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="o">**</span><span class="n">dataclass_options</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ProvenanceTableRow</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A row in a :class:`ProvenanceTable`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;timestamp&quot;</span><span class="p">,</span> <span class="s2">&quot;record&quot;</span><span class="p">]</span>
    <span class="n">timestamp</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Provenance.timestamp`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">record</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See :attr:`Provenance.record`</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="TableCollectionIndexes">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollectionIndexes">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="o">**</span><span class="n">dataclass_options</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TableCollectionIndexes</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class encapsulating the indexes of a :class:`TableCollection`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">edge_insertion_order</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">edge_removal_order</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="TableCollectionIndexes.asdict">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollectionIndexes.asdict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of bytes taken by the indexes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_removal_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_removal_order</span><span class="o">.</span><span class="n">nbytes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_insertion_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_insertion_order</span><span class="o">.</span><span class="n">nbytes</span>
        <span class="k">return</span> <span class="n">total</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">keep_with_offset</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used when filtering _offset columns in tables</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We need the astype here for 32 bit machines</span>
    <span class="n">lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">lens</span><span class="p">)],</span>
        <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">offset</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lens</span><span class="p">[</span><span class="n">keep</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">offset</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">),</span>
    <span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">BaseTable</span><span class="p">:</span>
    <span class="c1"># Base class for all tables, with only immutable methods,</span>
    <span class="c1"># or those that don&#39;t use separate low-level table implementations.</span>

    <span class="c1"># The list of columns in the table. Must be set by subclasses.</span>
    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mutable</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_required_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> is required&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total number of bytes required to store the data</span>
<span class="sd">        in this table. Note that this may not be equal to</span>
<span class="sd">        the actual memory footprint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># It&#39;s not ideal that we run asdict() here to do this as we&#39;re</span>
        <span class="c1"># currently creating copies of the column arrays, so it would</span>
        <span class="c1"># be more efficient to have dedicated low-level methods. However,</span>
        <span class="c1"># if we do have read-only views on the underlying memory for the</span>
        <span class="c1"># column arrays then this will be a perfectly good way of</span>
        <span class="c1"># computing the nbytes values and the overhead minimal.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="n">nbytes</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Some tables don&#39;t have a metadata_schema</span>
        <span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;metadata_schema&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">metadata_schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nbytes</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
        <span class="n">nbytes</span> <span class="o">+=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">nbytes</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">nbytes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_equals_internal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseTable</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_name</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">table_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Can only use mutable fast path if both tables are mutable</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutable</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">mutable</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">other</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">base</span><span class="o">.</span><span class="n">_fast_equals</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if  `self` and `other` are equal. By default, two tables</span>
<span class="sd">        are considered equal if their columns and metadata schemas are</span>
<span class="sd">        byte-for-byte identical.</span>

<span class="sd">        :param other: Another table instance</span>
<span class="sd">        :param bool ignore_metadata: If True exclude metadata and metadata schemas</span>
<span class="sd">            from the comparison.</span>
<span class="sd">        :return: True if other is equal to this table; False otherwise.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equals_internal</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assert_equals_internal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BaseTable</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_name</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">table_name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Types differ: self=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> other=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equals_internal</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assert_equals</span><span class="p">(</span>
                <span class="n">other</span><span class="p">,</span>
                <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">,</span>
                <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">assert_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise an AssertionError for the first found difference between</span>
<span class="sd">        this and another table of the same type.</span>

<span class="sd">        :param other: Another table instance</span>
<span class="sd">        :param bool ignore_metadata: If True exclude metadata and metadata schemas</span>
<span class="sd">            from the comparison.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_equals_internal</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_assert_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">ignore_metadata</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;metadata_schema&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;metadata_schema&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">metadata_schema</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> metadata schemas differ: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;self=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;other=</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">metadata_schema</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">row_self</span><span class="p">,</span> <span class="n">row_other</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ignore_metadata</span><span class="p">:</span>
                <span class="n">row_self</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">row_self</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">row_other</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">row_other</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ignore_timestamps</span><span class="p">:</span>
                <span class="n">row_self</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">row_self</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">row_other</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">row_other</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">row_self</span> <span class="o">!=</span> <span class="n">row_other</span><span class="p">:</span>
                <span class="n">self_dict</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                <span class="n">other_dict</span> <span class="o">=</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
                <span class="n">diff_string</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">self_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">ignore_timestamps</span> <span class="ow">and</span> <span class="n">col</span> <span class="o">==</span> <span class="s2">&quot;timestamp&quot;</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">self_dict</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                        <span class="n">equal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">self_dict</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">other_dict</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">equal</span> <span class="o">=</span> <span class="n">self_dict</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">other_dict</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">equal</span><span class="p">:</span>
                        <span class="n">diff_string</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;self.</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">self_dict</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="si">}</span><span class="s2"> other.</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">other_dict</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                <span class="n">diff_string</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">diff_string</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> row </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> differs:</span><span class="se">\n</span><span class="si">{</span><span class="n">diff_string</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> number of rows differ: self=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;other=</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">num_rows</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># We can reach this point if the metadata schemas byte representations</span>
        <span class="c1"># differ when the decoded schema is the same</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">ignore_metadata</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ll_table&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;ll_table&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">metadata_schema</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">metadata_schema</span>
        <span class="p">):</span>
            <span class="k">return</span>

        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
            <span class="s2">&quot;Tables differ in an undetected way - &quot;</span>
            <span class="s2">&quot;this is a bug, please report an issue on github&quot;</span>
        <span class="p">)</span>  <span class="c1"># pragma: no cover</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary mapping the names of the columns in this table</span>
<span class="sd">        to the corresponding numpy arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span><span class="p">}</span>
        <span class="c1"># Not all tables have metadata</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span><span class="p">[</span><span class="s2">&quot;metadata_schema&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">headers</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text_header_and_rows</span><span class="p">(</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">tskit</span><span class="o">.</span><span class="n">_print_options</span><span class="p">[</span><span class="s2">&quot;max_lines&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">unicode_table</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">headers</span><span class="p">,</span> <span class="n">row_separator</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called e.g. by jupyter notebooks to render tables</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">headers</span><span class="p">,</span> <span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text_header_and_rows</span><span class="p">(</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">tskit</span><span class="o">.</span><span class="n">_print_options</span><span class="p">[</span><span class="s2">&quot;max_lines&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">html_table</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">headers</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_columns_all_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">colnames</span><span class="p">):</span>
        <span class="c1"># For displaying floating point values without loads of decimal places</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">colnames</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_text_header_and_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns headers and rows for table display.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate headers: &quot;id&quot; + column names (excluding offset columns)</span>
        <span class="n">display_columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">col</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;_offset&quot;</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">display_columns</span><span class="p">)</span>

        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">row_indexes</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">truncate_rows</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

        <span class="n">float_columns</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">display_columns</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
                <span class="n">float_columns</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns_all_integer</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">else</span> <span class="mi">8</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">row_indexes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;__skipped__</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">limit</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">formatted_values</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">j</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>  <span class="c1"># ID column</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">display_columns</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="s2">&quot;metadata&quot;</span><span class="p">:</span>
                        <span class="n">formatted_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">render_metadata</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;parents&quot;</span><span class="p">]:</span>
                        <span class="c1"># Array columns - join with commas</span>
                        <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="s2">&quot;parents&quot;</span><span class="p">:</span>
                            <span class="n">formatted_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">value</span><span class="p">])</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">formatted_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">)))</span>
                    <span class="k">elif</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">float_columns</span><span class="p">:</span>
                        <span class="n">dp</span> <span class="o">=</span> <span class="n">float_columns</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                        <span class="n">formatted_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="s2">,.</span><span class="si">{</span><span class="n">dp</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
                        <span class="n">formatted_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="s2">,</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">formatted_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">formatted_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">headers</span><span class="p">,</span> <span class="n">rows</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_assert_table_collections_equal</span><span class="p">(</span>
    <span class="n">tc1</span><span class="p">,</span>
    <span class="n">tc2</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">ignore_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">ignore_reference_sequence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">ignore_tables</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="c1"># This is shared between TableCollection and ImmutableTableCollection,</span>
    <span class="c1"># could go in a base class, but there&#39;s not much else in common</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ignore_metadata</span> <span class="ow">or</span> <span class="n">ignore_ts_metadata</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tc1</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">!=</span> <span class="n">tc2</span><span class="o">.</span><span class="n">metadata_schema</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Metadata schemas differ: self=</span><span class="si">{</span><span class="n">tc1</span><span class="o">.</span><span class="n">metadata_schema</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;other=</span><span class="si">{</span><span class="n">tc2</span><span class="o">.</span><span class="n">metadata_schema</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">tc1</span><span class="o">.</span><span class="n">metadata</span> <span class="o">!=</span> <span class="n">tc2</span><span class="o">.</span><span class="n">metadata</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Metadata differs: self=</span><span class="si">{</span><span class="n">tc1</span><span class="o">.</span><span class="n">metadata</span><span class="si">}</span><span class="s2"> other=</span><span class="si">{</span><span class="n">tc2</span><span class="o">.</span><span class="n">metadata</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_reference_sequence</span><span class="p">:</span>
        <span class="n">tc1</span><span class="o">.</span><span class="n">reference_sequence</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span>
            <span class="n">tc2</span><span class="o">.</span><span class="n">reference_sequence</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">tc1</span><span class="o">.</span><span class="n">time_units</span> <span class="o">!=</span> <span class="n">tc2</span><span class="o">.</span><span class="n">time_units</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Time units differs: self=</span><span class="si">{</span><span class="n">tc1</span><span class="o">.</span><span class="n">time_units</span><span class="si">}</span><span class="s2"> other=</span><span class="si">{</span><span class="n">tc2</span><span class="o">.</span><span class="n">time_units</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">tc1</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">tc2</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Sequence Length differs: self=</span><span class="si">{</span><span class="n">tc1</span><span class="o">.</span><span class="n">sequence_length</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;other=</span><span class="si">{</span><span class="n">tc2</span><span class="o">.</span><span class="n">sequence_length</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_tables</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">table_name</span><span class="p">,</span> <span class="n">table</span> <span class="ow">in</span> <span class="n">tc1</span><span class="o">.</span><span class="n">table_name_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">table_name</span> <span class="o">==</span> <span class="s2">&quot;provenances&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">other_table</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tc2</span><span class="p">,</span> <span class="n">table_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">ImmutableBaseTable</span><span class="p">):</span>
                <span class="n">table</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span><span class="n">other_table</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_table</span><span class="p">,</span> <span class="n">ImmutableBaseTable</span><span class="p">):</span>
                <span class="n">other_table</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">table</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span><span class="n">other_table</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_provenance</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_tables</span><span class="p">:</span>
        <span class="n">prov1</span> <span class="o">=</span> <span class="n">tc1</span><span class="o">.</span><span class="n">provenances</span>
        <span class="n">prov2</span> <span class="o">=</span> <span class="n">tc2</span><span class="o">.</span><span class="n">provenances</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prov1</span><span class="p">,</span> <span class="n">ImmutableProvenanceTable</span><span class="p">):</span>
            <span class="n">prov1</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span><span class="n">prov2</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prov2</span><span class="p">,</span> <span class="n">ImmutableProvenanceTable</span><span class="p">):</span>
            <span class="n">prov2</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span><span class="n">prov1</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prov1</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span><span class="n">prov2</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="ow">not</span> <span class="n">ignore_metadata</span>
        <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tc1</span><span class="p">,</span> <span class="s2">&quot;_ll_object&quot;</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tc2</span><span class="p">,</span> <span class="s2">&quot;_ll_object&quot;</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tc1</span><span class="o">.</span><span class="n">_ll_object</span><span class="p">,</span> <span class="s2">&quot;metadata_schema&quot;</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tc2</span><span class="o">.</span><span class="n">_ll_object</span><span class="p">,</span> <span class="s2">&quot;metadata_schema&quot;</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">tc1</span><span class="o">.</span><span class="n">_ll_object</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">!=</span> <span class="n">tc2</span><span class="o">.</span><span class="n">_ll_object</span><span class="o">.</span><span class="n">metadata_schema</span>
        <span class="ow">and</span> <span class="n">tc1</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">==</span> <span class="n">tc2</span><span class="o">.</span><span class="n">metadata_schema</span>
    <span class="p">):</span>
        <span class="c1"># Schemas differ in byte representation but are equivalent when decoded</span>
        <span class="k">return</span>

    <span class="c1"># If we reach here, all comparisons matched; treat collections as equal.</span>
    <span class="k">return</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MutableBaseTable</span><span class="p">(</span><span class="n">BaseTable</span><span class="p">):</span>
    <span class="c1"># Abstract base class for mutable tables that use the low-level table implementation.</span>

    <span class="n">mutable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ll_table</span><span class="p">,</span> <span class="n">row_class</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span> <span class="o">=</span> <span class="n">ll_table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_class</span> <span class="o">=</span> <span class="n">row_class</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fast_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">ll_table</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">}</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">num_rows</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">max_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">max_rows</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">max_rows_increment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">max_rows_increment</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> object has no attribute </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
            <span class="n">d</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_make_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_class</span><span class="p">(</span>
                <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">decode_row</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_class</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If passed an integer, return the specified row of this table, decoding metadata</span>
<span class="sd">        if it is present. Supports negative indexing, e.g. ``table[-5]``.</span>
<span class="sd">        If passed a slice, iterable or array return a new table containing the specified</span>
<span class="sd">        rows. Similar to numpy fancy indexing, if the array or iterables contains</span>
<span class="sd">        booleans then the index acts as a mask, returning those rows for which the mask</span>
<span class="sd">        is True. Note that as the result is a new table, the row ids will change as tskit</span>
<span class="sd">        row ids are row indexes.</span>

<span class="sd">        :param index: the index of a desired row, a slice of the desired rows, an</span>
<span class="sd">            iterable or array of the desired row numbers, or a boolean array to use as</span>
<span class="sd">            a mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># Single row by integer</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of bounds&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_row</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">get_row</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Index must be integer, slice or iterable&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">index</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Boolean index must be same length as table&quot;</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        <span class="c1"># Not all tables have metadata schemas; guard access</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="p">,</span> <span class="n">row_indexes</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">new_row</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces a row of this table at the specified index with information from a</span>
<span class="sd">        row-like object. Metadata, will be validated and encoded according to the table&#39;s</span>
<span class="sd">        :attr:`metadata_schema&lt;tskit.IndividualTable.metadata_schema&gt;`.</span>

<span class="sd">        :param index: the index of the row to change</span>
<span class="sd">        :param row-like new_row: An object that has attributes corresponding to the</span>
<span class="sd">            properties of the new row. Both the objects returned from ``table[i]`` and</span>
<span class="sd">            e.g. ``ts.individual(i)`` work for this purpose, along with any other</span>
<span class="sd">            object with the correct attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># Single row by integer</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of bounds&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Index must be integer&quot;</span><span class="p">)</span>

        <span class="n">row_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">column</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">new_row</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span>
            <span class="k">if</span> <span class="s2">&quot;_offset&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">column</span>
        <span class="p">}</span>

        <span class="c1"># Encode the metadata - note that if this becomes a perf bottleneck it is</span>
        <span class="c1"># possible to use the cached, encoded metadata in the row object, rather than</span>
        <span class="c1"># decode and reencode</span>
        <span class="k">if</span> <span class="s2">&quot;metadata&quot;</span> <span class="ow">in</span> <span class="n">row_data</span><span class="p">:</span>
            <span class="n">row_data</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">validate_and_encode_row</span><span class="p">(</span>
                <span class="n">row_data</span><span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">update_row</span><span class="p">(</span><span class="n">row_index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">row_data</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new row to this table and returns the ID of the new row. Metadata, if</span>
<span class="sd">        specified, will be validated and encoded according to the table&#39;s</span>
<span class="sd">        :attr:`metadata_schema&lt;tskit.IndividualTable.metadata_schema&gt;`.</span>

<span class="sd">        :param row-like row: An object that has attributes corresponding to the</span>
<span class="sd">            properties of the new row. Both the objects returned from ``table[i]`` and</span>
<span class="sd">            e.g. ``ts.individual(i)`` work for this purpose, along with any other</span>
<span class="sd">            object with the correct attributes.</span>
<span class="sd">        :return: The index of the newly added row.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="n">column</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span>
                <span class="k">if</span> <span class="s2">&quot;_offset&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">column</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">replace_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Overwrite the contents of this table with a copy of the other table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="o">**</span><span class="n">other</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes all rows in this table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for clear</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Truncates this table so that the only the first ``num_rows`` are retained.</span>

<span class="sd">        :param int num_rows: The number of rows to retain in this table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="n">num_rows</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">keep_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. include:: substitutions/table_keep_rows_main.rst</span>

<span class="sd">        :param array-like keep: The rows to keep as a boolean array. Must</span>
<span class="sd">            be the same length as the table, and convertible to a numpy</span>
<span class="sd">            array of dtype bool.</span>
<span class="sd">        :return: The mapping between old and new row IDs as a numpy</span>
<span class="sd">            array (dtype int32).</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We do this check here rather than in the C code because calling</span>
        <span class="c1"># len() on the input will cause a more readable exception to be</span>
        <span class="c1"># raised than the inscrutable errors we get from numpy when</span>
        <span class="c1"># converting arguments of the wrong type.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Argument for keep_rows must be a boolean array of &quot;</span>
                <span class="s2">&quot;the same length as the table. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(need:</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">, got:</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">keep_rows</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span>

    <span class="c1"># Pickle support</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>

    <span class="c1"># Unpickle support</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="o">**</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a deep copy of this table</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        <span class="n">copy</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">copy</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the values for each column in this :class:`Table` using values</span>
<span class="sd">        provided in numpy arrays. Overwrites existing data in all the table columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ImmutableBaseTable</span><span class="p">(</span><span class="n">BaseTable</span><span class="p">):</span>
    <span class="c1"># List of all mutation methods that should give a nice error</span>
    <span class="n">_MUTATION_METHODS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;add_row&quot;</span><span class="p">,</span>
        <span class="s2">&quot;clear&quot;</span><span class="p">,</span>
        <span class="s2">&quot;set_columns&quot;</span><span class="p">,</span>
        <span class="s2">&quot;truncate&quot;</span><span class="p">,</span>
        <span class="s2">&quot;replace_with&quot;</span><span class="p">,</span>
        <span class="s2">&quot;append_columns&quot;</span><span class="p">,</span>
        <span class="s2">&quot;keep_rows&quot;</span><span class="p">,</span>
        <span class="s2">&quot;append&quot;</span><span class="p">,</span>
        <span class="s2">&quot;reset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;drop_metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;packset_metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;packset_location&quot;</span><span class="p">,</span>
        <span class="s2">&quot;packset_parents&quot;</span><span class="p">,</span>
        <span class="s2">&quot;packset_ancestral_state&quot;</span><span class="p">,</span>
        <span class="s2">&quot;packset_derived_state&quot;</span><span class="p">,</span>
        <span class="s2">&quot;packset_record&quot;</span><span class="p">,</span>
        <span class="s2">&quot;packset_timestamp&quot;</span><span class="p">,</span>
        <span class="s2">&quot;squash&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">mutable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># These are set by subclasses.</span>
    <span class="n">_row_field_indices</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">table_name</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mutable_class</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ll_tree_sequence</span><span class="p">,</span> <span class="n">row_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">row_slice</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_initialised&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span> <span class="o">=</span> <span class="n">ll_tree_sequence</span>
        <span class="n">singular_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_name</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">row_class</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">singular_name</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span><span class="si">}</span><span class="s2">TableRow&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_row_getter</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;get_</span><span class="si">{</span><span class="n">singular_name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_column_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">column_names</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_row_indices</span> <span class="o">=</span> <span class="n">row_indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span> <span class="o">=</span> <span class="n">row_slice</span>
        <span class="k">if</span> <span class="n">row_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">row_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;get_num_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">table_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">row_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">row_slice</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span> <span class="o">=</span> <span class="n">row_slice</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_indices</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_initialised&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a mutable deep copy of this ImmutableTableCollection.</span>

<span class="sd">        :return: A deep copy of this ImmutableTableCollection.</span>
<span class="sd">        :rtype: tskit.TableCollection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mutable_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutable_class</span><span class="p">()</span>
        <span class="n">column_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="n">mutable_table</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="o">**</span><span class="n">column_data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mutable_table</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">row_factory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_row_object</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ll_index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_indices</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">row_factory</span><span class="p">(</span><span class="n">ll_index</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span><span class="o">.</span><span class="n">start</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span><span class="o">.</span><span class="n">stop</span>
        <span class="k">for</span> <span class="n">ll_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">row_factory</span><span class="p">(</span><span class="n">ll_index</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fast_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">ignore_metadata</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;metadata_schema&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;metadata_schema&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">metadata_schema</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ignore_metadata</span> <span class="ow">and</span> <span class="n">column_name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">ignore_timestamps</span>
                <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;table_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;provenances&quot;</span>
                <span class="ow">and</span> <span class="n">column_name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;timestamp&quot;</span><span class="p">,</span> <span class="s2">&quot;timestamp_offset&quot;</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column_name</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">column_name</span><span class="p">),</span> <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># Handle attribute access. This method is only called when an attribute</span>
        <span class="c1"># is not found through normal lookup, so we can lazily calculate column</span>
        <span class="c1"># contents.</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_column_names</span><span class="p">:</span>
            <span class="n">full_array</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">table_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># TableCollection methods use the LWT code, which is stuck returning</span>
            <span class="c1"># int8 for compatibility see https://github.com/tskit-dev/tskit/issues/3284</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;metadata&quot;</span><span class="p">:</span>
                <span class="n">full_array</span> <span class="o">=</span> <span class="n">full_array</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_row_indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">is_offset</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;_offset&quot;</span><span class="p">)</span>
                <span class="n">is_ragged</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_offset&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_column_names</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">subset_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_column</span><span class="p">(</span>
                        <span class="n">full_array</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">is_offset</span><span class="p">,</span> <span class="n">is_ragged</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">subset_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_column</span><span class="p">(</span>
                        <span class="n">full_array</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">is_offset</span><span class="p">,</span> <span class="n">is_ragged</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subset_array</span> <span class="o">=</span> <span class="n">full_array</span>
            <span class="c1"># Store the result, so on the next access we don&#39;t need to calculate it again</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">subset_array</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">subset_array</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MUTATION_METHODS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ImmutableTableError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot call </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">() on immutable </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">table_name</span><span class="si">}</span><span class="s2"> table. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Use TreeSequence.dump_tables() for mutable copy.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If it&#39;s not a blocked method or column, delegate to parent classes</span>
        <span class="c1"># This allows metadata mixins to handle metadata_schema and other attributes</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_slice_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_array</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">is_offset</span><span class="p">,</span> <span class="n">is_ragged</span><span class="p">):</span>
        <span class="n">row_slice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">row_slice</span><span class="o">.</span><span class="n">start</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">row_slice</span><span class="o">.</span><span class="n">stop</span>
        <span class="k">if</span> <span class="n">is_offset</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">full_array</span><span class="p">[</span><span class="n">start</span> <span class="p">:</span> <span class="n">stop</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">is_ragged</span><span class="p">:</span>
            <span class="n">offset_array</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">table_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_offset&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">full_array</span><span class="p">[</span><span class="n">offset_array</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="p">:</span> <span class="n">offset_array</span><span class="p">[</span><span class="n">stop</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">full_array</span><span class="p">[</span><span class="n">row_slice</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_select_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_array</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">is_offset</span><span class="p">,</span> <span class="n">is_ragged</span><span class="p">):</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_indices</span>
        <span class="k">if</span> <span class="n">is_ragged</span><span class="p">:</span>
            <span class="n">ragged</span><span class="p">,</span> <span class="n">offsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_column_ragged</span><span class="p">(</span><span class="n">full_array</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
            <span class="c1"># We calculated _offset, so might as well store it so it doesn&#39;t</span>
            <span class="c1"># need to be recalculated if accessed</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_offset&quot;</span><span class="p">,</span> <span class="n">offsets</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ragged</span>
        <span class="k">elif</span> <span class="n">is_offset</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_column_offset</span><span class="p">(</span><span class="n">full_array</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">full_array</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_select_column_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset_array</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">offset_array</span><span class="p">[</span><span class="n">indices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset_array</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">lengths</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">offset_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">lengths</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lengths</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">offset_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_select_column_ragged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_array</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="n">offset_array</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">table_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_offset&quot;</span><span class="p">)</span>
        <span class="n">indexed_offsets</span> <span class="o">=</span> <span class="n">offset_array</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">lengths64</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset_array</span><span class="p">[</span><span class="n">indices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">indexed_offsets</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">_ragged_selection_indices</span><span class="p">(</span><span class="n">indexed_offsets</span><span class="p">,</span> <span class="n">lengths64</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">full_array</span><span class="p">[</span><span class="n">gather_indices</span><span class="p">]</span>
        <span class="n">offsets_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_column_offset</span><span class="p">(</span><span class="n">offset_array</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">offsets_result</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">row_index</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">selector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_selector</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="p">,</span> <span class="n">row_slice</span><span class="o">=</span><span class="n">selector</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="p">,</span> <span class="n">row_indices</span><span class="o">=</span><span class="n">selector</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">row_index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">row_index</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span>
        <span class="k">if</span> <span class="n">row_index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">row_index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of bounds&quot;</span><span class="p">)</span>
        <span class="n">ll_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_single_index</span><span class="p">(</span><span class="n">row_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_row_object</span><span class="p">(</span><span class="n">ll_index</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_current_ll_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span><span class="o">.</span><span class="n">start</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span><span class="o">.</span><span class="n">stop</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_row_indices</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_resolve_single_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_index</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base_start</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span><span class="o">.</span><span class="n">start</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">base_start</span> <span class="o">+</span> <span class="n">row_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_row_indices</span><span class="p">[</span><span class="n">row_index</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_resolve_selector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">step</span> <span class="ow">or</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">)</span>
                <span class="n">base_start</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_slice</span><span class="o">.</span><span class="n">start</span>
                <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">base_start</span> <span class="o">+</span> <span class="n">start</span><span class="p">,</span> <span class="n">base_start</span> <span class="o">+</span> <span class="n">stop</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
            <span class="n">selector</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">selector</span><span class="p">]</span>

        <span class="n">selector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">selector</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Boolean index must be same length as table&quot;</span><span class="p">)</span>
            <span class="n">selector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">selector</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">selector</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="n">ll_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_ll_indices</span><span class="p">()</span>
        <span class="n">resolved</span> <span class="o">=</span> <span class="n">ll_indices</span><span class="p">[</span><span class="n">selector</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">resolved</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span>
            <span class="n">resolved</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">resolved</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">resolved</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_row_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ll_index</span><span class="p">):</span>
        <span class="n">raw_row</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_row_getter</span><span class="p">)(</span><span class="nb">int</span><span class="p">(</span><span class="n">ll_index</span><span class="p">))</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_row_field_indices</span>
        <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">raw_row</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">raw_row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_class</span><span class="p">(</span>
                <span class="o">*</span><span class="n">values</span><span class="p">,</span> <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">decode_row</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">row_class</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># Allow all assignments during initialization</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialised</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># Allow internal/private attributes</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">raise</span> <span class="n">ImmutableTableError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Cannot set attribute &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; on immutable </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">table_name</span><span class="si">}</span><span class="s2"> table. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Use TreeSequence.dump_tables() for mutable copy.&quot;</span>
        <span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MutableMetadataTable</span><span class="p">(</span><span class="n">MutableBaseTable</span><span class="p">,</span> <span class="n">metadata</span><span class="o">.</span><span class="n">TableMetadataWriter</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ImmutableMetadataTable</span><span class="p">(</span><span class="n">ImmutableBaseTable</span><span class="p">,</span> <span class="n">metadata</span><span class="o">.</span><span class="n">TableMetadataReader</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`tskit.MetadataSchema` for this table.</span>
<span class="sd">        Overrides the base implementation to access schema from tree sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_schema</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_schema</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="n">parse_metadata_schema</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">get_table_metadata_schemas</span><span class="p">(),</span>
                    <span class="c1"># Use singular form for table name</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">table_name</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_schema</span>


<div class="viewcode-block" id="IndividualTable">
<a class="viewcode-back" href="../../python-api.html#tskit.IndividualTable">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IndividualTable</span><span class="p">(</span><span class="n">MutableMetadataTable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A table defining the individuals in a tree sequence. Note that although</span>
<span class="sd">    each Individual has associated nodes, reference to these is not stored in</span>
<span class="sd">    the individual table, but rather reference to the individual is stored for</span>
<span class="sd">    each node in the :class:`NodeTable`.  This is similar to the way in which</span>
<span class="sd">    the relationship between sites and mutations is modelled.</span>

<span class="sd">    .. include:: substitutions/table_edit_warning.rst</span>

<span class="sd">    :ivar flags: The array of flags values.</span>
<span class="sd">    :vartype flags: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar location: The flattened array of floating point location values. See</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` for more details.</span>
<span class="sd">    :vartype location: numpy.ndarray, dtype=np.float64</span>
<span class="sd">    :ivar location_offset: The array of offsets into the location column. See</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` for more details.</span>
<span class="sd">    :vartype location_offset: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar parents: The flattened array of parent individual ids. See</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` for more details.</span>
<span class="sd">    :vartype parents: numpy.ndarray, dtype=np.int32</span>
<span class="sd">    :ivar parents_offset: The array of offsets into the parents column. See</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` for more details.</span>
<span class="sd">    :vartype parents_offset: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar metadata: The flattened array of binary metadata values. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">    :ivar metadata_offset: The array of offsets into the metadata column. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata_offset: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar metadata_schema: The metadata schema for this table&#39;s metadata column</span>
<span class="sd">    :vartype metadata_schema: tskit.MetadataSchema</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;individuals&quot;</span>
    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;flags&quot;</span><span class="p">,</span>
        <span class="s2">&quot;location&quot;</span><span class="p">,</span>
        <span class="s2">&quot;location_offset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;parents&quot;</span><span class="p">,</span>
        <span class="s2">&quot;parents_offset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_offset&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_rows_increment</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ll_table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ll_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ll_table</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">IndividualTable</span><span class="p">(</span><span class="n">max_rows_increment</span><span class="o">=</span><span class="n">max_rows_increment</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ll_table</span><span class="p">,</span> <span class="n">IndividualTableRow</span><span class="p">)</span>

<div class="viewcode-block" id="IndividualTable.add_row">
<a class="viewcode-back" href="../../python-api.html#tskit.IndividualTable.add_row">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new row to this :class:`IndividualTable` and returns the ID of the</span>
<span class="sd">        corresponding individual. Metadata, if specified, will be validated and encoded</span>
<span class="sd">        according to the table&#39;s</span>
<span class="sd">        :attr:`metadata_schema&lt;tskit.IndividualTable.metadata_schema&gt;`.</span>

<span class="sd">        :param int flags: The bitwise flags for the new node.</span>
<span class="sd">        :param array-like location: A list of numeric values or one-dimensional numpy</span>
<span class="sd">            array describing the location of this individual. If not specified</span>
<span class="sd">            or None, a zero-dimensional location is stored.</span>
<span class="sd">        :param array-like parents: A list or array of ids of parent individuals. If not</span>
<span class="sd">            specified an empty array is stored.</span>
<span class="sd">        :param object metadata: Any object that is valid metadata for the table&#39;s schema.</span>
<span class="sd">            Defaults to the default metadata value for the table&#39;s schema. This is</span>
<span class="sd">            typically ``{}``. For no schema, ``None``.</span>
<span class="sd">        :return: The ID of the newly added individual.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">empty_value</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">validate_and_encode_row</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
            <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="IndividualTable.set_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.IndividualTable.set_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">location_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">parents</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">parents_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the values for each column in this :class:`IndividualTable` using the</span>
<span class="sd">        values in the specified arrays. Overwrites existing data in all the table</span>
<span class="sd">        columns.</span>

<span class="sd">        The ``flags`` array is mandatory and defines the number of individuals</span>
<span class="sd">        the table will contain.</span>
<span class="sd">        The ``location`` and ``location_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for :ref:`sec_encoding_ragged_columns`.</span>
<span class="sd">        The ``parents`` and ``parents_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for :ref:`sec_encoding_ragged_columns`.</span>
<span class="sd">        The ``metadata`` and ``metadata_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for :ref:`sec_encoding_ragged_columns`.</span>
<span class="sd">        See :ref:`sec_tables_api_binary_columns` for more information and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>

<span class="sd">        :param flags: The bitwise flags for each individual. Required.</span>
<span class="sd">        :type flags: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">        :param location: The flattened location array. Must be specified along</span>
<span class="sd">            with ``location_offset``. If not specified or None, an empty location</span>
<span class="sd">            value is stored for each individual.</span>
<span class="sd">        :type location: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param location_offset: The offsets into the ``location`` array.</span>
<span class="sd">        :type location_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param parents: The flattened parents array. Must be specified along</span>
<span class="sd">            with ``parents_offset``. If not specified or None, an empty parents array</span>
<span class="sd">            is stored for each individual.</span>
<span class="sd">        :type parents: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param parents_offset: The offsets into the ``parents`` array.</span>
<span class="sd">        :type parents_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each individual.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param metadata_schema: The encoded metadata schema. If None (default)</span>
<span class="sd">            do not overwrite the exising schema. Note that a schema will need to be</span>
<span class="sd">            encoded as a string, e.g. via ``repr(new_metadata_schema)``.</span>
<span class="sd">        :type metadata_schema: str</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_required_args</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
                <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
                <span class="n">location_offset</span><span class="o">=</span><span class="n">location_offset</span><span class="p">,</span>
                <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span>
                <span class="n">parents_offset</span><span class="o">=</span><span class="n">parents_offset</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
                <span class="n">metadata_schema</span><span class="o">=</span><span class="n">metadata_schema</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="IndividualTable.append_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.IndividualTable.append_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">append_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">location_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">parents</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">parents_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends the specified arrays to the end of the columns in this</span>
<span class="sd">        :class:`IndividualTable`. This allows many new rows to be added at once.</span>

<span class="sd">        The ``flags`` array is mandatory and defines the number of</span>
<span class="sd">        extra individuals to add to the table.</span>
<span class="sd">        The ``parents`` and ``parents_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for :ref:`sec_encoding_ragged_columns`.</span>
<span class="sd">        The ``location`` and ``location_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for :ref:`sec_encoding_ragged_columns`.</span>
<span class="sd">        The ``metadata`` and ``metadata_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for :ref:`sec_encoding_ragged_columns`.</span>
<span class="sd">        See :ref:`sec_tables_api_binary_columns` for more information and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>

<span class="sd">        :param flags: The bitwise flags for each individual. Required.</span>
<span class="sd">        :type flags: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">        :param location: The flattened location array. Must be specified along</span>
<span class="sd">            with ``location_offset``. If not specified or None, an empty location</span>
<span class="sd">            value is stored for each individual.</span>
<span class="sd">        :type location: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param location_offset: The offsets into the ``location`` array.</span>
<span class="sd">        :type location_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each individual.</span>
<span class="sd">        :param parents: The flattened parents array. Must be specified along</span>
<span class="sd">            with ``parents_offset``. If not specified or None, an empty parents array</span>
<span class="sd">            is stored for each individual.</span>
<span class="sd">        :type parents: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param parents_offset: The offsets into the ``parents`` array.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_required_args</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">append_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
                <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
                <span class="n">location_offset</span><span class="o">=</span><span class="n">location_offset</span><span class="p">,</span>
                <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span>
                <span class="n">parents_offset</span><span class="o">=</span><span class="n">parents_offset</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="IndividualTable.packset_location">
<a class="viewcode-back" href="../../python-api.html#tskit.IndividualTable.packset_location">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">packset_location</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locations</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Packs the specified list of location values and updates the ``location``</span>
<span class="sd">        and ``location_offset`` columns. The length of the locations array</span>
<span class="sd">        must be equal to the number of rows in the table.</span>

<span class="sd">        :param list locations: A list of locations interpreted as numpy float64</span>
<span class="sd">            arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">packed</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pack_arrays</span><span class="p">(</span><span class="n">locations</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">packed</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;location_offset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndividualTable.packset_parents">
<a class="viewcode-back" href="../../python-api.html#tskit.IndividualTable.packset_parents">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">packset_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Packs the specified list of parent values and updates the ``parent``</span>
<span class="sd">        and ``parent_offset`` columns. The length of the parents array</span>
<span class="sd">        must be equal to the number of rows in the table.</span>

<span class="sd">        :param list parents: A list of list of parent ids, interpreted as numpy int32</span>
<span class="sd">            arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">packed</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pack_arrays</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;parents&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">packed</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;parents_offset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="IndividualTable.keep_rows">
<a class="viewcode-back" href="../../python-api.html#tskit.IndividualTable.keep_rows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">keep_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. include:: substitutions/table_keep_rows_main.rst</span>

<span class="sd">        The values in the ``parents`` column are updated according to this</span>
<span class="sd">        map, so that reference integrity within the table is maintained.</span>
<span class="sd">        As a consequence of this, the values in the ``parents`` column</span>
<span class="sd">        for kept rows are bounds-checked and an error raised if they</span>
<span class="sd">        are not valid. Rows that are deleted are not checked for</span>
<span class="sd">        parent ID integrity.</span>

<span class="sd">        If an attempt is made to delete rows that are referred to by</span>
<span class="sd">        the ``parents`` column of rows that are retained, an error</span>
<span class="sd">        is raised.</span>

<span class="sd">        These error conditions are checked before any alterations to</span>
<span class="sd">        the table are made.</span>

<span class="sd">        :param array-like keep: The rows to keep as a boolean array. Must</span>
<span class="sd">            be the same length as the table, and convertible to a numpy</span>
<span class="sd">            array of dtype bool.</span>
<span class="sd">        :return: The mapping between old and new row IDs as a numpy</span>
<span class="sd">            array (dtype int32).</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">keep_rows</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="NodeTable">
<a class="viewcode-back" href="../../python-api.html#tskit.NodeTable">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">NodeTable</span><span class="p">(</span><span class="n">MutableMetadataTable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A table defining the nodes in a tree sequence. See the</span>
<span class="sd">    :ref:`definitions &lt;sec_node_table_definition&gt;` for details on the columns</span>
<span class="sd">    in this table and the</span>
<span class="sd">    :ref:`tree sequence requirements &lt;sec_valid_tree_sequence_requirements&gt;` section</span>
<span class="sd">    for the properties needed for a node table to be a part of a valid tree sequence.</span>

<span class="sd">    .. include:: substitutions/table_edit_warning.rst</span>

<span class="sd">    :ivar time: The array of time values.</span>
<span class="sd">    :vartype time: numpy.ndarray, dtype=np.float64</span>
<span class="sd">    :ivar flags: The array of flags values.</span>
<span class="sd">    :vartype flags: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar population: The array of population IDs.</span>
<span class="sd">    :vartype population: numpy.ndarray, dtype=np.int32</span>
<span class="sd">    :ivar individual: The array of individual IDs that each node belongs to.</span>
<span class="sd">    :vartype individual: numpy.ndarray, dtype=np.int32</span>
<span class="sd">    :ivar metadata: The flattened array of binary metadata values. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">    :ivar metadata_offset: The array of offsets into the metadata column. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata_offset: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar metadata_schema: The metadata schema for this table&#39;s metadata column</span>
<span class="sd">    :vartype metadata_schema: tskit.MetadataSchema</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;nodes&quot;</span>
    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;time&quot;</span><span class="p">,</span>
        <span class="s2">&quot;flags&quot;</span><span class="p">,</span>
        <span class="s2">&quot;population&quot;</span><span class="p">,</span>
        <span class="s2">&quot;individual&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_offset&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_rows_increment</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ll_table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ll_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ll_table</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">NodeTable</span><span class="p">(</span><span class="n">max_rows_increment</span><span class="o">=</span><span class="n">max_rows_increment</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ll_table</span><span class="p">,</span> <span class="n">NodeTableRow</span><span class="p">)</span>

<div class="viewcode-block" id="NodeTable.add_row">
<a class="viewcode-back" href="../../python-api.html#tskit.NodeTable.add_row">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">population</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">individual</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new row to this :class:`NodeTable` and returns the ID of the</span>
<span class="sd">        corresponding node. Metadata, if specified, will be validated and encoded</span>
<span class="sd">        according to the table&#39;s</span>
<span class="sd">        :attr:`metadata_schema&lt;tskit.NodeTable.metadata_schema&gt;`.</span>

<span class="sd">        :param int flags: The bitwise flags for the new node.</span>
<span class="sd">        :param float time: The birth time for the new node.</span>
<span class="sd">        :param int population: The ID of the population in which the new node was born.</span>
<span class="sd">            Defaults to :data:`tskit.NULL`.</span>
<span class="sd">        :param int individual: The ID of the individual in which the new node was born.</span>
<span class="sd">            Defaults to :data:`tskit.NULL`.</span>
<span class="sd">        :param object metadata: Any object that is valid metadata for the table&#39;s schema.</span>
<span class="sd">            Defaults to the default metadata value for the table&#39;s schema. This is</span>
<span class="sd">            typically ``{}``. For no schema, ``None``.</span>
<span class="sd">        :return: The ID of the newly added node.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">empty_value</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">validate_and_encode_row</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">population</span><span class="p">,</span> <span class="n">individual</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span></div>


<div class="viewcode-block" id="NodeTable.set_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.NodeTable.set_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">population</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">individual</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the values for each column in this :class:`NodeTable` using the values in</span>
<span class="sd">        the specified arrays. Overwrites existing data in all the table columns.</span>

<span class="sd">        The ``flags``, ``time`` and ``population`` arrays must all be of the same length,</span>
<span class="sd">        which is equal to the number of nodes the table will contain. The</span>
<span class="sd">        ``metadata`` and ``metadata_offset`` parameters must be supplied together, and</span>
<span class="sd">        meet the requirements for :ref:`sec_encoding_ragged_columns`.</span>
<span class="sd">        See :ref:`sec_tables_api_binary_columns` for more information and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>

<span class="sd">        :param flags: The bitwise flags for each node. Required.</span>
<span class="sd">        :type flags: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">        :param time: The time values for each node. Required.</span>
<span class="sd">        :type time: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param population: The population values for each node. If not specified</span>
<span class="sd">            or None, the :data:`tskit.NULL` value is stored for each node.</span>
<span class="sd">        :type population: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param individual: The individual values for each node. If not specified</span>
<span class="sd">            or None, the :data:`tskit.NULL` value is stored for each node.</span>
<span class="sd">        :type individual: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param metadata_schema: The encoded metadata schema. If None (default)</span>
<span class="sd">            do not overwrite the exising schema. Note that a schema will need to be</span>
<span class="sd">            encoded as a string, e.g. via ``repr(new_metadata_schema)``.</span>
<span class="sd">        :type metadata_schema: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_required_args</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
                <span class="n">individual</span><span class="o">=</span><span class="n">individual</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
                <span class="n">metadata_schema</span><span class="o">=</span><span class="n">metadata_schema</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="NodeTable.append_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.NodeTable.append_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">append_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">population</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">individual</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends the specified arrays to the end of the columns in this</span>
<span class="sd">        :class:`NodeTable`. This allows many new rows to be added at once.</span>

<span class="sd">        The ``flags``, ``time`` and ``population`` arrays must all be of the same length,</span>
<span class="sd">        which is equal to the number of nodes that will be added to the table. The</span>
<span class="sd">        ``metadata`` and ``metadata_offset`` parameters must be supplied together, and</span>
<span class="sd">        meet the requirements for :ref:`sec_encoding_ragged_columns`.</span>
<span class="sd">        See :ref:`sec_tables_api_binary_columns` for more information and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>

<span class="sd">        :param flags: The bitwise flags for each node. Required.</span>
<span class="sd">        :type flags: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">        :param time: The time values for each node. Required.</span>
<span class="sd">        :type time: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param population: The population values for each node. If not specified</span>
<span class="sd">            or None, the :data:`tskit.NULL` value is stored for each node.</span>
<span class="sd">        :type population: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param individual: The individual values for each node. If not specified</span>
<span class="sd">            or None, the :data:`tskit.NULL` value is stored for each node.</span>
<span class="sd">        :type individual: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_required_args</span><span class="p">(</span><span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">append_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
                <span class="n">individual</span><span class="o">=</span><span class="n">individual</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="EdgeTable">
<a class="viewcode-back" href="../../python-api.html#tskit.EdgeTable">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">EdgeTable</span><span class="p">(</span><span class="n">MutableMetadataTable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A table defining the edges in a tree sequence. See the</span>
<span class="sd">    :ref:`definitions &lt;sec_edge_table_definition&gt;` for details on the columns</span>
<span class="sd">    in this table and the</span>
<span class="sd">    :ref:`tree sequence requirements &lt;sec_valid_tree_sequence_requirements&gt;` section</span>
<span class="sd">    for the properties needed for an edge table to be a part of a valid tree sequence.</span>

<span class="sd">    .. include:: substitutions/table_edit_warning.rst</span>

<span class="sd">    :ivar left: The array of left coordinates.</span>
<span class="sd">    :vartype left: numpy.ndarray, dtype=np.float64</span>
<span class="sd">    :ivar right: The array of right coordinates.</span>
<span class="sd">    :vartype right: numpy.ndarray, dtype=np.float64</span>
<span class="sd">    :ivar parent: The array of parent node IDs.</span>
<span class="sd">    :vartype parent: numpy.ndarray, dtype=np.int32</span>
<span class="sd">    :ivar child: The array of child node IDs.</span>
<span class="sd">    :vartype child: numpy.ndarray, dtype=np.int32</span>
<span class="sd">    :ivar metadata: The flattened array of binary metadata values. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">    :ivar metadata_offset: The array of offsets into the metadata column. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata_offset: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar metadata_schema: The metadata schema for this table&#39;s metadata column</span>
<span class="sd">    :vartype metadata_schema: tskit.MetadataSchema</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;edges&quot;</span>
    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="s2">&quot;right&quot;</span><span class="p">,</span>
        <span class="s2">&quot;parent&quot;</span><span class="p">,</span>
        <span class="s2">&quot;child&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_offset&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_rows_increment</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ll_table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ll_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ll_table</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">EdgeTable</span><span class="p">(</span><span class="n">max_rows_increment</span><span class="o">=</span><span class="n">max_rows_increment</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ll_table</span><span class="p">,</span> <span class="n">EdgeTableRow</span><span class="p">)</span>

<div class="viewcode-block" id="EdgeTable.add_row">
<a class="viewcode-back" href="../../python-api.html#tskit.EdgeTable.add_row">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new row to this :class:`EdgeTable` and returns the ID of the</span>
<span class="sd">        corresponding edge. Metadata, if specified, will be validated and encoded</span>
<span class="sd">        according to the table&#39;s</span>
<span class="sd">        :attr:`metadata_schema&lt;tskit.EdgeTable.metadata_schema&gt;`.</span>

<span class="sd">        :param float left: The left coordinate (inclusive).</span>
<span class="sd">        :param float right: The right coordinate (exclusive).</span>
<span class="sd">        :param int parent: The ID of parent node.</span>
<span class="sd">        :param int child: The ID of child node.</span>
<span class="sd">        :param object metadata: Any object that is valid metadata for the table&#39;s schema.</span>
<span class="sd">            Defaults to the default metadata value for the table&#39;s schema. This is</span>
<span class="sd">            typically ``{}``. For no schema, ``None``.</span>
<span class="sd">        :return: The ID of the newly added edge.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">empty_value</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">validate_and_encode_row</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span></div>


<div class="viewcode-block" id="EdgeTable.set_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.EdgeTable.set_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">child</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the values for each column in this :class:`EdgeTable` using the values</span>
<span class="sd">        in the specified arrays. Overwrites existing data in all the table columns.</span>

<span class="sd">        The ``left``, ``right``, ``parent`` and ``child`` parameters are mandatory,</span>
<span class="sd">        and must be numpy arrays of the same length (which is equal to the number of</span>
<span class="sd">        edges the table will contain).</span>
<span class="sd">        The ``metadata`` and ``metadata_offset`` parameters must be supplied together,</span>
<span class="sd">        and meet the requirements for :ref:`sec_encoding_ragged_columns`.</span>
<span class="sd">        See :ref:`sec_tables_api_binary_columns` for more information and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>


<span class="sd">        :param left: The left coordinates (inclusive).</span>
<span class="sd">        :type left: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param right: The right coordinates (exclusive).</span>
<span class="sd">        :type right: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param parent: The parent node IDs.</span>
<span class="sd">        :type parent: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param child: The child node IDs.</span>
<span class="sd">        :type child: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param metadata_schema: The encoded metadata schema. If None (default)</span>
<span class="sd">            do not overwrite the exising schema. Note that a schema will need to be</span>
<span class="sd">            encoded as a string, e.g. via ``repr(new_metadata_schema)``.</span>
<span class="sd">        :type metadata_schema: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_required_args</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span>
                <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span>
                <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
                <span class="n">metadata_schema</span><span class="o">=</span><span class="n">metadata_schema</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="EdgeTable.append_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.EdgeTable.append_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">append_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends the specified arrays to the end of the columns of this</span>
<span class="sd">        :class:`EdgeTable`. This allows many new rows to be added at once.</span>

<span class="sd">        The ``left``, ``right``, ``parent`` and ``child`` parameters are mandatory,</span>
<span class="sd">        and must be numpy arrays of the same length (which is equal to the number of</span>
<span class="sd">        additional edges to add to the table). The ``metadata`` and</span>
<span class="sd">        ``metadata_offset`` parameters must be supplied together, and</span>
<span class="sd">        meet the requirements for :ref:`sec_encoding_ragged_columns`.</span>
<span class="sd">        See :ref:`sec_tables_api_binary_columns` for more information and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>


<span class="sd">        :param left: The left coordinates (inclusive).</span>
<span class="sd">        :type left: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param right: The right coordinates (exclusive).</span>
<span class="sd">        :type right: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param parent: The parent node IDs.</span>
<span class="sd">        :type parent: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param child: The child node IDs.</span>
<span class="sd">        :type child: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">append_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span>
                <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span>
                <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="EdgeTable.squash">
<a class="viewcode-back" href="../../python-api.html#tskit.EdgeTable.squash">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">squash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts, then condenses the table into the smallest possible number of rows by</span>
<span class="sd">        combining any adjacent edges.</span>
<span class="sd">        A pair of edges is said to be `adjacent` if they have the same parent and child</span>
<span class="sd">        nodes, and if the left coordinate of one of the edges is equal to the right</span>
<span class="sd">        coordinate of the other edge.</span>
<span class="sd">        The ``squash`` method modifies an :class:`EdgeTable` in place so that any set of</span>
<span class="sd">        adjacent edges is replaced by a single edge.</span>
<span class="sd">        The new edge will have the same parent and child node, a left coordinate</span>
<span class="sd">        equal to the smallest left coordinate in the set, and a right coordinate</span>
<span class="sd">        equal to the largest right coordinate in the set.</span>
<span class="sd">        The new edge table will be sorted in the order (P, C, L, R): if the node table</span>
<span class="sd">        is ordered by increasing node time, as is common, this order will meet the</span>
<span class="sd">        :ref:`sec_edge_requirements` for a valid tree sequence, otherwise you will need</span>
<span class="sd">        to call :meth:`.sort` on the entire :class:`TableCollection`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Note that this method will fail if any edges have non-empty metadata.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">squash</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="MigrationTable">
<a class="viewcode-back" href="../../python-api.html#tskit.MigrationTable">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MigrationTable</span><span class="p">(</span><span class="n">MutableMetadataTable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A table defining the migrations in a tree sequence. See the</span>
<span class="sd">    :ref:`definitions &lt;sec_migration_table_definition&gt;` for details on the columns</span>
<span class="sd">    in this table and the</span>
<span class="sd">    :ref:`tree sequence requirements &lt;sec_valid_tree_sequence_requirements&gt;` section</span>
<span class="sd">    for the properties needed for a migration table to be a part of a valid tree</span>
<span class="sd">    sequence.</span>

<span class="sd">    .. include:: substitutions/table_edit_warning.rst</span>

<span class="sd">    :ivar left: The array of left coordinates.</span>
<span class="sd">    :vartype left: numpy.ndarray, dtype=np.float64</span>
<span class="sd">    :ivar right: The array of right coordinates.</span>
<span class="sd">    :vartype right: numpy.ndarray, dtype=np.float64</span>
<span class="sd">    :ivar node: The array of node IDs.</span>
<span class="sd">    :vartype node: numpy.ndarray, dtype=np.int32</span>
<span class="sd">    :ivar source: The array of source population IDs.</span>
<span class="sd">    :vartype source: numpy.ndarray, dtype=np.int32</span>
<span class="sd">    :ivar dest: The array of destination population IDs.</span>
<span class="sd">    :vartype dest: numpy.ndarray, dtype=np.int32</span>
<span class="sd">    :ivar time: The array of time values.</span>
<span class="sd">    :vartype time: numpy.ndarray, dtype=np.float64</span>
<span class="sd">    :ivar metadata: The flattened array of binary metadata values. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">    :ivar metadata_offset: The array of offsets into the metadata column. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata_offset: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar metadata_schema: The metadata schema for this table&#39;s metadata column</span>
<span class="sd">    :vartype metadata_schema: tskit.MetadataSchema</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;migrations&quot;</span>
    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="s2">&quot;right&quot;</span><span class="p">,</span>
        <span class="s2">&quot;node&quot;</span><span class="p">,</span>
        <span class="s2">&quot;source&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dest&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_offset&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_rows_increment</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ll_table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ll_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ll_table</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">MigrationTable</span><span class="p">(</span><span class="n">max_rows_increment</span><span class="o">=</span><span class="n">max_rows_increment</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ll_table</span><span class="p">,</span> <span class="n">MigrationTableRow</span><span class="p">)</span>

<div class="viewcode-block" id="MigrationTable.add_row">
<a class="viewcode-back" href="../../python-api.html#tskit.MigrationTable.add_row">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new row to this :class:`MigrationTable` and returns the ID of the</span>
<span class="sd">        corresponding migration. Metadata, if specified, will be validated and encoded</span>
<span class="sd">        according to the table&#39;s</span>
<span class="sd">        :attr:`metadata_schema&lt;tskit.MigrationTable.metadata_schema&gt;`.</span>

<span class="sd">        :param float left: The left coordinate (inclusive).</span>
<span class="sd">        :param float right: The right coordinate (exclusive).</span>
<span class="sd">        :param int node: The node ID.</span>
<span class="sd">        :param int source: The ID of the source population.</span>
<span class="sd">        :param int dest: The ID of the destination population.</span>
<span class="sd">        :param float time: The time of the migration event.</span>
<span class="sd">        :param object metadata: Any object that is valid metadata for the table&#39;s schema.</span>
<span class="sd">            Defaults to the default metadata value for the table&#39;s schema. This is</span>
<span class="sd">            typically ``{}``. For no schema, ``None``.</span>
<span class="sd">        :return: The ID of the newly added migration.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">empty_value</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">validate_and_encode_row</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span></div>


<div class="viewcode-block" id="MigrationTable.set_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.MigrationTable.set_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">source</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dest</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the values for each column in this :class:`MigrationTable` using the values</span>
<span class="sd">        in the specified arrays. Overwrites existing data in all the table columns.</span>

<span class="sd">        All parameters except ``metadata`` and ``metadata_offset`` and are mandatory,</span>
<span class="sd">        and must be numpy arrays of the same length (which is equal to the number of</span>
<span class="sd">        migrations the table will contain).</span>
<span class="sd">        The ``metadata`` and ``metadata_offset`` parameters must be supplied together,</span>
<span class="sd">        and meet the requirements for :ref:`sec_encoding_ragged_columns`.</span>
<span class="sd">        See :ref:`sec_tables_api_binary_columns` for more information and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>

<span class="sd">        :param left: The left coordinates (inclusive).</span>
<span class="sd">        :type left: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param right: The right coordinates (exclusive).</span>
<span class="sd">        :type right: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param node: The node IDs.</span>
<span class="sd">        :type node: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param source: The source population IDs.</span>
<span class="sd">        :type source: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param dest: The destination population IDs.</span>
<span class="sd">        :type dest: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param time: The time of each migration.</span>
<span class="sd">        :type time: numpy.ndarray, dtype=np.int64</span>
<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each migration.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param metadata_schema: The encoded metadata schema. If None (default)</span>
<span class="sd">            do not overwrite the exising schema. Note that a schema will need to be</span>
<span class="sd">            encoded as a string, e.g. via ``repr(new_metadata_schema)``.</span>
<span class="sd">        :type metadata_schema: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_required_args</span><span class="p">(</span>
            <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span>
                <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span>
                <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
                <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
                <span class="n">metadata_schema</span><span class="o">=</span><span class="n">metadata_schema</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MigrationTable.append_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.MigrationTable.append_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">append_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">left</span><span class="p">,</span>
        <span class="n">right</span><span class="p">,</span>
        <span class="n">node</span><span class="p">,</span>
        <span class="n">source</span><span class="p">,</span>
        <span class="n">dest</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends the specified arrays to the end of the columns of this</span>
<span class="sd">        :class:`MigrationTable`. This allows many new rows to be added at once.</span>

<span class="sd">        All parameters except ``metadata`` and ``metadata_offset`` and are mandatory,</span>
<span class="sd">        and must be numpy arrays of the same length (which is equal to the number of</span>
<span class="sd">        additional migrations to add to the table). The ``metadata`` and</span>
<span class="sd">        ``metadata_offset`` parameters must be supplied together, and</span>
<span class="sd">        meet the requirements for :ref:`sec_encoding_ragged_columns`.</span>
<span class="sd">        See :ref:`sec_tables_api_binary_columns` for more information and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>

<span class="sd">        :param left: The left coordinates (inclusive).</span>
<span class="sd">        :type left: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param right: The right coordinates (exclusive).</span>
<span class="sd">        :type right: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param node: The node IDs.</span>
<span class="sd">        :type node: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param source: The source population IDs.</span>
<span class="sd">        :type source: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param dest: The destination population IDs.</span>
<span class="sd">        :type dest: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param time: The time of each migration.</span>
<span class="sd">        :type time: numpy.ndarray, dtype=np.int64</span>
<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each migration.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">append_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span>
                <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span>
                <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
                <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SiteTable">
<a class="viewcode-back" href="../../python-api.html#tskit.SiteTable">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SiteTable</span><span class="p">(</span><span class="n">MutableMetadataTable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A table defining the sites in a tree sequence. See the</span>
<span class="sd">    :ref:`definitions &lt;sec_site_table_definition&gt;` for details on the columns</span>
<span class="sd">    in this table and the</span>
<span class="sd">    :ref:`tree sequence requirements &lt;sec_valid_tree_sequence_requirements&gt;` section</span>
<span class="sd">    for the properties needed for a site table to be a part of a valid tree</span>
<span class="sd">    sequence.</span>

<span class="sd">    .. include:: substitutions/table_edit_warning.rst</span>

<span class="sd">    :ivar position: The array of site position coordinates.</span>
<span class="sd">    :vartype position: numpy.ndarray, dtype=np.float64</span>
<span class="sd">    :ivar ancestral_state: The flattened array of ancestral state strings.</span>
<span class="sd">        See :ref:`sec_tables_api_text_columns` for more details.</span>
<span class="sd">    :vartype ancestral_state: numpy.ndarray, dtype=np.int8</span>
<span class="sd">    :ivar ancestral_state_offset: The offsets of rows in the ancestral_state</span>
<span class="sd">        array. See :ref:`sec_tables_api_text_columns` for more details.</span>
<span class="sd">    :vartype ancestral_state_offset: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar metadata: The flattened array of binary metadata values. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">    :ivar metadata_offset: The array of offsets into the metadata column. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata_offset: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar metadata_schema: The metadata schema for this table&#39;s metadata column</span>
<span class="sd">    :vartype metadata_schema: tskit.MetadataSchema</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;sites&quot;</span>
    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;position&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ancestral_state&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ancestral_state_offset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_offset&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_rows_increment</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ll_table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ll_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ll_table</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">SiteTable</span><span class="p">(</span><span class="n">max_rows_increment</span><span class="o">=</span><span class="n">max_rows_increment</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ll_table</span><span class="p">,</span> <span class="n">SiteTableRow</span><span class="p">)</span>

<div class="viewcode-block" id="SiteTable.add_row">
<a class="viewcode-back" href="../../python-api.html#tskit.SiteTable.add_row">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">ancestral_state</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new row to this :class:`SiteTable` and returns the ID of the</span>
<span class="sd">        corresponding site. Metadata, if specified, will be validated and encoded</span>
<span class="sd">        according to the table&#39;s</span>
<span class="sd">        :attr:`metadata_schema&lt;tskit.SiteTable.metadata_schema&gt;`.</span>

<span class="sd">        :param float position: The position of this site in genome coordinates.</span>
<span class="sd">        :param str ancestral_state: The state of this site at the root of the tree.</span>
<span class="sd">        :param object metadata: Any object that is valid metadata for the table&#39;s schema.</span>
<span class="sd">            Defaults to the default metadata value for the table&#39;s schema. This is</span>
<span class="sd">            typically ``{}``. For no schema, ``None``.</span>
<span class="sd">        :return: The ID of the newly added site.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">empty_value</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">validate_and_encode_row</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">ancestral_state</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span></div>


<div class="viewcode-block" id="SiteTable.set_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.SiteTable.set_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ancestral_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ancestral_state_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the values for each column in this :class:`SiteTable` using the values</span>
<span class="sd">        in the specified arrays. Overwrites existing data in all the table columns.</span>

<span class="sd">        The ``position``, ``ancestral_state`` and ``ancestral_state_offset``</span>
<span class="sd">        parameters are mandatory, and must be 1D numpy arrays. The length</span>
<span class="sd">        of the ``position`` array determines the number of rows in table.</span>
<span class="sd">        The ``ancestral_state`` and ``ancestral_state_offset`` parameters must</span>
<span class="sd">        be supplied together, and meet the requirements for</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` (see</span>
<span class="sd">        :ref:`sec_tables_api_text_columns` for more information). The</span>
<span class="sd">        ``metadata`` and ``metadata_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` (see</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more information) and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>

<span class="sd">        :param position: The position of each site in genome coordinates.</span>
<span class="sd">        :type position: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param ancestral_state: The flattened ancestral_state array. Required.</span>
<span class="sd">        :type ancestral_state: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param ancestral_state_offset: The offsets into the ``ancestral_state`` array.</span>
<span class="sd">        :type ancestral_state_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param metadata_schema: The encoded metadata schema. If None (default)</span>
<span class="sd">            do not overwrite the exising schema. Note that a schema will need to be</span>
<span class="sd">            encoded as a string, e.g. via ``repr(new_metadata_schema)``.</span>
<span class="sd">        :type metadata_schema: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_required_args</span><span class="p">(</span>
            <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span>
            <span class="n">ancestral_state</span><span class="o">=</span><span class="n">ancestral_state</span><span class="p">,</span>
            <span class="n">ancestral_state_offset</span><span class="o">=</span><span class="n">ancestral_state_offset</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span>
                <span class="n">ancestral_state</span><span class="o">=</span><span class="n">ancestral_state</span><span class="p">,</span>
                <span class="n">ancestral_state_offset</span><span class="o">=</span><span class="n">ancestral_state_offset</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
                <span class="n">metadata_schema</span><span class="o">=</span><span class="n">metadata_schema</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SiteTable.append_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.SiteTable.append_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">append_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">position</span><span class="p">,</span>
        <span class="n">ancestral_state</span><span class="p">,</span>
        <span class="n">ancestral_state_offset</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends the specified arrays to the end of the columns of this</span>
<span class="sd">        :class:`SiteTable`. This allows many new rows to be added at once.</span>

<span class="sd">        The ``position``, ``ancestral_state`` and ``ancestral_state_offset``</span>
<span class="sd">        parameters are mandatory, and must be 1D numpy arrays. The length</span>
<span class="sd">        of the ``position`` array determines the number of additional rows</span>
<span class="sd">        to add the table.</span>
<span class="sd">        The ``ancestral_state`` and ``ancestral_state_offset`` parameters must</span>
<span class="sd">        be supplied together, and meet the requirements for</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` (see</span>
<span class="sd">        :ref:`sec_tables_api_text_columns` for more information). The</span>
<span class="sd">        ``metadata`` and ``metadata_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` (see</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more information) and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>

<span class="sd">        :param position: The position of each site in genome coordinates.</span>
<span class="sd">        :type position: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param ancestral_state: The flattened ancestral_state array. Required.</span>
<span class="sd">        :type ancestral_state: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param ancestral_state_offset: The offsets into the ``ancestral_state`` array.</span>
<span class="sd">        :type ancestral_state_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">append_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span>
                <span class="n">ancestral_state</span><span class="o">=</span><span class="n">ancestral_state</span><span class="p">,</span>
                <span class="n">ancestral_state_offset</span><span class="o">=</span><span class="n">ancestral_state_offset</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="SiteTable.packset_ancestral_state">
<a class="viewcode-back" href="../../python-api.html#tskit.SiteTable.packset_ancestral_state">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">packset_ancestral_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ancestral_states</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Packs the specified list of ancestral_state values and updates the</span>
<span class="sd">        ``ancestral_state`` and ``ancestral_state_offset`` columns. The length</span>
<span class="sd">        of the ancestral_states array must be equal to the number of rows in</span>
<span class="sd">        the table.</span>

<span class="sd">        :param list(str) ancestral_states: A list of string ancestral state values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">packed</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pack_strings</span><span class="p">(</span><span class="n">ancestral_states</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;ancestral_state&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">packed</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;ancestral_state_offset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="MutationTable">
<a class="viewcode-back" href="../../python-api.html#tskit.MutationTable">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MutationTable</span><span class="p">(</span><span class="n">MutableMetadataTable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A table defining the mutations in a tree sequence. See the</span>
<span class="sd">    :ref:`definitions &lt;sec_mutation_table_definition&gt;` for details on the columns</span>
<span class="sd">    in this table and the</span>
<span class="sd">    :ref:`tree sequence requirements &lt;sec_valid_tree_sequence_requirements&gt;` section</span>
<span class="sd">    for the properties needed for a mutation table to be a part of a valid tree</span>
<span class="sd">    sequence.</span>

<span class="sd">    .. include:: substitutions/table_edit_warning.rst</span>

<span class="sd">    :ivar site: The array of site IDs.</span>
<span class="sd">    :vartype site: numpy.ndarray, dtype=np.int32</span>
<span class="sd">    :ivar node: The array of node IDs.</span>
<span class="sd">    :vartype node: numpy.ndarray, dtype=np.int32</span>
<span class="sd">    :ivar time: The array of time values.</span>
<span class="sd">    :vartype time: numpy.ndarray, dtype=np.float64</span>
<span class="sd">    :ivar derived_state: The flattened array of derived state strings.</span>
<span class="sd">        See :ref:`sec_tables_api_text_columns` for more details.</span>
<span class="sd">    :vartype derived_state: numpy.ndarray, dtype=np.int8</span>
<span class="sd">    :ivar derived_state_offset: The offsets of rows in the derived_state</span>
<span class="sd">        array. See :ref:`sec_tables_api_text_columns` for more details.</span>
<span class="sd">    :vartype derived_state_offset: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar parent: The array of parent mutation IDs.</span>
<span class="sd">    :vartype parent: numpy.ndarray, dtype=np.int32</span>
<span class="sd">    :ivar metadata: The flattened array of binary metadata values. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">    :ivar metadata_offset: The array of offsets into the metadata column. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata_offset: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar metadata_schema: The metadata schema for this table&#39;s metadata column</span>
<span class="sd">    :vartype metadata_schema: tskit.MetadataSchema</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;mutations&quot;</span>
    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="s2">&quot;node&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time&quot;</span><span class="p">,</span>
        <span class="s2">&quot;derived_state&quot;</span><span class="p">,</span>
        <span class="s2">&quot;derived_state_offset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;parent&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_offset&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_rows_increment</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ll_table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ll_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ll_table</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">MutationTable</span><span class="p">(</span><span class="n">max_rows_increment</span><span class="o">=</span><span class="n">max_rows_increment</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ll_table</span><span class="p">,</span> <span class="n">MutationTableRow</span><span class="p">)</span>

<div class="viewcode-block" id="MutationTable.add_row">
<a class="viewcode-back" href="../../python-api.html#tskit.MutationTable.add_row">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">derived_state</span><span class="p">,</span> <span class="n">parent</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new row to this :class:`MutationTable` and returns the ID of the</span>
<span class="sd">        corresponding mutation. Metadata, if specified, will be validated and encoded</span>
<span class="sd">        according to the table&#39;s</span>
<span class="sd">        :attr:`metadata_schema&lt;tskit.MutationTable.metadata_schema&gt;`.</span>

<span class="sd">        :param int site: The ID of the site that this mutation occurs at.</span>
<span class="sd">        :param int node: The ID of the first node inheriting this mutation.</span>
<span class="sd">        :param str derived_state: The state of the site at this mutation&#39;s node.</span>
<span class="sd">        :param int parent: The ID of the parent mutation. If not specified,</span>
<span class="sd">            defaults to :attr:`NULL`.</span>
<span class="sd">        :param object metadata: Any object that is valid metadata for the table&#39;s schema.</span>
<span class="sd">            Defaults to the default metadata value for the table&#39;s schema. This is</span>
<span class="sd">            typically ``{}``. For no schema, ``None``.</span>
<span class="sd">        :return: The ID of the newly added mutation.</span>
<span class="sd">        :param float time: The occurrence time for the new mutation. If not specified,</span>
<span class="sd">            defaults to ``UNKNOWN_TIME``, indicating the time is unknown.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">empty_value</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">validate_and_encode_row</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
            <span class="n">site</span><span class="p">,</span>
            <span class="n">node</span><span class="p">,</span>
            <span class="n">derived_state</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">,</span>
            <span class="n">UNKNOWN_TIME</span> <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">time</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MutationTable.set_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.MutationTable.set_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">site</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">derived_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">derived_state_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the values for each column in this :class:`MutationTable` using the values</span>
<span class="sd">        in the specified arrays. Overwrites existing data in all the the table columns.</span>

<span class="sd">        The ``site``, ``node``, ``derived_state`` and ``derived_state_offset``</span>
<span class="sd">        parameters are mandatory, and must be 1D numpy arrays. The</span>
<span class="sd">        ``site`` and ``node`` (also ``parent`` and ``time``, if supplied) arrays</span>
<span class="sd">        must be of equal length, and determine the number of rows in the table.</span>
<span class="sd">        The ``derived_state`` and ``derived_state_offset`` parameters must</span>
<span class="sd">        be supplied together, and meet the requirements for</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` (see</span>
<span class="sd">        :ref:`sec_tables_api_text_columns` for more information). The</span>
<span class="sd">        ``metadata`` and ``metadata_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` (see</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more information) and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>

<span class="sd">        :param site: The ID of the site each mutation occurs at.</span>
<span class="sd">        :type site: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param node: The ID of the node each mutation is associated with.</span>
<span class="sd">        :type node: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param time: The time values for each mutation.</span>
<span class="sd">        :type time: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param derived_state: The flattened derived_state array. Required.</span>
<span class="sd">        :type derived_state: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param derived_state_offset: The offsets into the ``derived_state`` array.</span>
<span class="sd">        :type derived_state_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param parent: The ID of the parent mutation for each mutation.</span>
<span class="sd">        :type parent: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param metadata_schema: The encoded metadata schema. If None (default)</span>
<span class="sd">            do not overwrite the exising schema. Note that a schema will need to be</span>
<span class="sd">            encoded as a string, e.g. via ``repr(new_metadata_schema)``.</span>
<span class="sd">        :type metadata_schema: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_required_args</span><span class="p">(</span>
            <span class="n">site</span><span class="o">=</span><span class="n">site</span><span class="p">,</span>
            <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
            <span class="n">derived_state</span><span class="o">=</span><span class="n">derived_state</span><span class="p">,</span>
            <span class="n">derived_state_offset</span><span class="o">=</span><span class="n">derived_state_offset</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">site</span><span class="o">=</span><span class="n">site</span><span class="p">,</span>
                <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">derived_state</span><span class="o">=</span><span class="n">derived_state</span><span class="p">,</span>
                <span class="n">derived_state_offset</span><span class="o">=</span><span class="n">derived_state_offset</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
                <span class="n">metadata_schema</span><span class="o">=</span><span class="n">metadata_schema</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MutationTable.append_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.MutationTable.append_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">append_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">site</span><span class="p">,</span>
        <span class="n">node</span><span class="p">,</span>
        <span class="n">derived_state</span><span class="p">,</span>
        <span class="n">derived_state_offset</span><span class="p">,</span>
        <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends the specified arrays to the end of the columns of this</span>
<span class="sd">        :class:`MutationTable`. This allows many new rows to be added at once.</span>

<span class="sd">        The ``site``, ``node``, ``derived_state`` and ``derived_state_offset``</span>
<span class="sd">        parameters are mandatory, and must be 1D numpy arrays. The</span>
<span class="sd">        ``site`` and ``node`` (also ``time`` and ``parent``, if supplied) arrays</span>
<span class="sd">        must be of equal length, and determine the number of additional</span>
<span class="sd">        rows to add to the table.</span>
<span class="sd">        The ``derived_state`` and ``derived_state_offset`` parameters must</span>
<span class="sd">        be supplied together, and meet the requirements for</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` (see</span>
<span class="sd">        :ref:`sec_tables_api_text_columns` for more information). The</span>
<span class="sd">        ``metadata`` and ``metadata_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` (see</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more information) and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>

<span class="sd">        :param site: The ID of the site each mutation occurs at.</span>
<span class="sd">        :type site: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param node: The ID of the node each mutation is associated with.</span>
<span class="sd">        :type node: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param time: The time values for each mutation.</span>
<span class="sd">        :type time: numpy.ndarray, dtype=np.float64</span>
<span class="sd">        :param derived_state: The flattened derived_state array. Required.</span>
<span class="sd">        :type derived_state: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param derived_state_offset: The offsets into the ``derived_state`` array.</span>
<span class="sd">        :type derived_state_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param parent: The ID of the parent mutation for each mutation.</span>
<span class="sd">        :type parent: numpy.ndarray, dtype=np.int32</span>
<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">append_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">site</span><span class="o">=</span><span class="n">site</span><span class="p">,</span>
                <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                <span class="n">derived_state</span><span class="o">=</span><span class="n">derived_state</span><span class="p">,</span>
                <span class="n">derived_state_offset</span><span class="o">=</span><span class="n">derived_state_offset</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="MutationTable.packset_derived_state">
<a class="viewcode-back" href="../../python-api.html#tskit.MutationTable.packset_derived_state">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">packset_derived_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">derived_states</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Packs the specified list of derived_state values and updates the</span>
<span class="sd">        ``derived_state`` and ``derived_state_offset`` columns. The length</span>
<span class="sd">        of the derived_states array must be equal to the number of rows in</span>
<span class="sd">        the table.</span>

<span class="sd">        :param list(str) derived_states: A list of string derived state values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">packed</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pack_strings</span><span class="p">(</span><span class="n">derived_states</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;derived_state&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">packed</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;derived_state_offset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="MutationTable.keep_rows">
<a class="viewcode-back" href="../../python-api.html#tskit.MutationTable.keep_rows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">keep_rows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. include:: substitutions/table_keep_rows_main.rst</span>

<span class="sd">        The values in the ``parent`` column are updated according to this</span>
<span class="sd">        map, so that reference integrity within the table is maintained.</span>
<span class="sd">        As a consequence of this, the values in the ``parent`` column</span>
<span class="sd">        for kept rows are bounds-checked and an error raised if they</span>
<span class="sd">        are not valid. Rows that are deleted are not checked for</span>
<span class="sd">        parent ID integrity.</span>

<span class="sd">        If an attempt is made to delete rows that are referred to by</span>
<span class="sd">        the ``parent`` column of rows that are retained, an error</span>
<span class="sd">        is raised.</span>

<span class="sd">        These error conditions are checked before any alterations to</span>
<span class="sd">        the table are made.</span>

<span class="sd">        :param array-like keep: The rows to keep as a boolean array. Must</span>
<span class="sd">            be the same length as the table, and convertible to a numpy</span>
<span class="sd">            array of dtype bool.</span>
<span class="sd">        :return: The mapping between old and new row IDs as a numpy</span>
<span class="sd">            array (dtype int32).</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">keep_rows</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="PopulationTable">
<a class="viewcode-back" href="../../python-api.html#tskit.PopulationTable">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PopulationTable</span><span class="p">(</span><span class="n">MutableMetadataTable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A table defining the populations referred to in a tree sequence.</span>
<span class="sd">    The PopulationTable stores metadata for populations that may be referred to</span>
<span class="sd">    in the NodeTable and MigrationTable&quot;.  Note that although nodes</span>
<span class="sd">    may be associated with populations, this association is stored in</span>
<span class="sd">    the :class:`NodeTable`: only metadata on each population is stored</span>
<span class="sd">    in the population table.</span>

<span class="sd">    .. include:: substitutions/table_edit_warning.rst</span>

<span class="sd">    :ivar metadata: The flattened array of binary metadata values. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">    :ivar metadata_offset: The array of offsets into the metadata column. See</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more details.</span>
<span class="sd">    :vartype metadata_offset: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar metadata_schema: The metadata schema for this table&#39;s metadata column</span>
<span class="sd">    :vartype metadata_schema: tskit.MetadataSchema</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;populations&quot;</span>
    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata_offset&quot;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_rows_increment</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ll_table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ll_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ll_table</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">PopulationTable</span><span class="p">(</span><span class="n">max_rows_increment</span><span class="o">=</span><span class="n">max_rows_increment</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ll_table</span><span class="p">,</span> <span class="n">PopulationTableRow</span><span class="p">)</span>

<div class="viewcode-block" id="PopulationTable.add_row">
<a class="viewcode-back" href="../../python-api.html#tskit.PopulationTable.add_row">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new row to this :class:`PopulationTable` and returns the ID of the</span>
<span class="sd">        corresponding population. Metadata, if specified, will be validated and encoded</span>
<span class="sd">        according to the table&#39;s</span>
<span class="sd">        :attr:`metadata_schema&lt;tskit.PopulationTable.metadata_schema&gt;`.</span>

<span class="sd">        :param object metadata: Any object that is valid metadata for the table&#39;s schema.</span>
<span class="sd">            Defaults to the default metadata value for the table&#39;s schema. This is</span>
<span class="sd">            typically ``{}``. For no schema, ``None``.</span>
<span class="sd">        :return: The ID of the newly added population.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">empty_value</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">validate_and_encode_row</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span></div>


<div class="viewcode-block" id="PopulationTable.set_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.PopulationTable.set_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metadata_schema</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the values for each column in this :class:`PopulationTable` using the</span>
<span class="sd">        values in the specified arrays. Overwrites existing data in all the table</span>
<span class="sd">        columns.</span>

<span class="sd">        The ``metadata`` and ``metadata_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` (see</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more information) and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>

<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param metadata_schema: The encoded metadata schema. If None (default)</span>
<span class="sd">            do not overwrite the exising schema. Note that a schema will need to be</span>
<span class="sd">            encoded as a string, e.g. via ``repr(new_metadata_schema)``.</span>
<span class="sd">        :type metadata_schema: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
                <span class="n">metadata_schema</span><span class="o">=</span><span class="n">metadata_schema</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="PopulationTable.append_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.PopulationTable.append_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">append_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metadata_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends the specified arrays to the end of the columns of this</span>
<span class="sd">        :class:`PopulationTable`. This allows many new rows to be added at once.</span>

<span class="sd">        The ``metadata`` and ``metadata_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` (see</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more information) and</span>
<span class="sd">        :ref:`sec_tutorial_metadata_bulk` for an example of how to prepare metadata.</span>

<span class="sd">        :param metadata: The flattened metadata array. Must be specified along</span>
<span class="sd">            with ``metadata_offset``. If not specified or None, an empty metadata</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type metadata: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param metadata_offset: The offsets into the ``metadata`` array.</span>
<span class="sd">        :type metadata_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">append_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span> <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">)</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ProvenanceTable">
<a class="viewcode-back" href="../../python-api.html#tskit.ProvenanceTable">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ProvenanceTable</span><span class="p">(</span><span class="n">MutableBaseTable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A table recording the provenance (i.e., history) of this table, so that the</span>
<span class="sd">    origin of the underlying data and sequence of subsequent operations can be</span>
<span class="sd">    traced. Each row contains a &quot;record&quot; string (recommended format: JSON) and</span>
<span class="sd">    a timestamp.</span>

<span class="sd">    .. todo::</span>
<span class="sd">        The format of the `record` field will be more precisely specified in</span>
<span class="sd">        the future.</span>

<span class="sd">    :ivar record: The flattened array containing the record strings.</span>
<span class="sd">        :ref:`sec_tables_api_text_columns` for more details.</span>
<span class="sd">    :vartype record: numpy.ndarray, dtype=np.int8</span>
<span class="sd">    :ivar record_offset: The array of offsets into the record column. See</span>
<span class="sd">        :ref:`sec_tables_api_text_columns` for more details.</span>
<span class="sd">    :vartype record_offset: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    :ivar timestamp: The flattened array containing the timestamp strings.</span>
<span class="sd">        :ref:`sec_tables_api_text_columns` for more details.</span>
<span class="sd">    :vartype timestamp: numpy.ndarray, dtype=np.int8</span>
<span class="sd">    :ivar timestamp_offset: The array of offsets into the timestamp column. See</span>
<span class="sd">        :ref:`sec_tables_api_text_columns` for more details.</span>
<span class="sd">    :vartype timestamp_offset: numpy.ndarray, dtype=np.uint32</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;provenances&quot;</span>
    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;record&quot;</span><span class="p">,</span> <span class="s2">&quot;record_offset&quot;</span><span class="p">,</span> <span class="s2">&quot;timestamp&quot;</span><span class="p">,</span> <span class="s2">&quot;timestamp_offset&quot;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_rows_increment</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ll_table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ll_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ll_table</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">ProvenanceTable</span><span class="p">(</span><span class="n">max_rows_increment</span><span class="o">=</span><span class="n">max_rows_increment</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ll_table</span><span class="p">,</span> <span class="n">ProvenanceTableRow</span><span class="p">)</span>

<div class="viewcode-block" id="ProvenanceTable.add_row">
<a class="viewcode-back" href="../../python-api.html#tskit.ProvenanceTable.add_row">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new row to this ProvenanceTable consisting of the specified record and</span>
<span class="sd">        timestamp. If timestamp is not specified, it is automatically generated from</span>
<span class="sd">        the current time.</span>

<span class="sd">        :param str record: A provenance record, describing the parameters and</span>
<span class="sd">            environment used to generate the current set of tables.</span>
<span class="sd">        :param str timestamp: A string timestamp. This should be in ISO8601 form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timestamp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timestamp</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()</span>
        <span class="c1"># Note that the order of the positional arguments has been reversed</span>
        <span class="c1"># from the low-level module, which is a bit confusing. However, we</span>
        <span class="c1"># want the default behaviour here to be to add a row to the table at</span>
        <span class="c1"># the current time as simply as possible.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="n">record</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProvenanceTable.set_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.ProvenanceTable.set_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timestamp_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">record_offset</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the values for each column in this :class:`ProvenanceTable` using the</span>
<span class="sd">        values in the specified arrays. Overwrites existing data in all the table</span>
<span class="sd">        columns.</span>

<span class="sd">        The ``timestamp`` and ``timestamp_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` (see</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more information). Likewise</span>
<span class="sd">        for the ``record`` and ``record_offset`` columns</span>

<span class="sd">        :param timestamp: The flattened timestamp array. Must be specified along</span>
<span class="sd">            with ``timestamp_offset``. If not specified or None, an empty timestamp</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type timestamp: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param timestamp_offset: The offsets into the ``timestamp`` array.</span>
<span class="sd">        :type timestamp_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param record: The flattened record array. Must be specified along</span>
<span class="sd">            with ``record_offset``. If not specified or None, an empty record</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type record: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param record_offset: The offsets into the ``record`` array.</span>
<span class="sd">        :type record_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span>
                <span class="n">timestamp_offset</span><span class="o">=</span><span class="n">timestamp_offset</span><span class="p">,</span>
                <span class="n">record</span><span class="o">=</span><span class="n">record</span><span class="p">,</span>
                <span class="n">record_offset</span><span class="o">=</span><span class="n">record_offset</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ProvenanceTable.append_columns">
<a class="viewcode-back" href="../../python-api.html#tskit.ProvenanceTable.append_columns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">append_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timestamp_offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">record_offset</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends the specified arrays to the end of the columns of this</span>
<span class="sd">        :class:`ProvenanceTable`. This allows many new rows to be added at once.</span>

<span class="sd">        The ``timestamp`` and ``timestamp_offset`` parameters must be supplied</span>
<span class="sd">        together, and meet the requirements for</span>
<span class="sd">        :ref:`sec_encoding_ragged_columns` (see</span>
<span class="sd">        :ref:`sec_tables_api_binary_columns` for more information). Likewise</span>
<span class="sd">        for the ``record`` and ``record_offset`` columns</span>

<span class="sd">        :param timestamp: The flattened timestamp array. Must be specified along</span>
<span class="sd">            with ``timestamp_offset``. If not specified or None, an empty timestamp</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type timestamp: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param timestamp_offset: The offsets into the ``timestamp`` array.</span>
<span class="sd">        :type timestamp_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        :param record: The flattened record array. Must be specified along</span>
<span class="sd">            with ``record_offset``. If not specified or None, an empty record</span>
<span class="sd">            value is stored for each node.</span>
<span class="sd">        :type record: numpy.ndarray, dtype=np.int8</span>
<span class="sd">        :param record_offset: The offsets into the ``record`` array.</span>
<span class="sd">        :type record_offset: numpy.ndarray, dtype=np.uint32.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ll_table</span><span class="o">.</span><span class="n">append_columns</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span>
                <span class="n">timestamp_offset</span><span class="o">=</span><span class="n">timestamp_offset</span><span class="p">,</span>
                <span class="n">record</span><span class="o">=</span><span class="n">record</span><span class="p">,</span>
                <span class="n">record_offset</span><span class="o">=</span><span class="n">record_offset</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="ProvenanceTable.packset_record">
<a class="viewcode-back" href="../../python-api.html#tskit.ProvenanceTable.packset_record">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">packset_record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">records</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Packs the specified list of record values and updates the</span>
<span class="sd">        ``record`` and ``record_offset`` columns. The length</span>
<span class="sd">        of the records array must be equal to the number of rows in</span>
<span class="sd">        the table.</span>

<span class="sd">        :param list(str) records: A list of string record values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">packed</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pack_strings</span><span class="p">(</span><span class="n">records</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;record&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">packed</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;record_offset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProvenanceTable.packset_timestamp">
<a class="viewcode-back" href="../../python-api.html#tskit.ProvenanceTable.packset_timestamp">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">packset_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestamps</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Packs the specified list of timestamp values and updates the</span>
<span class="sd">        ``timestamp`` and ``timestamp_offset`` columns. The length</span>
<span class="sd">        of the timestamps array must be equal to the number of rows in</span>
<span class="sd">        the table.</span>

<span class="sd">        :param list(str) timestamps: A list of string timestamp values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">packed</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">pack_strings</span><span class="p">(</span><span class="n">timestamps</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;timestamp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">packed</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;timestamp_offset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProvenanceTable.equals">
<a class="viewcode-back" href="../../python-api.html#tskit.ProvenanceTable.equals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if  `self` and `other` are equal. By default, two provenance</span>
<span class="sd">        tables are considered equal if their columns are byte-for-byte identical.</span>

<span class="sd">        :param other: Another provenance table instance</span>
<span class="sd">        :param bool ignore_timestamps: If True exclude the timestamp column</span>
<span class="sd">            from the comparison.</span>
<span class="sd">        :return: True if other is equal to this provenance table; False otherwise.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equals_internal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span><span class="p">)</span></div>


<div class="viewcode-block" id="ProvenanceTable.assert_equals">
<a class="viewcode-back" href="../../python-api.html#tskit.ProvenanceTable.assert_equals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assert_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise an AssertionError for the first found difference between</span>
<span class="sd">        this and another provenance table.</span>

<span class="sd">        :param other: Another provenance table instance</span>
<span class="sd">        :param bool ignore_timestamps: If True exclude the timestamp column</span>
<span class="sd">            from the comparison.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_equals_internal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span><span class="p">)</span></div>
</div>



<span class="c1"># We define segment ordering by (left, right, node) tuples</span>
<div class="viewcode-block" id="IdentitySegment">
<a class="viewcode-back" href="../../python-api.html#tskit.IdentitySegment">[docs]</a>
<span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span><span class="p">(</span><span class="n">eq</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">IdentitySegment</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single segment of identity by descent spanning a genomic interval</span>
<span class="sd">    for a specific ancestor node.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">left</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The left genomic coordinate (inclusive).&quot;&quot;&quot;</span>
    <span class="n">right</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The right genomic coordinate (exclusive).&quot;&quot;&quot;</span>
    <span class="n">node</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The ID of the most recent common ancestor node.&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The length of the genomic region spanned by this identity segment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span></div>



<div class="viewcode-block" id="IdentitySegmentList">
<a class="viewcode-back" href="../../python-api.html#tskit.IdentitySegmentList">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IdentitySegmentList</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sized</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A summary of identity-by-descent segments for some pair of samples in a</span>
<span class="sd">    :class:`.IdentitySegments` result. If the ``store_segments`` argument</span>
<span class="sd">    has been specified to :meth:`.TreeSequence.ibd_segments`, this class</span>
<span class="sd">    can be treated as a sequence of :class:`.IdentitySegment` objects.</span>

<span class="sd">    Access to the segment data via numpy arrays is also available via</span>
<span class="sd">    the :attr:`.IdentitySegmentList.left`, :attr:`.IdentitySegmentList.right`</span>
<span class="sd">    and :attr:`.IdentitySegmentList.node` attributes.</span>

<span class="sd">    If ``store_segments`` is False, only the overall summary values</span>
<span class="sd">    such as :attr:`.IdentitySegmentList.total_span` and ``len()`` are</span>
<span class="sd">    available. Attempting to iterate over the list or access per-segment</span>
<span class="sd">    arrays (``left``, ``right``, or ``node``) in this case will raise an</span>
<span class="sd">    ``IdentitySegmentsNotStoredError``.</span>

<span class="sd">    .. warning:: The order of segments within an IdentitySegmentList is</span>
<span class="sd">        arbitrary and may change in the future</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ll_segment_list</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_segment_list</span> <span class="o">=</span> <span class="n">ll_segment_list</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">IdentitySegment</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">right</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_segment_list</span><span class="o">.</span><span class="n">num_segments</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;IdentitySegmentList(num_segments=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;total_span=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">total_span</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;IdentitySegmentList(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">IdentitySegmentList</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">total_span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The total genomic span covered by segments in this list. Equal to</span>
<span class="sd">        ``sum(seg.span for seg in seglst)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_segment_list</span><span class="o">.</span><span class="n">total_span</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A numpy array (dtype=np.float64) of the ``left`` coordinates of segments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_segment_list</span><span class="o">.</span><span class="n">left</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A numpy array (dtype=np.float64) of the ``right`` coordinates of segments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_segment_list</span><span class="o">.</span><span class="n">right</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A numpy array (dtype=np.int32) of the MRCA node IDs in segments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_segment_list</span><span class="o">.</span><span class="n">node</span></div>



<div class="viewcode-block" id="IdentitySegments">
<a class="viewcode-back" href="../../python-api.html#tskit.IdentitySegments">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">IdentitySegments</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class summarising and optionally storing the segments of identity</span>
<span class="sd">    by descent returned by :meth:`.TreeSequence.ibd_segments`. See the</span>
<span class="sd">    :ref:`sec_identity` for more information and examples.</span>

<span class="sd">    Along with the documented methods and attributes, the class supports</span>
<span class="sd">    the Python mapping protocol, and can be regarded as a dictionary</span>
<span class="sd">    mapping sample node pair tuples to the corresponding</span>
<span class="sd">    :class:`.IdentitySegmentList`.</span>

<span class="sd">    .. note:: It is important to note that the facilities available</span>
<span class="sd">       for a given instance of this class are determined by the</span>
<span class="sd">       ``store_pairs`` and ``store_segments`` arguments provided to</span>
<span class="sd">       :meth:`.TreeSequence.ibd_segments`. For example, attempting</span>
<span class="sd">       to access per-sample pair information (such as indexing with</span>
<span class="sd">       ``[(a, b)]``, iterating over the mapping, or accessing</span>
<span class="sd">       :attr:`.IdentitySegments.pairs`) if ``store_pairs`` is False will</span>
<span class="sd">       result in an ``IdentityPairsNotStoredError`` being raised.</span>

<span class="sd">    .. warning:: This class should not be instantiated directly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ll_result</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">max_time</span><span class="p">,</span> <span class="n">min_span</span><span class="p">,</span> <span class="n">store_segments</span><span class="p">,</span> <span class="n">store_pairs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_identity_segments</span> <span class="o">=</span> <span class="n">ll_result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_time</span> <span class="o">=</span> <span class="n">max_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_span</span> <span class="o">=</span> <span class="n">min_span</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_segments</span> <span class="o">=</span> <span class="n">store_segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">store_pairs</span> <span class="o">=</span> <span class="n">store_pairs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The total number of identity segments found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_identity_segments</span><span class="o">.</span><span class="n">num_segments</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The total number of distinct sample pairs for which identity</span>
<span class="sd">        segments were found. (Only available when ``store_pairs`` or</span>
<span class="sd">        ``store_segments`` is specified).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_identity_segments</span><span class="o">.</span><span class="n">num_pairs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">total_span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The total genomic sequence length spanned by all identity</span>
<span class="sd">        segments that were found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_identity_segments</span><span class="o">.</span><span class="n">total_span</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A numpy array with shape ``(segs.num_pairs, 2)`` and dtype=np.int32</span>
<span class="sd">        containing the sample pairs for which IBD segments were found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_identity_segments</span><span class="o">.</span><span class="n">get_keys</span><span class="p">()</span>

    <span class="c1"># We have two different versions of repr - one where we list out the segments</span>
    <span class="c1"># for debugging, and the other that just shows the standard representation.</span>
    <span class="c1"># We could have repr fail if store_segments isn&#39;t true, but then printing,</span>
    <span class="c1"># e.g., a list of IdentitySegments objects would fail unexpectedly.</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_segments</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;IdentitySegments(</span><span class="si">{</span><span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO it would be nice to add horizontal lines as</span>
        <span class="c1"># table separators to distinguish the two parts of the</span>
        <span class="c1"># table like suggested here:</span>
        <span class="c1"># https://github.com/tskit-dev/tskit/pull/1902#issuecomment-989943424</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;Parameters:&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;max_time&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_time</span><span class="p">)],</span>
            <span class="p">[</span><span class="s2">&quot;min_span&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_span</span><span class="p">)],</span>
            <span class="p">[</span><span class="s2">&quot;store_pairs&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store_pairs</span><span class="p">)],</span>
            <span class="p">[</span><span class="s2">&quot;store_segments&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">store_segments</span><span class="p">)],</span>
            <span class="p">[</span><span class="s2">&quot;Results:&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;num_segments&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_segments</span><span class="p">)],</span>
            <span class="p">[</span><span class="s2">&quot;total_span&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_span</span><span class="p">)],</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">store_pairs</span><span class="p">:</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="s2">&quot;num_pairs&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))])</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">unicode_table</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;IdentitySegments&quot;</span><span class="p">,</span> <span class="n">row_separator</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">sample_a</span><span class="p">,</span> <span class="n">sample_b</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">return</span> <span class="n">IdentitySegmentList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_identity_segments</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sample_a</span><span class="p">,</span> <span class="n">sample_b</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_identity_segments</span><span class="o">.</span><span class="n">get_keys</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_pairs</span></div>



<span class="c1"># TODO move to reference_sequence.py when we start adding more functionality.</span>
<div class="viewcode-block" id="ReferenceSequence">
<a class="viewcode-back" href="../../python-api.html#tskit.ReferenceSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ReferenceSequence</span><span class="p">(</span><span class="n">metadata</span><span class="o">.</span><span class="n">MetadataProvider</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :ref:`reference sequence&lt;sec_data_model_reference_sequence&gt;` associated</span>
<span class="sd">    with a given :class:`.TableCollection` or :class:`.TreeSequence`.</span>

<span class="sd">    Metadata concerning reference sequences can be described using the</span>
<span class="sd">    :attr:`.metadata_schema` and stored in the :attr:`.metadata` attribute.</span>
<span class="sd">    See the :ref:`examples&lt;sec_metadata_examples_reference_sequence&gt;` for</span>
<span class="sd">    idiomatic usage.</span>

<span class="sd">    .. warning:: This API is preliminary and currently only supports accessing</span>
<span class="sd">       reference sequence information via the ``.data`` attribute. Future versions</span>
<span class="sd">       will also enable transparent fetching of known reference sequences</span>
<span class="sd">       from a URL (see https://github.com/tskit-dev/tskit/issues/2022).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ll_reference_sequence</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ll_reference_sequence</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_reference_sequence</span> <span class="o">=</span> <span class="n">ll_reference_sequence</span>

<div class="viewcode-block" id="ReferenceSequence.is_null">
<a class="viewcode-back" href="../../python-api.html#tskit.ReferenceSequence.is_null">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_null</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if this :class:`.ReferenceSequence` is null, i.e.,</span>
<span class="sd">        all fields are empty.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_reference_sequence</span><span class="o">.</span><span class="n">is_null</span><span class="p">())</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>

    <span class="c1"># https://github.com/tskit-dev/tskit/issues/1984</span>
    <span class="c1"># TODO add a __str__ method</span>
    <span class="c1"># TODO add a _repr_html_</span>
    <span class="c1"># FIXME This is a shortcut, we want to put the values in explicitly</span>
    <span class="c1"># here to get more control over how they are displayed.</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;ReferenceSequence(</span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The string encoding of the reference sequence such that ``data[j]``</span>
<span class="sd">        represents the reference nucleotide at base ``j``. If this reference</span>
<span class="sd">        sequence is writable, the value can be assigned, e.g.</span>
<span class="sd">        ``tables.reference_sequence.data = &quot;ACGT&quot;``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_reference_sequence</span><span class="o">.</span><span class="n">data</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_reference_sequence</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">url</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_reference_sequence</span><span class="o">.</span><span class="n">url</span>

    <span class="nd">@url</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">url</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_reference_sequence</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;metadata_schema&quot;</span><span class="p">:</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="p">),</span>
            <span class="s2">&quot;metadata&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_bytes</span><span class="p">,</span>
            <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
            <span class="s2">&quot;url&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">assert_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_metadata</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Reference sequence data differs: self=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;other=</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">url</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">url</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Reference sequence url differs: self=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="si">}</span><span class="s2"> &quot;</span> <span class="sa">f</span><span class="s2">&quot;other=</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">url</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO this will be inefficient when we work with large references.</span>
        <span class="c1"># Make a dedicated low-level method for getting the length of data.</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>



<div class="viewcode-block" id="TableCollection">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TableCollection</span><span class="p">(</span><span class="n">metadata</span><span class="o">.</span><span class="n">MetadataProvider</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A collection of mutable tables defining a tree sequence. See the</span>
<span class="sd">    :ref:`sec_data_model` section for definition on the various tables</span>
<span class="sd">    and how they together define a :class:`TreeSequence`. Arbitrary</span>
<span class="sd">    data can be stored in a TableCollection, but there are certain</span>
<span class="sd">    :ref:`requirements &lt;sec_valid_tree_sequence_requirements&gt;` that must be</span>
<span class="sd">    satisfied for these tables to be interpreted as a tree sequence.</span>

<span class="sd">    To obtain an immutable :class:`TreeSequence` instance corresponding to the</span>
<span class="sd">    current state of a ``TableCollection``, please use the :meth:`.tree_sequence`</span>
<span class="sd">    method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">set_err_text</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;Cannot set tables in a table collection: use table.replace_with() instead.&quot;</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ll_tables</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span> <span class="o">=</span> <span class="n">ll_tables</span>
        <span class="k">if</span> <span class="n">ll_tables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_individuals</span> <span class="o">=</span> <span class="n">IndividualTable</span><span class="p">(</span><span class="n">ll_table</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="n">NodeTable</span><span class="p">(</span><span class="n">ll_table</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="n">EdgeTable</span><span class="p">(</span><span class="n">ll_table</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_migrations</span> <span class="o">=</span> <span class="n">MigrationTable</span><span class="p">(</span><span class="n">ll_table</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">migrations</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sites</span> <span class="o">=</span> <span class="n">SiteTable</span><span class="p">(</span><span class="n">ll_table</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">sites</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mutations</span> <span class="o">=</span> <span class="n">MutationTable</span><span class="p">(</span><span class="n">ll_table</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">mutations</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_populations</span> <span class="o">=</span> <span class="n">PopulationTable</span><span class="p">(</span><span class="n">ll_table</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">populations</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_provenances</span> <span class="o">=</span> <span class="n">ProvenanceTable</span><span class="p">(</span><span class="n">ll_table</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">provenances</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IndividualTable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :ref:`sec_individual_table_definition` in this collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals</span>

    <span class="nd">@individuals</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_err_text</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NodeTable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :ref:`sec_node_table_definition` in this collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span>

    <span class="nd">@nodes</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_err_text</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EdgeTable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :ref:`sec_edge_table_definition` in this collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span>

    <span class="nd">@edges</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_err_text</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">migrations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MigrationTable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :ref:`sec_migration_table_definition` in this collection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_migrations</span>

    <span class="nd">@migrations</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">migrations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_err_text</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SiteTable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :ref:`sec_site_table_definition` in this collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sites</span>

    <span class="nd">@sites</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_err_text</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MutationTable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :ref:`sec_mutation_table_definition` in this collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutations</span>

    <span class="nd">@mutations</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_err_text</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">populations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PopulationTable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :ref:`sec_population_table_definition` in this collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_populations</span>

    <span class="nd">@populations</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">populations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_err_text</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">provenances</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ProvenanceTable</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :ref:`sec_provenance_table_definition` in this collection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_provenances</span>

    <span class="nd">@provenances</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">provenances</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_err_text</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TableCollectionIndexes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The edge insertion and removal indexes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">indexes</span>
        <span class="k">return</span> <span class="n">TableCollectionIndexes</span><span class="p">(</span><span class="o">**</span><span class="n">indexes</span><span class="p">)</span>

    <span class="nd">@indexes</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indexes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">indexes</span> <span class="o">=</span> <span class="n">indexes</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sequence_length</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The sequence length defining the coordinate space.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">sequence_length</span>

    <span class="nd">@sequence_length</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sequence_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence_length</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">=</span> <span class="n">sequence_length</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">file_uuid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The UUID for the file this TableCollection is derived</span>
<span class="sd">        from, or None if not derived from a file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">file_uuid</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time_units</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The units used for the time dimension of this TableCollection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">time_units</span>

    <span class="nd">@time_units</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_units</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">time_units</span> <span class="o">=</span> <span class="n">time_units</span>

<div class="viewcode-block" id="TableCollection.has_reference_sequence">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.has_reference_sequence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_reference_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if this :class:`.TableCollection` has an associated</span>
<span class="sd">        :ref:`reference sequence&lt;sec_data_model_reference_sequence&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">has_reference_sequence</span><span class="p">())</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reference_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`.ReferenceSequence` associated with this :class:`.TableCollection`.</span>

<span class="sd">        .. note:: Note that the behaviour of this attribute differs from</span>
<span class="sd">            :attr:`.TreeSequence.reference_sequence` in that we return a valid</span>
<span class="sd">            instance of :class:`.ReferenceSequence` even when</span>
<span class="sd">            :attr:`.TableCollection.has_reference_sequence` is False. This is</span>
<span class="sd">            to allow us to update the state of the reference sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE: arguably we should cache the reference to this object</span>
        <span class="c1"># during init, rather than creating a new instance each time.</span>
        <span class="c1"># However, following the pattern of the Table classes for now</span>
        <span class="c1"># for consistency.</span>
        <span class="k">return</span> <span class="n">ReferenceSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">reference_sequence</span><span class="p">)</span>

    <span class="nd">@reference_sequence</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reference_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ReferenceSequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_sequence</span><span class="o">.</span><span class="n">metadata_schema</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">metadata_schema</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_sequence</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_sequence</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_sequence</span><span class="o">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">url</span>

<div class="viewcode-block" id="TableCollection.asdict">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.asdict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_offset_64</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the nested dictionary representation of this TableCollection</span>
<span class="sd">        used for interchange.</span>

<span class="sd">        Note: the semantics of this method changed at tskit 0.1.0. Previously a</span>
<span class="sd">        map of table names to the tables themselves was returned.</span>

<span class="sd">        :param bool force_offset_64: If True, all offset columns will have dtype</span>
<span class="sd">            np.uint64. If False (the default) the offset array columns will have</span>
<span class="sd">            a dtype of either np.uint32 or np.uint64, depending on the size of the</span>
<span class="sd">            corresponding data array.</span>
<span class="sd">        :return: The dictionary representation of this table collection.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="n">force_offset_64</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">table_name_map</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary mapping table names to the corresponding</span>
<span class="sd">        table instances. For example, the returned dictionary will contain the</span>
<span class="sd">        key &quot;edges&quot; that maps to an :class:`.EdgeTable` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;edges&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span>
            <span class="s2">&quot;individuals&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span>
            <span class="s2">&quot;migrations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="p">,</span>
            <span class="s2">&quot;mutations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="p">,</span>
            <span class="s2">&quot;nodes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
            <span class="s2">&quot;populations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">,</span>
            <span class="s2">&quot;provenances&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="p">,</span>
            <span class="s2">&quot;sites&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">name_map</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c1"># Deprecated in 0.4.1</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;name_map is deprecated; use table_name_map instead&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_name_map</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total number of bytes required to store the data</span>
<span class="sd">        in this table collection. Note that this may not be equal to</span>
<span class="sd">        the actual memory footprint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="mi">8</span><span class="p">,</span>  <span class="c1"># sequence_length takes 8 bytes</span>
                <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span>  <span class="c1"># metadata</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_units</span><span class="o">.</span><span class="n">encode</span><span class="p">()),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reference_sequence</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span>
                <span class="nb">sum</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">nbytes</span> <span class="k">for</span> <span class="n">table</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_name_map</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a plain text summary of this TableCollection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="s2">&quot;TableCollection&quot;</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Sequence Length: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Time units: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">time_units</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Metadata: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Individuals&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">),</span>
                <span class="s2">&quot;Nodes&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span>
                <span class="s2">&quot;Edges&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">),</span>
                <span class="s2">&quot;Sites&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">),</span>
                <span class="s2">&quot;Mutations&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="p">),</span>
                <span class="s2">&quot;Migrations&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="p">),</span>
                <span class="s2">&quot;Populations&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">),</span>
                <span class="s2">&quot;Provenances&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TableCollection.equals">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.equals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_tables</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_reference_sequence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if  `self` and `other` are equal. By default, two table</span>
<span class="sd">        collections are considered equal if their</span>

<span class="sd">        - ``sequence_length`` properties are identical;</span>
<span class="sd">        - top-level tree sequence metadata and metadata schemas are</span>
<span class="sd">          byte-wise identical;</span>
<span class="sd">        - constituent tables are byte-wise identical.</span>

<span class="sd">        Some of the requirements in this definition can be relaxed using the</span>
<span class="sd">        parameters, which can be used to remove certain parts of the data model</span>
<span class="sd">        from the comparison.</span>

<span class="sd">        Table indexes are not considered in the equality comparison.</span>

<span class="sd">        :param TableCollection other: Another table collection.</span>
<span class="sd">        :param bool ignore_metadata: If True *all* metadata and metadata schemas</span>
<span class="sd">            will be excluded from the comparison. This includes the top-level</span>
<span class="sd">            tree sequence and constituent table metadata (default=False).</span>
<span class="sd">        :param bool ignore_ts_metadata: If True the top-level tree sequence</span>
<span class="sd">            metadata and metadata schemas will be excluded from the comparison.</span>
<span class="sd">            If ``ignore_metadata`` is True, this parameter has no effect.</span>
<span class="sd">        :param bool ignore_provenance: If True the provenance tables are</span>
<span class="sd">            not included in the comparison.</span>
<span class="sd">        :param bool ignore_timestamps: If True the provenance timestamp column</span>
<span class="sd">            is ignored in the comparison. If ``ignore_provenance`` is True, this</span>
<span class="sd">            parameter has no effect.</span>
<span class="sd">        :param bool ignore_tables: If True no tables are included in the</span>
<span class="sd">            comparison, thus comparing only the top-level information.</span>
<span class="sd">        :param bool ignore_reference_sequence: If True the reference sequence</span>
<span class="sd">            is not included in the comparison.</span>
<span class="sd">        :return: True if other is equal to this table collection; False otherwise.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">_ll_tables</span><span class="p">,</span>
                    <span class="n">ignore_metadata</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">ignore_metadata</span><span class="p">),</span>
                    <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">ignore_ts_metadata</span><span class="p">),</span>
                    <span class="n">ignore_provenance</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">ignore_provenance</span><span class="p">),</span>
                    <span class="n">ignore_timestamps</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">ignore_timestamps</span><span class="p">),</span>
                    <span class="n">ignore_tables</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">ignore_tables</span><span class="p">),</span>
                    <span class="n">ignore_reference_sequence</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">ignore_reference_sequence</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;_llts&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;_ll_tables&quot;</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">,</span>
                <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="n">ignore_ts_metadata</span><span class="p">,</span>
                <span class="n">ignore_provenance</span><span class="o">=</span><span class="n">ignore_provenance</span><span class="p">,</span>
                <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span><span class="p">,</span>
                <span class="n">ignore_tables</span><span class="o">=</span><span class="n">ignore_tables</span><span class="p">,</span>
                <span class="n">ignore_reference_sequence</span><span class="o">=</span><span class="n">ignore_reference_sequence</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="TableCollection.assert_equals">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.assert_equals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assert_equals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_tables</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_reference_sequence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise an AssertionError for the first found difference between</span>
<span class="sd">        this and another table collection. Note that table indexes are not checked.</span>

<span class="sd">        :param other: Another table collection (TableCollection or</span>
<span class="sd">            ImmutableTableCollection).</span>
<span class="sd">        :param bool ignore_metadata: If True *all* metadata and metadata schemas</span>
<span class="sd">            will be excluded from the comparison. This includes the top-level</span>
<span class="sd">            tree sequence and constituent table metadata (default=False).</span>
<span class="sd">        :param bool ignore_ts_metadata: If True the top-level tree sequence</span>
<span class="sd">            metadata and metadata schemas will be excluded from the comparison.</span>
<span class="sd">            If ``ignore_metadata`` is True, this parameter has no effect.</span>
<span class="sd">        :param bool ignore_provenance: If True the provenance tables are</span>
<span class="sd">            not included in the comparison.</span>
<span class="sd">        :param bool ignore_timestamps: If True the provenance timestamp column</span>
<span class="sd">            is ignored in the comparison. If ``ignore_provenance`` is True, this</span>
<span class="sd">            parameter has no effect.</span>
<span class="sd">        :param bool ignore_tables: If True no tables are included in the</span>
<span class="sd">            comparison, thus comparing only the top-level information.</span>
<span class="sd">        :param bool ignore_reference_sequence: If True the reference sequence</span>
<span class="sd">            is not included in the comparison.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check using the low-level method to avoid slowly going through everything</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">,</span>
            <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="n">ignore_ts_metadata</span><span class="p">,</span>
            <span class="n">ignore_provenance</span><span class="o">=</span><span class="n">ignore_provenance</span><span class="p">,</span>
            <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span><span class="p">,</span>
            <span class="n">ignore_tables</span><span class="o">=</span><span class="n">ignore_tables</span><span class="p">,</span>
            <span class="n">ignore_reference_sequence</span><span class="o">=</span><span class="n">ignore_reference_sequence</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span>

        <span class="n">valid_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">TableCollection</span><span class="p">,</span> <span class="n">ImmutableTableCollection</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">valid_types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Types differ: self=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> other=</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">_assert_table_collections_equal</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">,</span>
            <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="n">ignore_ts_metadata</span><span class="p">,</span>
            <span class="n">ignore_provenance</span><span class="o">=</span><span class="n">ignore_provenance</span><span class="p">,</span>
            <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span><span class="p">,</span>
            <span class="n">ignore_tables</span><span class="o">=</span><span class="n">ignore_tables</span><span class="p">,</span>
            <span class="n">ignore_reference_sequence</span><span class="o">=</span><span class="n">ignore_reference_sequence</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_or_path</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">skip_tables</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_reference_sequence</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">file</span><span class="p">,</span> <span class="n">local_file</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">convert_file_like_to_open_file</span><span class="p">(</span><span class="n">file_or_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
        <span class="n">ll_tc</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ll_tc</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                <span class="n">file</span><span class="p">,</span>
                <span class="n">skip_tables</span><span class="o">=</span><span class="n">skip_tables</span><span class="p">,</span>
                <span class="n">skip_reference_sequence</span><span class="o">=</span><span class="n">skip_reference_sequence</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">TableCollection</span><span class="p">(</span><span class="n">ll_tables</span><span class="o">=</span><span class="n">ll_tc</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">tskit</span><span class="o">.</span><span class="n">FileFormatError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">raise_known_file_format_errors</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">local_file</span><span class="p">:</span>
                <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<div class="viewcode-block" id="TableCollection.dump">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.dump">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_or_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the table collection to the specified path or file object.</span>

<span class="sd">        :param str file_or_path: The file object or path to write the TreeSequence to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">file</span><span class="p">,</span> <span class="n">local_file</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">convert_file_like_to_open_file</span><span class="p">(</span><span class="n">file_or_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">local_file</span><span class="p">:</span>
                <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


    <span class="c1"># Unpickle support</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fromdict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tables_dict</span><span class="p">):</span>
        <span class="n">ll_tc</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">()</span>
        <span class="n">ll_tc</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="n">tables_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TableCollection</span><span class="p">(</span><span class="n">ll_tables</span><span class="o">=</span><span class="n">ll_tc</span><span class="p">)</span>

<div class="viewcode-block" id="TableCollection.copy">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a deep copy of this TableCollection.</span>

<span class="sd">        :return: A deep copy of this TableCollection.</span>
<span class="sd">        :rtype: tskit.TableCollection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TableCollection</span><span class="o">.</span><span class="n">fromdict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asdict</span><span class="p">())</span></div>


<div class="viewcode-block" id="TableCollection.tree_sequence">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.tree_sequence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tree_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a :class:`TreeSequence` instance from the tables defined in this</span>
<span class="sd">        :class:`TableCollection`, building the required indexes if they have not yet</span>
<span class="sd">        been created by :meth:`.build_index`. If the table collection does not meet</span>
<span class="sd">        the :ref:`sec_valid_tree_sequence_requirements`, for example if the tables</span>
<span class="sd">        are not correctly sorted or if they cannot be interpreted as a tree sequence,</span>
<span class="sd">        an exception is raised. Note that in the former case, the :meth:`.sort`</span>
<span class="sd">        method may be used to ensure that sorting requirements are met.</span>

<span class="sd">        :return: A :class:`TreeSequence` instance reflecting the structures</span>
<span class="sd">            defined in this set of tables.</span>
<span class="sd">        :rtype: tskit.TreeSequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_index</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build_index</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TreeSequence</span><span class="o">.</span><span class="n">load_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="TableCollection.simplify">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.simplify">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simplify</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">reduce_to_site_topology</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_populations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">filter_individuals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">filter_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">filter_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">update_sample_flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_unary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_unary_in_individuals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_input_roots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">filter_zero_mutation_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Deprecated alias for filter_sites</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simplifies the tables in place to retain only the information necessary</span>
<span class="sd">        to reconstruct the tree sequence describing the given ``samples``.</span>
<span class="sd">        If ``filter_nodes`` is True (the default), this can change the ID of</span>
<span class="sd">        the nodes, so that the node ``samples[k]`` will have ID ``k`` in the</span>
<span class="sd">        result, resulting in a NodeTable where only the first ``len(samples)``</span>
<span class="sd">        nodes are marked as samples. The mapping from node IDs in the current</span>
<span class="sd">        set of tables to their equivalent values in the simplified tables is</span>
<span class="sd">        returned as a numpy array. If an array ``a`` is returned by this</span>
<span class="sd">        function and ``u`` is the ID of a node in the input table, then</span>
<span class="sd">        ``a[u]`` is the ID of this node in the output table. For any node ``u``</span>
<span class="sd">        that is not mapped into the output tables, this mapping will equal</span>
<span class="sd">        ``tskit.NULL`` (``-1``).</span>

<span class="sd">        Tables operated on by this function must: be sorted (see</span>
<span class="sd">        :meth:`TableCollection.sort`), have children be born strictly after their</span>
<span class="sd">        parents, and the intervals on which any node is a child must be</span>
<span class="sd">        disjoint. Other than this the tables need not satisfy remaining</span>
<span class="sd">        requirements to specify a valid tree sequence (but the resulting tables</span>
<span class="sd">        will).</span>

<span class="sd">        .. note::</span>
<span class="sd">            To invert the returned ``node_map``, that is, to obtain a reverse</span>
<span class="sd">            mapping from the node ID in the output table to the node ID in</span>
<span class="sd">            the input table, you can use::</span>

<span class="sd">                rev_map = np.zeros_like(node_map, shape=simplified_ts.num_nodes)</span>
<span class="sd">                kept = node_map != tskit.NULL</span>
<span class="sd">                rev_map[node_map[kept]] = np.arange(len(node_map))[kept]</span>

<span class="sd">            In this case, no elements of the ``rev_map`` array will be set to</span>
<span class="sd">            ``tskit.NULL``.</span>

<span class="sd">        .. seealso::</span>
<span class="sd">            This is identical to :meth:`TreeSequence.simplify` but acts *in place* to</span>
<span class="sd">            alter the data in this :class:`TableCollection`. Please see the</span>
<span class="sd">            :meth:`TreeSequence.simplify` method for a description of the remaining</span>
<span class="sd">            parameters.</span>

<span class="sd">        :param list[int] samples: A list of node IDs to retain as samples. They</span>
<span class="sd">            need not be nodes marked as samples in the original tree sequence, but</span>
<span class="sd">            will constitute the entire set of samples in the returned tree sequence.</span>
<span class="sd">            If not specified or None, use all nodes marked with the IS_SAMPLE flag.</span>
<span class="sd">            The list may be provided as a numpy array (or array-like) object</span>
<span class="sd">            (dtype=np.int32).</span>
<span class="sd">        :param bool reduce_to_site_topology: Whether to reduce the topology down</span>
<span class="sd">            to the trees that are present at sites. (Default: False).</span>
<span class="sd">        :param bool filter_populations: If True, remove any populations that are</span>
<span class="sd">            not referenced by nodes after simplification; new population IDs are</span>
<span class="sd">            allocated sequentially from zero. If False, the population table will</span>
<span class="sd">            not be altered in any way. (Default: None, treated as True)</span>
<span class="sd">        :param bool filter_individuals: If True, remove any individuals that are</span>
<span class="sd">            not referenced by nodes after simplification; new individual IDs are</span>
<span class="sd">            allocated sequentially from zero. If False, the individual table will</span>
<span class="sd">            not be altered in any way. (Default: None, treated as True)</span>
<span class="sd">        :param bool filter_sites: If True, remove any sites that are</span>
<span class="sd">            not referenced by mutations after simplification; new site IDs are</span>
<span class="sd">            allocated sequentially from zero. If False, the site table will not</span>
<span class="sd">            be altered in any way. (Default: None, treated as True)</span>
<span class="sd">        :param bool filter_nodes: If True, remove any nodes that are</span>
<span class="sd">            not referenced by edges after simplification. If False, the only</span>
<span class="sd">            potential change to the node table may be to change the node flags</span>
<span class="sd">            (if ``samples`` is specified and different from the existing samples).</span>
<span class="sd">            (Default: None, treated as True)</span>
<span class="sd">        :param bool update_sample_flags: If True, update node flags to so that</span>
<span class="sd">            nodes in the specified list of samples have the NODE_IS_SAMPLE</span>
<span class="sd">            flag after simplification, and nodes that are not in this list</span>
<span class="sd">            do not. (Default: None, treated as True)</span>
<span class="sd">        :param bool keep_unary: If True, preserve unary nodes (i.e. nodes with</span>
<span class="sd">            exactly one child) that exist on the path from samples to root.</span>
<span class="sd">            (Default: False)</span>
<span class="sd">        :param bool keep_unary_in_individuals: If True, preserve unary nodes</span>
<span class="sd">            that exist on the path from samples to root, but only if they are</span>
<span class="sd">            associated with an individual in the individuals table. Cannot be</span>
<span class="sd">            specified at the same time as ``keep_unary``. (Default: ``None``,</span>
<span class="sd">            equivalent to False)</span>
<span class="sd">        :param bool keep_input_roots: Whether to retain history ancestral to the</span>
<span class="sd">            MRCA of the samples. If ``False``, no topology older than the MRCAs of the</span>
<span class="sd">            samples will be included. If ``True`` the roots of all trees in the returned</span>
<span class="sd">            tree sequence will be the same roots as in the original tree sequence.</span>
<span class="sd">            (Default: False)</span>
<span class="sd">        :param bool record_provenance: If True, record details of this call to</span>
<span class="sd">            simplify in the returned tree sequence&#39;s provenance information</span>
<span class="sd">            (Default: True).</span>
<span class="sd">        :param bool filter_zero_mutation_sites: Deprecated alias for ``filter_sites``.</span>
<span class="sd">        :return: A numpy array mapping node IDs in the input tables to their</span>
<span class="sd">            corresponding node IDs in the output tables.</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filter_zero_mutation_sites</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Deprecated in msprime 0.6.1.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;filter_zero_mutation_sites is deprecated; use filter_sites instead&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">filter_sites</span> <span class="o">=</span> <span class="n">filter_zero_mutation_sites</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">flags</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">flags</span><span class="p">,</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span>
                <span class="mi">0</span>
            <span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filter_populations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_populations</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">filter_individuals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_individuals</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">filter_sites</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_sites</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">filter_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_nodes</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">update_sample_flags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">update_sample_flags</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">keep_unary_in_individuals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep_unary_in_individuals</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">node_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
            <span class="n">samples</span><span class="p">,</span>
            <span class="n">filter_sites</span><span class="o">=</span><span class="n">filter_sites</span><span class="p">,</span>
            <span class="n">filter_individuals</span><span class="o">=</span><span class="n">filter_individuals</span><span class="p">,</span>
            <span class="n">filter_populations</span><span class="o">=</span><span class="n">filter_populations</span><span class="p">,</span>
            <span class="n">filter_nodes</span><span class="o">=</span><span class="n">filter_nodes</span><span class="p">,</span>
            <span class="n">update_sample_flags</span><span class="o">=</span><span class="n">update_sample_flags</span><span class="p">,</span>
            <span class="n">reduce_to_site_topology</span><span class="o">=</span><span class="n">reduce_to_site_topology</span><span class="p">,</span>
            <span class="n">keep_unary</span><span class="o">=</span><span class="n">keep_unary</span><span class="p">,</span>
            <span class="n">keep_unary_in_individuals</span><span class="o">=</span><span class="n">keep_unary_in_individuals</span><span class="p">,</span>
            <span class="n">keep_input_roots</span><span class="o">=</span><span class="n">keep_input_roots</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
            <span class="c1"># TODO replace with a version of https://github.com/tskit-dev/tskit/pull/243</span>
            <span class="c1"># TODO also make sure we convert all the arguments so that they are</span>
            <span class="c1"># definitely JSON encodable.</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;simplify&quot;</span><span class="p">,</span> <span class="s2">&quot;TODO&quot;</span><span class="p">:</span> <span class="s2">&quot;add simplify parameters&quot;</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">node_map</span></div>


<div class="viewcode-block" id="TableCollection.link_ancestors">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.link_ancestors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">link_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">ancestors</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an :class:`EdgeTable` instance describing a subset of the genealogical</span>
<span class="sd">        relationships between the nodes in ``samples`` and ``ancestors``.</span>

<span class="sd">        Each row ``parent, child, left, right`` in the output table indicates that</span>
<span class="sd">        ``child`` has inherited the segment ``[left, right)`` from ``parent`` more</span>
<span class="sd">        recently than from any other node in these lists.</span>

<span class="sd">        In particular, suppose ``samples`` is a list of nodes such that ``time`` is 0</span>
<span class="sd">        for each node, and ``ancestors`` is a list of nodes such that ``time`` is</span>
<span class="sd">        greater than 0.0 for each node. Then each row of the output table will show</span>
<span class="sd">        an interval ``[left, right)`` over which a node in ``samples`` has inherited</span>
<span class="sd">        most recently from a node in ``ancestors``, or an interval over which one of</span>
<span class="sd">        these ``ancestors`` has inherited most recently from another node in</span>
<span class="sd">        ``ancestors``.</span>

<span class="sd">        The following table shows which ``parent-&gt;child`` pairs will be shown in the</span>
<span class="sd">        output of ``link_ancestors``.</span>
<span class="sd">        A node is a relevant descendant on a given interval if it also appears somewhere</span>
<span class="sd">        in the ``parent`` column of the outputted table.</span>

<span class="sd">        ========================  ===============================================</span>
<span class="sd">        Type of relationship      Shown in output of ``link_ancestors``</span>
<span class="sd">        ------------------------  -----------------------------------------------</span>
<span class="sd">        ``ancestor-&gt;sample``      Always</span>
<span class="sd">        ``ancestor1-&gt;ancestor2``  Only if ``ancestor2`` has a relevant descendant</span>
<span class="sd">        ``sample1-&gt;sample2``      Always</span>
<span class="sd">        ``sample-&gt;ancestor``      Only if ``ancestor`` has a relevant descendant</span>
<span class="sd">        ========================  ===============================================</span>

<span class="sd">        The difference between ``samples`` and ``ancestors`` is that information about</span>
<span class="sd">        the ancestors of a node in ``ancestors`` will only be retained if it also has a</span>
<span class="sd">        relevant descendant, while information about the ancestors of a node in</span>
<span class="sd">        ``samples`` will always be retained.</span>
<span class="sd">        The node IDs in ``parent`` and ``child`` refer to the IDs in the node table</span>
<span class="sd">        of the inputted tree sequence.</span>

<span class="sd">        The supplied nodes must be non-empty lists of the node IDs in the tree sequence:</span>
<span class="sd">        in particular, they do not have to be *samples* of the tree sequence. The lists</span>
<span class="sd">        of ``samples`` and ``ancestors`` may overlap, although adding a node from</span>
<span class="sd">        ``samples`` to ``ancestors`` will not change the output. So, setting ``samples``</span>
<span class="sd">        and ``ancestors`` to the same list of nodes will find all genealogical</span>
<span class="sd">        relationships within this list.</span>

<span class="sd">        If none of the nodes in ``ancestors`` or ``samples`` are ancestral to ``samples``</span>
<span class="sd">        anywhere in the tree sequence, an empty table will be returned.</span>

<span class="sd">        :param list[int] samples: A list of node IDs to retain as samples.</span>
<span class="sd">        :param list[int] ancestors: A list of node IDs to use as ancestors.</span>
<span class="sd">        :return: An :class:`EdgeTable` instance displaying relationships between</span>
<span class="sd">            the `samples` and `ancestors`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">ancestors</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">ancestors</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">ll_edge_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">link_ancestors</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">ancestors</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EdgeTable</span><span class="p">(</span><span class="n">ll_table</span><span class="o">=</span><span class="n">ll_edge_table</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">map_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># A deprecated alias for link_ancestors()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">link_ancestors</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="TableCollection.sort">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.sort">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">site_start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mutation_start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts the tables in place. This ensures that all tree sequence ordering</span>
<span class="sd">        requirements listed in the</span>
<span class="sd">        :ref:`sec_valid_tree_sequence_requirements` section are met, as long</span>
<span class="sd">        as each site has at most one mutation (see below).</span>

<span class="sd">        If the ``edge_start`` parameter is provided, this specifies the index</span>
<span class="sd">        in the edge table where sorting should start. Only rows with index</span>
<span class="sd">        greater than or equal to ``edge_start`` are sorted; rows before this index</span>
<span class="sd">        are not affected. This parameter is provided to allow for efficient sorting</span>
<span class="sd">        when the user knows that the edges up to a given index are already sorted.</span>

<span class="sd">        If both ``site_start`` and ``mutation_start`` are equal to the number of rows</span>
<span class="sd">        in their retrospective tables then neither is sorted. Note that a partial</span>
<span class="sd">        non-sorting is not possible, and both or neither must be skipped.</span>

<span class="sd">        The node, individual, population and provenance tables are not affected</span>
<span class="sd">        by this method.</span>

<span class="sd">        Edges are sorted as follows:</span>

<span class="sd">        - time of parent, then</span>
<span class="sd">        - parent node ID, then</span>
<span class="sd">        - child node ID, then</span>
<span class="sd">        - left endpoint.</span>

<span class="sd">        Note that this sorting order exceeds the</span>
<span class="sd">        :ref:`edge sorting requirements &lt;sec_edge_requirements&gt;` for a valid</span>
<span class="sd">        tree sequence. For a valid tree sequence, we require that all edges for a</span>
<span class="sd">        given parent ID are adjacent, but we do not require that they be listed in</span>
<span class="sd">        sorted order.</span>

<span class="sd">        Sites are sorted by position, and sites with the same position retain</span>
<span class="sd">        their relative ordering.</span>

<span class="sd">        Mutations are sorted by site, then time (if known), then the mutation&#39;s</span>
<span class="sd">        node&#39;s time, then number of descendant mutations (ensuring that parent</span>
<span class="sd">        mutations occur before children), then node, then original order in the</span>
<span class="sd">        tables.</span>

<span class="sd">        Migrations are sorted by ``time``, ``source``, ``dest``, ``left`` and</span>
<span class="sd">        ``node`` values. This defines a total sort order, such that any permutation</span>
<span class="sd">        of a valid migration table will be sorted into the same output order.</span>
<span class="sd">        Note that this sorting order exceeds the</span>
<span class="sd">        :ref:`migration sorting requirements &lt;sec_migration_requirements&gt;` for a</span>
<span class="sd">        valid tree sequence, which only requires that migrations are sorted by</span>
<span class="sd">        time value.</span>

<span class="sd">        :param int edge_start: The index in the edge table where sorting starts</span>
<span class="sd">            (default=0; must be &lt;= len(edges)).</span>
<span class="sd">        :param int site_start: The index in the site table where sorting starts</span>
<span class="sd">            (default=0; must be one of [0, len(sites)]).</span>
<span class="sd">        :param int mutation_start: The index in the mutation table where sorting starts</span>
<span class="sd">            (default=0; must be one of [0, len(mutations)]).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">edge_start</span><span class="p">,</span> <span class="n">site_start</span><span class="p">,</span> <span class="n">mutation_start</span><span class="p">)</span></div>

        <span class="c1"># TODO add provenance</span>

<div class="viewcode-block" id="TableCollection.sort_individuals">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.sort_individuals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sort_individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts the individual table in place, so that parents come before children,</span>
<span class="sd">        and the parent column is remapped as required. Node references to individuals</span>
<span class="sd">        are also updated. This is a stricter order than is required for a valid tree</span>
<span class="sd">        sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">sort_individuals</span><span class="p">()</span></div>

        <span class="c1"># TODO add provenance</span>

<div class="viewcode-block" id="TableCollection.canonicalise">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.canonicalise">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">canonicalise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove_unreferenced</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This puts the tables in *canonical* form, imposing a stricter order on the</span>
<span class="sd">        tables than :ref:`required &lt;sec_valid_tree_sequence_requirements&gt;` for</span>
<span class="sd">        a valid tree sequence. In particular, the population table is sorted to</span>
<span class="sd">        place populations with the lowest node IDs first, and the individual table</span>
<span class="sd">        is sorted firstly as in :meth:`.sort_individuals` and secondarily</span>
<span class="sd">        by the lowest ID of the nodes that refer to each individual</span>
<span class="sd">        (see :meth:`TreeSequence.subset`). The remaining tables are sorted</span>
<span class="sd">        as in :meth:`.sort`, with the modification that mutations are sorted by</span>
<span class="sd">        site, then time (if known), then the mutation&#39;s node&#39;s time, then number</span>
<span class="sd">        of descendant mutations (ensuring that parent mutations occur before</span>
<span class="sd">        children), then node, then original order in the tables. This ensures</span>
<span class="sd">        that any two tables with the same information</span>
<span class="sd">        and node order should be identical after canonical sorting (note</span>
<span class="sd">        that no canonical order exists for the node table).</span>

<span class="sd">        By default, the method removes sites, individuals, and populations that</span>
<span class="sd">        are not referenced (by mutations and nodes, respectively). If you wish</span>
<span class="sd">        to keep these, pass ``remove_unreferenced=False``, but note that</span>
<span class="sd">        unreferenced individuals and populations are put at the end of the tables</span>
<span class="sd">        in their original order.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.sort` for sorting edges, mutations, and sites, and</span>
<span class="sd">            :meth:`.subset` for reordering nodes, individuals, and populations.</span>

<span class="sd">        :param bool remove_unreferenced: Whether to remove unreferenced sites,</span>
<span class="sd">            individuals, and populations (default=True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">remove_unreferenced</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">True</span> <span class="k">if</span> <span class="n">remove_unreferenced</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">remove_unreferenced</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">canonicalise</span><span class="p">(</span><span class="n">remove_unreferenced</span><span class="o">=</span><span class="n">remove_unreferenced</span><span class="p">)</span></div>

        <span class="c1"># TODO add provenance</span>

<div class="viewcode-block" id="TableCollection.compute_mutation_parents">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.compute_mutation_parents">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_mutation_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies the tables in place, computing the ``parent`` column of the</span>
<span class="sd">        mutation table. For this to work, the node and edge tables must be</span>
<span class="sd">        valid, and the site and mutation tables must be sorted (see</span>
<span class="sd">        :meth:`TableCollection.sort`).  This will produce an error if mutations</span>
<span class="sd">        are not sorted (i.e., if a mutation appears before its mutation parent)</span>
<span class="sd">        *unless* the two mutations occur on the same branch, and have unknown times</span>
<span class="sd">        in which case there is no way to detect the error.</span>

<span class="sd">        The ``parent`` of a given mutation is the ID of the next mutation</span>
<span class="sd">        encountered traversing the tree upwards from that mutation, or</span>
<span class="sd">        ``NULL`` if there is no such mutation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">compute_mutation_parents</span><span class="p">()</span></div>

        <span class="c1"># TODO add provenance</span>

<div class="viewcode-block" id="TableCollection.compute_mutation_times">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.compute_mutation_times">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_mutation_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies the tables in place, computing valid values for the ``time`` column of</span>
<span class="sd">        the mutation table. For this to work, the node and edge tables must be</span>
<span class="sd">        valid, and the site and mutation tables must be sorted and indexed(see</span>
<span class="sd">        :meth:`TableCollection.sort` and :meth:`TableCollection.build_index`).</span>

<span class="sd">        For a single mutation on an edge at a site, the ``time`` assigned to a mutation</span>
<span class="sd">        by this method is the mid-point between the times of the nodes above and below</span>
<span class="sd">        the mutation. In the case where there is more than one mutation on an edge for</span>
<span class="sd">        a site, the times are evenly spread along the edge. For mutations that are</span>
<span class="sd">        above a root node, the time of the root node is assigned.</span>

<span class="sd">        The mutation table will be sorted if the new times mean that the original order</span>
<span class="sd">        is no longer valid.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">compute_mutation_times</span><span class="p">()</span></div>

        <span class="c1"># TODO add provenance</span>

<div class="viewcode-block" id="TableCollection.deduplicate_sites">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.deduplicate_sites">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">deduplicate_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies the tables in place, removing entries in the site table with</span>
<span class="sd">        duplicate ``position`` (and keeping only the *first* entry for each</span>
<span class="sd">        site), and renumbering the ``site`` column of the mutation table</span>
<span class="sd">        appropriately.  This requires the site table to be sorted by position.</span>

<span class="sd">        .. warning:: This method does not sort the tables afterwards, so</span>
<span class="sd">            mutations may no longer be sorted by time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">deduplicate_sites</span><span class="p">()</span></div>

        <span class="c1"># TODO add provenance</span>

<div class="viewcode-block" id="TableCollection.delete_sites">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.delete_sites">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site_ids</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the specified sites entirely from the sites and mutations tables in this</span>
<span class="sd">        collection. This is identical to :meth:`TreeSequence.delete_sites` but acts</span>
<span class="sd">        *in place* to alter the data in this :class:`TableCollection`.</span>

<span class="sd">        :param list[int] site_ids: A list of site IDs specifying the sites to remove.</span>
<span class="sd">        :param bool record_provenance: If ``True``, add details of this operation</span>
<span class="sd">            to the provenance table in this TableCollection. (Default: ``True``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keep_sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">site_ids</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">site_ids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">site_ids</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">site_ids</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Site ID out of bounds&quot;</span><span class="p">)</span>
        <span class="n">keep_sites</span><span class="p">[</span><span class="n">site_ids</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">new_as</span><span class="p">,</span> <span class="n">new_as_offset</span> <span class="o">=</span> <span class="n">keep_with_offset</span><span class="p">(</span>
            <span class="n">keep_sites</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">ancestral_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">ancestral_state_offset</span>
        <span class="p">)</span>
        <span class="n">new_md</span><span class="p">,</span> <span class="n">new_md_offset</span> <span class="o">=</span> <span class="n">keep_with_offset</span><span class="p">(</span>
            <span class="n">keep_sites</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">metadata_offset</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="n">position</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span><span class="p">[</span><span class="n">keep_sites</span><span class="p">],</span>
            <span class="n">ancestral_state</span><span class="o">=</span><span class="n">new_as</span><span class="p">,</span>
            <span class="n">ancestral_state_offset</span><span class="o">=</span><span class="n">new_as_offset</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">new_md</span><span class="p">,</span>
            <span class="n">metadata_offset</span><span class="o">=</span><span class="n">new_md_offset</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># We also need to adjust the mutations table, as it references into sites</span>
        <span class="n">keep_mutations</span> <span class="o">=</span> <span class="n">keep_sites</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">site</span><span class="p">]</span>
        <span class="n">new_ds</span><span class="p">,</span> <span class="n">new_ds_offset</span> <span class="o">=</span> <span class="n">keep_with_offset</span><span class="p">(</span>
            <span class="n">keep_mutations</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">derived_state</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">derived_state_offset</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">new_md</span><span class="p">,</span> <span class="n">new_md_offset</span> <span class="o">=</span> <span class="n">keep_with_offset</span><span class="p">(</span>
            <span class="n">keep_mutations</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">metadata_offset</span>
        <span class="p">)</span>
        <span class="c1"># Site numbers will have changed</span>
        <span class="n">site_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">keep_sites</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># Mutation numbers will change, so the parent references need altering</span>
        <span class="n">mutation_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">keep_mutations</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># Map parent == -1 to -1, and check this has worked (assumes tskit.NULL == -1)</span>
        <span class="n">mutation_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mutation_map</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">mutation_map</span><span class="p">[</span><span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">]</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="n">site</span><span class="o">=</span><span class="n">site_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">site</span><span class="p">[</span><span class="n">keep_mutations</span><span class="p">]],</span>
            <span class="n">node</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">keep_mutations</span><span class="p">],</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">keep_mutations</span><span class="p">],</span>
            <span class="n">derived_state</span><span class="o">=</span><span class="n">new_ds</span><span class="p">,</span>
            <span class="n">derived_state_offset</span><span class="o">=</span><span class="n">new_ds_offset</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">mutation_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">keep_mutations</span><span class="p">]],</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">new_md</span><span class="p">,</span>
            <span class="n">metadata_offset</span><span class="o">=</span><span class="n">new_md_offset</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
            <span class="c1"># TODO replace with a version of https://github.com/tskit-dev/tskit/pull/243</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;delete_sites&quot;</span><span class="p">,</span> <span class="s2">&quot;TODO&quot;</span><span class="p">:</span> <span class="s2">&quot;add parameters&quot;</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="TableCollection.delete_intervals">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.delete_intervals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete all information from this set of tables which lies *within* the</span>
<span class="sd">        specified list of genomic intervals. This is identical to</span>
<span class="sd">        :meth:`TreeSequence.delete_intervals` but acts *in place* to alter</span>
<span class="sd">        the data in this :class:`TableCollection`.</span>

<span class="sd">        :param array_like intervals: A list (start, end) pairs describing the</span>
<span class="sd">            genomic intervals to delete. Intervals must be non-overlapping and</span>
<span class="sd">            in increasing order. The list of intervals must be interpretable as a</span>
<span class="sd">            2D numpy array with shape (N, 2), where N is the number of intervals.</span>
<span class="sd">        :param bool simplify: If True, run simplify on the tables so that nodes</span>
<span class="sd">            no longer used are discarded. (Default: True).</span>
<span class="sd">        :param bool record_provenance: If ``True``, add details of this operation</span>
<span class="sd">            to the provenance table in this TableCollection. (Default: ``True``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_intervals</span><span class="p">(</span>
            <span class="n">util</span><span class="o">.</span><span class="n">negate_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">),</span>
            <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;delete_intervals&quot;</span><span class="p">,</span> <span class="s2">&quot;TODO&quot;</span><span class="p">:</span> <span class="s2">&quot;add parameters&quot;</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="TableCollection.keep_intervals">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.keep_intervals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">keep_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete all information from this set of tables which lies *outside* the</span>
<span class="sd">        specified list of genomic intervals. This is identical to</span>
<span class="sd">        :meth:`TreeSequence.keep_intervals` but acts *in place* to alter</span>
<span class="sd">        the data in this :class:`TableCollection`.</span>

<span class="sd">        :param array_like intervals: A list (start, end) pairs describing the</span>
<span class="sd">            genomic intervals to keep. Intervals must be non-overlapping and</span>
<span class="sd">            in increasing order. The list of intervals must be interpretable as a</span>
<span class="sd">            2D numpy array with shape (N, 2), where N is the number of intervals.</span>
<span class="sd">        :param bool simplify: If True, run simplify on the tables so that nodes</span>
<span class="sd">            no longer used are discarded. Must be ``False`` if input tree sequence</span>
<span class="sd">            includes migrations. (Default: True).</span>
<span class="sd">        :param bool record_provenance: If ``True``, add details of this operation</span>
<span class="sd">            to the provenance table in this TableCollection. (Default: ``True``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">intervals_to_np_array</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">migrations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">keep_sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">num_rows</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
            <span class="n">curr_keep_sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span> <span class="o">&lt;</span> <span class="n">e</span>
            <span class="p">)</span>
            <span class="n">keep_sites</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">keep_sites</span><span class="p">,</span> <span class="n">curr_keep_sites</span><span class="p">)</span>
            <span class="n">keep_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">right</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">,</span> <span class="n">edges</span><span class="o">.</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">e</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">metadata</span><span class="p">,</span> <span class="n">metadata_offset</span> <span class="o">=</span> <span class="n">keep_with_offset</span><span class="p">(</span>
                <span class="n">keep_edges</span><span class="p">,</span> <span class="n">edges</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">edges</span><span class="o">.</span><span class="n">metadata_offset</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">append_columns</span><span class="p">(</span>
                <span class="n">left</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">edges</span><span class="o">.</span><span class="n">left</span><span class="p">[</span><span class="n">keep_edges</span><span class="p">]),</span>
                <span class="n">right</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">edges</span><span class="o">.</span><span class="n">right</span><span class="p">[</span><span class="n">keep_edges</span><span class="p">]),</span>
                <span class="n">parent</span><span class="o">=</span><span class="n">edges</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">keep_edges</span><span class="p">],</span>
                <span class="n">child</span><span class="o">=</span><span class="n">edges</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">keep_edges</span><span class="p">],</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">keep_migrations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">migrations</span><span class="o">.</span><span class="n">right</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">,</span> <span class="n">migrations</span><span class="o">.</span><span class="n">left</span> <span class="o">&gt;=</span> <span class="n">e</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">metadata</span><span class="p">,</span> <span class="n">metadata_offset</span> <span class="o">=</span> <span class="n">keep_with_offset</span><span class="p">(</span>
                <span class="n">keep_migrations</span><span class="p">,</span> <span class="n">migrations</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span> <span class="n">migrations</span><span class="o">.</span><span class="n">metadata_offset</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">append_columns</span><span class="p">(</span>
                <span class="n">left</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">migrations</span><span class="o">.</span><span class="n">left</span><span class="p">[</span><span class="n">keep_migrations</span><span class="p">]),</span>
                <span class="n">right</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">migrations</span><span class="o">.</span><span class="n">right</span><span class="p">[</span><span class="n">keep_migrations</span><span class="p">]),</span>
                <span class="n">node</span><span class="o">=</span><span class="n">migrations</span><span class="o">.</span><span class="n">node</span><span class="p">[</span><span class="n">keep_migrations</span><span class="p">],</span>
                <span class="n">source</span><span class="o">=</span><span class="n">migrations</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">keep_migrations</span><span class="p">],</span>
                <span class="n">dest</span><span class="o">=</span><span class="n">migrations</span><span class="o">.</span><span class="n">dest</span><span class="p">[</span><span class="n">keep_migrations</span><span class="p">],</span>
                <span class="n">time</span><span class="o">=</span><span class="n">migrations</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">keep_migrations</span><span class="p">],</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">metadata_offset</span><span class="o">=</span><span class="n">metadata_offset</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete_sites</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">keep_sites</span><span class="p">))[</span><span class="mi">0</span><span class="p">],</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;keep_intervals&quot;</span><span class="p">,</span> <span class="s2">&quot;TODO&quot;</span><span class="p">:</span> <span class="s2">&quot;add parameters&quot;</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
            <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_check_trim_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_reference_sequence</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot trim if there is a reference sequence. Please remove the &quot;</span>
                <span class="s2">&quot;reference sequence by calling `.reference_sequence.clear()` first.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">left</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot trim a tree sequence with migrations which exist to the&quot;</span>
                    <span class="s2">&quot;left of the leftmost edge or to the right of the rightmost edge.&quot;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Trimming a tree sequence with no edges would reduce the sequence length&quot;</span>
                <span class="s2">&quot; to zero, which is not allowed&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="TableCollection.ltrim">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.ltrim">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ltrim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the coordinate system used in these tables, changing the left and right</span>
<span class="sd">        genomic positions in the edge table such that the leftmost edge now starts at</span>
<span class="sd">        position 0. This is identical to :meth:`TreeSequence.ltrim` but acts *in place*</span>
<span class="sd">        to alter the data in this :class:`TableCollection`.</span>

<span class="sd">        :param bool record_provenance: If ``True``, add details of this operation</span>
<span class="sd">            to the provenance table in this TableCollection. (Default: ``True``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_trim_conditions</span><span class="p">()</span>
        <span class="n">leftmost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete_sites</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span> <span class="o">&lt;</span> <span class="n">leftmost</span><span class="p">),</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="n">left</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">left</span> <span class="o">-</span> <span class="n">leftmost</span><span class="p">,</span>
            <span class="n">right</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">leftmost</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
            <span class="n">child</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">child</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="n">position</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">leftmost</span><span class="p">,</span>
            <span class="n">ancestral_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">ancestral_state</span><span class="p">,</span>
            <span class="n">ancestral_state_offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">ancestral_state_offset</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">metadata_offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">metadata_offset</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
            <span class="n">left</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">left</span> <span class="o">-</span> <span class="n">leftmost</span><span class="p">,</span>
            <span class="n">right</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">leftmost</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
            <span class="n">node</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">node</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">source</span><span class="p">,</span>
            <span class="n">dest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">dest</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">-</span> <span class="n">leftmost</span>
        <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
            <span class="c1"># TODO replace with a version of https://github.com/tskit-dev/tskit/pull/243</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;ltrim&quot;</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="TableCollection.rtrim">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.rtrim">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rtrim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the ``sequence_length`` property so that the sequence ends at the end of</span>
<span class="sd">        the last edge. This is identical to :meth:`TreeSequence.rtrim` but acts</span>
<span class="sd">        *in place* to alter the data in this :class:`TableCollection`.</span>

<span class="sd">        :param bool record_provenance: If ``True``, add details of this operation</span>
<span class="sd">            to the provenance table in this TableCollection. (Default: ``True``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_trim_conditions</span><span class="p">()</span>
        <span class="n">rightmost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delete_sites</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span> <span class="o">&gt;=</span> <span class="n">rightmost</span><span class="p">),</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">=</span> <span class="n">rightmost</span>
        <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
            <span class="c1"># TODO replace with a version of https://github.com/tskit-dev/tskit/pull/243</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;rtrim&quot;</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="TableCollection.trim">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.trim">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trim away any empty regions on the right and left of the tree sequence encoded by</span>
<span class="sd">        these tables. This is identical to :meth:`TreeSequence.trim` but acts *in place*</span>
<span class="sd">        to alter the data in this :class:`TableCollection`.</span>

<span class="sd">        :param bool record_provenance: If ``True``, add details of this operation</span>
<span class="sd">            to the provenance table in this TableCollection. (Default: ``True``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rtrim</span><span class="p">(</span><span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ltrim</span><span class="p">(</span><span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
            <span class="c1"># TODO replace with a version of https://github.com/tskit-dev/tskit/pull/243</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;trim&quot;</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="TableCollection.shift">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.shift">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift the coordinate system (used by edges, sites, and migrations) of this</span>
<span class="sd">        TableCollection by a given value. This is identical to :meth:`TreeSequence.shift`</span>
<span class="sd">        but acts *in place* to alter the data in this :class:`TableCollection`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            No attempt is made to check that the new coordinate system or sequence length</span>
<span class="sd">            is valid: if you wish to do this, use {meth}`TreeSequence.shift` instead.</span>

<span class="sd">        :param value: The amount by which to shift the coordinate system.</span>
<span class="sd">        :param sequence_length: The new sequence length of the tree sequence. If</span>
<span class="sd">            ``None`` (default) add `value` to the sequence length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_reference_sequence</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot shift if there is a reference sequence. Please remove the &quot;</span>
                <span class="s2">&quot;reference sequence by calling `.reference_sequence.clear()` first.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_index</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">left</span> <span class="o">+=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">right</span> <span class="o">+=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">left</span> <span class="o">+=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">right</span> <span class="o">+=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="o">.</span><span class="n">position</span> <span class="o">+=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="n">sequence_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">+=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">=</span> <span class="n">sequence_length</span>
        <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;shift&quot;</span><span class="p">,</span>
                <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">value</span><span class="p">,</span>
                <span class="s2">&quot;sequence_length&quot;</span><span class="p">:</span> <span class="n">sequence_length</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="TableCollection.delete_older">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.delete_older">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete_older</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes edge, mutation and migration information at least as old as</span>
<span class="sd">        the specified time.</span>

<span class="sd">        .. seealso:: This method is similar to the higher-level</span>
<span class="sd">            :meth:`TreeSequence.decapitate` method, which also splits</span>
<span class="sd">            edges that intersect with the given time.</span>
<span class="sd">            :meth:`TreeSequence.decapitate`</span>
<span class="sd">            is more useful for most purposes, and may be what</span>
<span class="sd">            you need instead of this method!</span>

<span class="sd">        For the purposes of this method, an edge covers the times from the</span>
<span class="sd">        child node up until the *parent* node, so that any any edge with parent</span>
<span class="sd">        node time &gt; ``time`` will be removed.</span>

<span class="sd">        Any mutation whose time is &gt;= ``time`` will be removed. A mutation&#39;s time</span>
<span class="sd">        is its associated ``time`` value, or the time of its node if the</span>
<span class="sd">        mutation&#39;s time was marked as unknown (:data:`UNKNOWN_TIME`).</span>

<span class="sd">        Any migration with time &gt;= ``time`` will be removed.</span>

<span class="sd">        The node table is not affected by this operation.</span>

<span class="sd">        .. note:: This method does not have any specific sorting requirements</span>
<span class="sd">            and will maintain mutation parent mappings.</span>

<span class="sd">        :param float time: The cutoff time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">delete_older</span><span class="p">(</span><span class="n">time</span><span class="p">)</span></div>


<div class="viewcode-block" id="TableCollection.clear">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.clear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clear</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">clear_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">clear_metadata_schemas</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">clear_ts_metadata_and_schema</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all rows of the data tables, optionally remove provenance, metadata</span>
<span class="sd">        schemas and ts-level metadata.</span>

<span class="sd">        :param bool clear_provenance: If ``True``, remove all rows of the provenance</span>
<span class="sd">            table. (Default: ``False``).</span>
<span class="sd">        :param bool clear_metadata_schemas: If ``True``, clear the table metadata</span>
<span class="sd">            schemas. (Default: ``False``).</span>
<span class="sd">        :param bool clear_ts_metadata_and_schema: If ``True``, clear the tree-sequence</span>
<span class="sd">            level metadata and schema (Default: ``False``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">clear</span><span class="p">(</span>
            <span class="n">clear_provenance</span><span class="o">=</span><span class="n">clear_provenance</span><span class="p">,</span>
            <span class="n">clear_metadata_schemas</span><span class="o">=</span><span class="n">clear_metadata_schemas</span><span class="p">,</span>
            <span class="n">clear_ts_metadata_and_schema</span><span class="o">=</span><span class="n">clear_ts_metadata_and_schema</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TableCollection.has_index">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.has_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if this TableCollection is indexed. See :ref:`sec_table_indexes`</span>
<span class="sd">        for information on indexes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">has_index</span><span class="p">())</span></div>


<div class="viewcode-block" id="TableCollection.build_index">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.build_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds an index on this TableCollection. Any existing indexes are automatically</span>
<span class="sd">        dropped.  See :ref:`sec_table_indexes` for information on indexes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">build_index</span><span class="p">()</span></div>


<div class="viewcode-block" id="TableCollection.drop_index">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.drop_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">drop_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drops any indexes present on this table collection. If the tables are not</span>
<span class="sd">        currently indexed this method has no effect.  See :ref:`sec_table_indexes`</span>
<span class="sd">        for information on indexes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">drop_index</span><span class="p">()</span></div>


<div class="viewcode-block" id="TableCollection.subset">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.subset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">subset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">reorder_populations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">remove_unreferenced</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies the tables in place to contain only the entries referring to</span>
<span class="sd">        the provided list of node IDs, with nodes reordered according to the</span>
<span class="sd">        order they appear in the list. Other tables are :meth:`sorted &lt;sort&gt;`</span>
<span class="sd">        to conform to the :ref:`sec_valid_tree_sequence_requirements`, and</span>
<span class="sd">        additionally sorted as described in the documentation for the equivalent</span>
<span class="sd">        tree sequence method :meth:`TreeSequence.subset`: please see this for more</span>
<span class="sd">        detail.</span>

<span class="sd">        :param list nodes: The list of nodes for which to retain information. This</span>
<span class="sd">            may be a numpy array (or array-like) object (dtype=np.int32).</span>
<span class="sd">        :param bool record_provenance: Whether to record a provenance entry</span>
<span class="sd">            in the provenance table for this operation.</span>
<span class="sd">        :param bool reorder_populations: Whether to reorder the population table</span>
<span class="sd">            (default: True).  If False, the population table will not be altered</span>
<span class="sd">            in any way.</span>
<span class="sd">        :param bool remove_unreferenced: Whether sites, individuals, and populations</span>
<span class="sd">            that are not referred to by any retained entries in the tables should</span>
<span class="sd">            be removed (default: True). See the description for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reorder_populations</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">True</span> <span class="k">if</span> <span class="n">reorder_populations</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">reorder_populations</span>
        <span class="p">)</span>
        <span class="n">remove_unreferenced</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">True</span> <span class="k">if</span> <span class="n">remove_unreferenced</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">remove_unreferenced</span>
        <span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span>
            <span class="n">nodes</span><span class="p">,</span>
            <span class="n">reorder_populations</span><span class="o">=</span><span class="n">reorder_populations</span><span class="p">,</span>
            <span class="n">remove_unreferenced</span><span class="o">=</span><span class="n">remove_unreferenced</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;subset&quot;</span><span class="p">,</span> <span class="s2">&quot;nodes&quot;</span><span class="p">:</span> <span class="n">nodes</span><span class="o">.</span><span class="n">tolist</span><span class="p">()}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="TableCollection.union">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.union">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">union</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">node_mapping</span><span class="p">,</span>
        <span class="n">check_shared_equality</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">add_populations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">all_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">all_mutations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modifies the table collection in place by adding the non-shared</span>
<span class="sd">        portions of ``other`` to itself. To perform the node-wise union,</span>
<span class="sd">        the method relies on a ``node_mapping`` array, that maps nodes in</span>
<span class="sd">        ``other`` to its equivalent node in ``self`` or ``tskit.NULL`` if</span>
<span class="sd">        the node is exclusive to ``other``. See :meth:`TreeSequence.union` for a more</span>
<span class="sd">        detailed description.</span>

<span class="sd">        :param TableCollection other: Another table collection.</span>
<span class="sd">        :param list node_mapping: An array of node IDs that relate nodes in</span>
<span class="sd">            ``other`` to nodes in ``self``: the k-th element of ``node_mapping``</span>
<span class="sd">            should be the index of the equivalent node in ``self``, or</span>
<span class="sd">            ``tskit.NULL`` if the node is not present in ``self`` (in which case it</span>
<span class="sd">            will be added to self).</span>
<span class="sd">        :param bool check_shared_equality: If True, the shared portions of the</span>
<span class="sd">            table collections will be checked for equality.</span>
<span class="sd">        :param bool add_populations: If True, nodes new to ``self`` will be</span>
<span class="sd">            assigned new population IDs.</span>
<span class="sd">        :param bool record_provenance: Whether to record a provenance entry</span>
<span class="sd">            in the provenance table for this operation.</span>
<span class="sd">        :param bool all_edges: If True, then all edges in ``other`` are added</span>
<span class="sd">            to ``self``.</span>
<span class="sd">        :param bool all_mutations: If True, then all mutations in ``other`` are added</span>
<span class="sd">            to ``self``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_mapping</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">node_mapping</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">_ll_tables</span><span class="p">,</span>
            <span class="n">node_mapping</span><span class="p">,</span>
            <span class="n">check_shared_equality</span><span class="o">=</span><span class="n">check_shared_equality</span><span class="p">,</span>
            <span class="n">add_populations</span><span class="o">=</span><span class="n">add_populations</span><span class="p">,</span>
            <span class="n">all_edges</span><span class="o">=</span><span class="n">all_edges</span><span class="p">,</span>
            <span class="n">all_mutations</span><span class="o">=</span><span class="n">all_mutations</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
            <span class="n">other_records</span> <span class="o">=</span> <span class="p">[</span><span class="n">prov</span><span class="o">.</span><span class="n">record</span> <span class="k">for</span> <span class="n">prov</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">provenances</span><span class="p">]</span>
            <span class="n">other_timestamps</span> <span class="o">=</span> <span class="p">[</span><span class="n">prov</span><span class="o">.</span><span class="n">timestamp</span> <span class="k">for</span> <span class="n">prov</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">provenances</span><span class="p">]</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;union&quot;</span><span class="p">,</span>
                <span class="s2">&quot;other&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;timestamp&quot;</span><span class="p">:</span> <span class="n">other_timestamps</span><span class="p">,</span> <span class="s2">&quot;record&quot;</span><span class="p">:</span> <span class="n">other_records</span><span class="p">},</span>
                <span class="s2">&quot;node_mapping&quot;</span><span class="p">:</span> <span class="n">node_mapping</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="TableCollection.ibd_segments">
<a class="viewcode-back" href="../../python-api.html#tskit.TableCollection.ibd_segments">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ibd_segments</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">within</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">between</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">min_span</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">store_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">store_segments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equivalent to the :meth:`TreeSequence.ibd_segments` method; please see its</span>
<span class="sd">        documentation for more details, and use this method only if you specifically need</span>
<span class="sd">        to work with a :class:`TableCollection` object.</span>

<span class="sd">        This method has the same data requirements as</span>
<span class="sd">        :meth:`TableCollection.simplify`. In particular, the tables in the collection</span>
<span class="sd">        have :ref:`required &lt;sec_valid_tree_sequence_requirements&gt;` sorting orders.</span>
<span class="sd">        To enforce this, you can call :meth:`TableCollection.sort` before using this</span>
<span class="sd">        method. If the edge table contains any edges with identical</span>
<span class="sd">        parents and children over adjacent genomic intervals, any IBD intervals</span>
<span class="sd">        underneath the edges will also be split across the breakpoint(s). To prevent this</span>
<span class="sd">        behaviour in this situation, use :meth:`EdgeTable.squash` beforehand.</span>

<span class="sd">        :param list within: As for the :meth:`TreeSequence.ibd_segments` method.</span>
<span class="sd">        :param list[list] between: As for the :meth:`TreeSequence.ibd_segments` method.</span>
<span class="sd">        :param float max_time: As for the :meth:`TreeSequence.ibd_segments` method.</span>
<span class="sd">        :param float min_span: As for the :meth:`TreeSequence.ibd_segments` method.</span>
<span class="sd">        :param bool store_pairs: As for the :meth:`TreeSequence.ibd_segments` method.</span>
<span class="sd">        :param bool store_segments: As for the :meth:`TreeSequence.ibd_segments` method.</span>
<span class="sd">        :return: An :class:`.IdentitySegments` object containing the recorded</span>
<span class="sd">            IBD information.</span>
<span class="sd">        :rtype: IdentitySegments</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="k">if</span> <span class="n">max_time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">max_time</span>
        <span class="n">min_span</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">min_span</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">min_span</span>
        <span class="n">store_pairs</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">store_pairs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">store_pairs</span>
        <span class="n">store_segments</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">store_segments</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">store_segments</span>
        <span class="k">if</span> <span class="n">within</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">between</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The ``within`` and ``between`` arguments are mutually exclusive&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">between</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_set_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_set</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample_set</span> <span class="ow">in</span> <span class="n">between</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span>
            <span class="p">)</span>
            <span class="c1"># hstack has some annoying quirks around its handling of empty</span>
            <span class="c1"># lists which we need to work around. In a way it would be more</span>
            <span class="c1"># convenient to detect these conditions as errors, but then we</span>
            <span class="c1"># end up having to workaround edge cases in the tests and its</span>
            <span class="c1"># mathematically neater this way.</span>
            <span class="n">pre_flattened</span> <span class="o">=</span> <span class="p">[</span><span class="n">lst</span> <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="n">between</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre_flattened</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">flattened</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flattened</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">pre_flattened</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">ll_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">ibd_segments_between</span><span class="p">(</span>
                <span class="n">sample_set_sizes</span><span class="o">=</span><span class="n">sample_set_sizes</span><span class="p">,</span>
                <span class="n">sample_sets</span><span class="o">=</span><span class="n">flattened</span><span class="p">,</span>
                <span class="n">max_time</span><span class="o">=</span><span class="n">max_time</span><span class="p">,</span>
                <span class="n">min_span</span><span class="o">=</span><span class="n">min_span</span><span class="p">,</span>
                <span class="n">store_pairs</span><span class="o">=</span><span class="n">store_pairs</span><span class="p">,</span>
                <span class="n">store_segments</span><span class="o">=</span><span class="n">store_segments</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">within</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">within</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">within</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">ll_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tables</span><span class="o">.</span><span class="n">ibd_segments_within</span><span class="p">(</span>
                <span class="n">samples</span><span class="o">=</span><span class="n">within</span><span class="p">,</span>
                <span class="n">max_time</span><span class="o">=</span><span class="n">max_time</span><span class="p">,</span>
                <span class="n">min_span</span><span class="o">=</span><span class="n">min_span</span><span class="p">,</span>
                <span class="n">store_pairs</span><span class="o">=</span><span class="n">store_pairs</span><span class="p">,</span>
                <span class="n">store_segments</span><span class="o">=</span><span class="n">store_segments</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">IdentitySegments</span><span class="p">(</span>
            <span class="n">ll_result</span><span class="p">,</span>
            <span class="n">max_time</span><span class="o">=</span><span class="n">max_time</span><span class="p">,</span>
            <span class="n">min_span</span><span class="o">=</span><span class="n">min_span</span><span class="p">,</span>
            <span class="n">store_pairs</span><span class="o">=</span><span class="n">store_pairs</span><span class="p">,</span>
            <span class="n">store_segments</span><span class="o">=</span><span class="n">store_segments</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>



<span class="k">class</span><span class="w"> </span><span class="nc">ImmutableNodeTable</span><span class="p">(</span><span class="n">ImmutableMetadataTable</span><span class="p">):</span>
    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;nodes&quot;</span>
    <span class="n">mutable_class</span> <span class="o">=</span> <span class="n">NodeTable</span>

    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;time&quot;</span><span class="p">,</span>
        <span class="s2">&quot;flags&quot;</span><span class="p">,</span>
        <span class="s2">&quot;population&quot;</span><span class="p">,</span>
        <span class="s2">&quot;individual&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_offset&quot;</span><span class="p">,</span>
    <span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ImmutableIndividualTable</span><span class="p">(</span><span class="n">ImmutableMetadataTable</span><span class="p">):</span>
    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;individuals&quot;</span>
    <span class="n">mutable_class</span> <span class="o">=</span> <span class="n">IndividualTable</span>

    <span class="n">_row_field_indices</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;flags&quot;</span><span class="p">,</span>
        <span class="s2">&quot;location&quot;</span><span class="p">,</span>
        <span class="s2">&quot;location_offset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;parents&quot;</span><span class="p">,</span>
        <span class="s2">&quot;parents_offset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_offset&quot;</span><span class="p">,</span>
    <span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ImmutableEdgeTable</span><span class="p">(</span><span class="n">ImmutableMetadataTable</span><span class="p">):</span>
    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;edges&quot;</span>
    <span class="n">mutable_class</span> <span class="o">=</span> <span class="n">EdgeTable</span>

    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="s2">&quot;right&quot;</span><span class="p">,</span>
        <span class="s2">&quot;parent&quot;</span><span class="p">,</span>
        <span class="s2">&quot;child&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_offset&quot;</span><span class="p">,</span>
    <span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ImmutableMigrationTable</span><span class="p">(</span><span class="n">ImmutableMetadataTable</span><span class="p">):</span>
    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;migrations&quot;</span>
    <span class="n">mutable_class</span> <span class="o">=</span> <span class="n">MigrationTable</span>

    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="s2">&quot;right&quot;</span><span class="p">,</span>
        <span class="s2">&quot;node&quot;</span><span class="p">,</span>
        <span class="s2">&quot;source&quot;</span><span class="p">,</span>
        <span class="s2">&quot;dest&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_offset&quot;</span><span class="p">,</span>
    <span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ImmutableSiteTable</span><span class="p">(</span><span class="n">ImmutableMetadataTable</span><span class="p">):</span>
    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;sites&quot;</span>
    <span class="n">mutable_class</span> <span class="o">=</span> <span class="n">SiteTable</span>

    <span class="n">_row_field_indices</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;position&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ancestral_state&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ancestral_state_offset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_offset&quot;</span><span class="p">,</span>
    <span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ImmutableMutationTable</span><span class="p">(</span><span class="n">ImmutableMetadataTable</span><span class="p">):</span>
    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;mutations&quot;</span>
    <span class="n">mutable_class</span> <span class="o">=</span> <span class="n">MutationTable</span>

    <span class="n">_row_field_indices</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="s2">&quot;node&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time&quot;</span><span class="p">,</span>
        <span class="s2">&quot;derived_state&quot;</span><span class="p">,</span>
        <span class="s2">&quot;derived_state_offset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;parent&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata_offset&quot;</span><span class="p">,</span>
    <span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ImmutablePopulationTable</span><span class="p">(</span><span class="n">ImmutableMetadataTable</span><span class="p">):</span>
    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;populations&quot;</span>
    <span class="n">mutable_class</span> <span class="o">=</span> <span class="n">PopulationTable</span>

    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;metadata&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata_offset&quot;</span><span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ImmutableProvenanceTable</span><span class="p">(</span><span class="n">ImmutableBaseTable</span><span class="p">):</span>
    <span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;provenances&quot;</span>
    <span class="n">mutable_class</span> <span class="o">=</span> <span class="n">ProvenanceTable</span>

    <span class="n">column_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;record&quot;</span><span class="p">,</span>
        <span class="s2">&quot;record_offset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;timestamp&quot;</span><span class="p">,</span>
        <span class="s2">&quot;timestamp_offset&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equals_internal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">ignore_timestamps</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">assert_equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ignore_timestamps</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;table_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="s2">&quot;provenances&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ignore_timestamps is only valid for Provenance tables&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_equals_internal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ignore_timestamps</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">ignore_timestamps</span><span class="p">))</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ImmutableTableCollection</span><span class="p">(</span><span class="n">metadata</span><span class="o">.</span><span class="n">MetadataProvider</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An immutable view of a table collection backed by a :class:`TreeSequence`.</span>
<span class="sd">    Provides zero-copy read access to all table data without allowing mutation.</span>

<span class="sd">    This class is returned by :attr:`TreeSequence.tables` and provides efficient,</span>
<span class="sd">    read-only access to the underlying table data. Since it&#39;s backed directly by</span>
<span class="sd">    the low-level TreeSequence representation, no copying of data is required.</span>

<span class="sd">    All methods from TableCollection that do not mutate the data are reflected here.</span>

<span class="sd">    To obtain a mutable copy of this table collection, use the :meth:`.copy`</span>
<span class="sd">    method which returns a :class:`TableCollection` instance that can be modified.</span>
<span class="sd">    Alternatively, use :meth:`TreeSequence.dump_tables` to get a mutable copy</span>
<span class="sd">    directly from the tree sequence.</span>

<span class="sd">    All mutator methods present on :class:`TableCollection` (such as ``sort()``,</span>
<span class="sd">    ``simplify()``, ``clear()``, etc.) will raise an :class:`ImmutableTableError`</span>
<span class="sd">    if called on an immutable table collection.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ll_tree_sequence</span><span class="p">):</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_initialised&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span> <span class="o">=</span> <span class="n">ll_tree_sequence</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ll_tree_sequence</span><span class="p">)</span>

        <span class="c1"># Create immutable table views - lazy initialization could be added later</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="n">ImmutableIndividualTable</span><span class="p">(</span><span class="n">ll_tree_sequence</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">ImmutableNodeTable</span><span class="p">(</span><span class="n">ll_tree_sequence</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">ImmutableEdgeTable</span><span class="p">(</span><span class="n">ll_tree_sequence</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migrations</span> <span class="o">=</span> <span class="n">ImmutableMigrationTable</span><span class="p">(</span><span class="n">ll_tree_sequence</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sites</span> <span class="o">=</span> <span class="n">ImmutableSiteTable</span><span class="p">(</span><span class="n">ll_tree_sequence</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span> <span class="o">=</span> <span class="n">ImmutableMutationTable</span><span class="p">(</span><span class="n">ll_tree_sequence</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">populations</span> <span class="o">=</span> <span class="n">ImmutablePopulationTable</span><span class="p">(</span><span class="n">ll_tree_sequence</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span> <span class="o">=</span> <span class="n">ImmutableProvenanceTable</span><span class="p">(</span><span class="n">ll_tree_sequence</span><span class="p">)</span>
        <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_initialised&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sequence_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">get_sequence_length</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">file_uuid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">get_file_uuid</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">get_time_units</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reference_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ReferenceSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">reference_sequence</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">metadata</span><span class="o">.</span><span class="n">parse_metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">get_metadata_schema</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">decode_row</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata_bytes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">table_name_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;edges&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span>
            <span class="s2">&quot;individuals&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span>
            <span class="s2">&quot;migrations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="p">,</span>
            <span class="s2">&quot;mutations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="p">,</span>
            <span class="s2">&quot;nodes&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
            <span class="s2">&quot;populations&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">,</span>
            <span class="s2">&quot;provenances&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="p">,</span>
            <span class="s2">&quot;sites&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TableCollectionIndexes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TableCollectionIndexes</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="s2">&quot;edge_insertion_order&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">indexes_edge_insertion_order</span><span class="p">,</span>
                <span class="s2">&quot;edge_removal_order&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">indexes_edge_removal_order</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">has_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">indexes_edge_insertion_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">indexes_edge_removal_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">force_offset_64</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># TODO Could avoid the copy here</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">asdict</span><span class="p">(</span><span class="n">force_offset_64</span><span class="o">=</span><span class="n">force_offset_64</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_tables</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_reference_sequence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assert_equals</span><span class="p">(</span>
                <span class="n">other</span><span class="p">,</span>
                <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">,</span>
                <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="n">ignore_ts_metadata</span><span class="p">,</span>
                <span class="n">ignore_provenance</span><span class="o">=</span><span class="n">ignore_provenance</span><span class="p">,</span>
                <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span><span class="p">,</span>
                <span class="n">ignore_tables</span><span class="o">=</span><span class="n">ignore_tables</span><span class="p">,</span>
                <span class="n">ignore_reference_sequence</span><span class="o">=</span><span class="n">ignore_reference_sequence</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">assert_equals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_tables</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_reference_sequence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">_assert_table_collections_equal</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">,</span>
            <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="n">ignore_ts_metadata</span><span class="p">,</span>
            <span class="n">ignore_provenance</span><span class="o">=</span><span class="n">ignore_provenance</span><span class="p">,</span>
            <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span><span class="p">,</span>
            <span class="n">ignore_tables</span><span class="o">=</span><span class="n">ignore_tables</span><span class="p">,</span>
            <span class="n">ignore_reference_sequence</span><span class="o">=</span><span class="n">ignore_reference_sequence</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="mi">8</span><span class="p">,</span>  <span class="c1"># sequence length</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadata_bytes</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">get_metadata_schema</span><span class="p">()),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_units</span><span class="o">.</span><span class="n">encode</span><span class="p">()),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reference_sequence</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span>
                <span class="nb">sum</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">nbytes</span> <span class="k">for</span> <span class="n">table</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_name_map</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="s2">&quot;ImmutableTableCollection&quot;</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Sequence Length: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Time units: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">time_units</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;Individuals&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">),</span>
                <span class="s2">&quot;Nodes&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">),</span>
                <span class="s2">&quot;Edges&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">),</span>
                <span class="s2">&quot;Sites&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">),</span>
                <span class="s2">&quot;Mutations&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="p">),</span>
                <span class="s2">&quot;Migrations&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">migrations</span><span class="p">),</span>
                <span class="s2">&quot;Populations&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">),</span>
                <span class="s2">&quot;Provenances&quot;</span><span class="p">,</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">provenances</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">link_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">ancestors</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See :meth:`TableCollection.link_ancestors`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">ancestors</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">ancestors</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">ll_edge_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">link_ancestors</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">ancestors</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">EdgeTable</span><span class="p">(</span><span class="n">ll_table</span><span class="o">=</span><span class="n">ll_edge_table</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">map_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated alias for :meth:`link_ancestors`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">link_ancestors</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">_MUTATOR_METHODS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;clear&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sort&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sort_individuals&quot;</span><span class="p">,</span>
        <span class="s2">&quot;canonicalise&quot;</span><span class="p">,</span>
        <span class="s2">&quot;compute_mutation_parents&quot;</span><span class="p">,</span>
        <span class="s2">&quot;compute_mutation_times&quot;</span><span class="p">,</span>
        <span class="s2">&quot;deduplicate_sites&quot;</span><span class="p">,</span>
        <span class="s2">&quot;delete_sites&quot;</span><span class="p">,</span>
        <span class="s2">&quot;delete_intervals&quot;</span><span class="p">,</span>
        <span class="s2">&quot;keep_intervals&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ltrim&quot;</span><span class="p">,</span>
        <span class="s2">&quot;rtrim&quot;</span><span class="p">,</span>
        <span class="s2">&quot;trim&quot;</span><span class="p">,</span>
        <span class="s2">&quot;shift&quot;</span><span class="p">,</span>
        <span class="s2">&quot;delete_older&quot;</span><span class="p">,</span>
        <span class="s2">&quot;build_index&quot;</span><span class="p">,</span>
        <span class="s2">&quot;drop_index&quot;</span><span class="p">,</span>
        <span class="s2">&quot;subset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;union&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ibd_segments&quot;</span><span class="p">,</span>
        <span class="s2">&quot;fromdict&quot;</span><span class="p">,</span>
        <span class="s2">&quot;simplify&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ll_tables</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">(</span><span class="n">ll_tables</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TableCollection</span><span class="p">(</span><span class="n">ll_tables</span><span class="o">=</span><span class="n">ll_tables</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_or_path</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">file_or_path</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">tree_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TreeSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">has_reference_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_llts</span><span class="o">.</span><span class="n">has_reference_sequence</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MUTATOR_METHODS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ImmutableTableError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot call </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">() on immutable table collection. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Use TreeSequence.dump_tables() for mutable copy.&quot;</span>
            <span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># Allow all assignments during initialization</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialised</span><span class="p">:</span>
            <span class="nb">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">raise</span> <span class="n">ImmutableTableError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Cannot set attribute &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; on immutable table collection. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Use TreeSequence.dump_tables() for mutable copy.&quot;</span>
        <span class="p">)</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Tskit Developers
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
       Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>