
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tskit.trees &#8212; Tskit manual</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5349f25f" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=9c3e77be" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../_static/bespoke.css?v=00f581dd" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=1ae7504c"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/tskit/trees';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <script data-goatcounter="https://tskit.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../introduction.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.svg" class="logo__image only-light" alt=""/>
    <script>document.write(`<img src="../../_static/logo.svg" class="logo__image only-dark" alt=""/>`);</script>
  
  
    <p class="title logo__title">Version 1.0.1</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quickstart</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Concepts</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../data-model.html">Data model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../metadata.html">Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../provenance.html">Provenance</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Analysis</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../stats.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../topological-analysis.html">Topological analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ibd.html">Identity by descent</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../export.html">Data export</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Interfaces</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../python-api.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../numba.html">Numba Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../c-api.html">C API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cli.html">Command line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../file-formats.html">File formats</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">For developers</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelogs.html">Changelogs</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Miscellaneous</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../citation.html">Citing tskit</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/tskit-dev/tskit" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/tskit-dev/tskit/issues/new?title=Issue%20on%20page%20%2F_modules/tskit/trees.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for tskit.trees</h1><div class="highlight"><pre>
<span></span><span class="c1"># MIT License</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2018-2025 Tskit Developers</span>
<span class="c1"># Copyright (c) 2015-2018 University of Oxford</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="c1"># of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="c1"># in the Software without restriction, including without limitation the rights</span>
<span class="c1"># to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="c1"># copies of the Software, and to permit persons to whom the Software is</span>
<span class="c1"># furnished to do so, subject to the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be included in all</span>
<span class="c1"># copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="c1"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="c1"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="c1"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="c1"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="c1"># OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="c1"># SOFTWARE.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module responsible for managing trees and tree sequences.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">base64</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">builtins</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">concurrent.futures</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">io</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numbers</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NamedTuple</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">_tskit</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit.combinatorics</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">combinatorics</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit.drawing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">drawing</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit.metadata</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">metadata_module</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit.provenance</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">provenance</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit.tables</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">tables</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit.text_formats</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">text_formats</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit.util</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">util</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tskit.vcf</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">vcf</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tskit</span><span class="w"> </span><span class="kn">import</span> <span class="n">NODE_IS_SAMPLE</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tskit</span><span class="w"> </span><span class="kn">import</span> <span class="n">NULL</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tskit</span><span class="w"> </span><span class="kn">import</span> <span class="n">UNKNOWN_TIME</span>

<span class="n">LEGACY_MS_LABELS</span> <span class="o">=</span> <span class="s2">&quot;legacy_ms&quot;</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">VcfModelMapping</span><span class="p">:</span>
    <span class="n">individuals_nodes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">individuals_name</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">transformed_positions</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">contig_length</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">contig_id</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">isolated_as_missing</span><span class="p">:</span> <span class="nb">bool</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CoalescenceRecord</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">left</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">right</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">node</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">population</span><span class="p">:</span> <span class="nb">int</span>


<div class="viewcode-block" id="Interval">
<a class="viewcode-back" href="../../python-api.html#tskit.Interval">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Interval</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A tuple of 2 numbers, ``[left, right)``, defining an interval over the genome.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">left</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The left hand end of the interval. By convention this value is included</span>
<span class="sd">    in the interval</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">right</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The right hand end of the interval. By convention this value is *not*</span>
<span class="sd">    included in the interval, i.e., the interval is half-open.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The span of the genome covered by this interval, simply ``right-left``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The middle point of this interval, simply ``left+(right-left)/2``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">EdgeDiff</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">interval</span><span class="p">:</span> <span class="n">Interval</span>
    <span class="n">edges_out</span><span class="p">:</span> <span class="nb">list</span>
    <span class="n">edges_in</span><span class="p">:</span> <span class="nb">list</span>


<span class="k">def</span><span class="w"> </span><span class="nf">store_tree_sequence</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="n">wrapped_init</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span>

    <span class="c1"># Intercept the init to record the tree_sequence</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">new_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">tree_sequence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">builtins</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_tree_sequence&quot;</span><span class="p">,</span> <span class="n">tree_sequence</span><span class="p">)</span>
        <span class="n">wrapped_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">new_init</span>
    <span class="k">return</span> <span class="bp">cls</span>


<div class="viewcode-block" id="Individual">
<a class="viewcode-back" href="../../python-api.html#tskit.Individual">[docs]</a>
<span class="nd">@store_tree_sequence</span>
<span class="nd">@metadata_module</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">()</span>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Individual</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An :ref:`individual &lt;sec_individual_table_definition&gt;` in a tree sequence.</span>
<span class="sd">    Since nodes correspond to genomes, individuals are associated with a collection</span>
<span class="sd">    of nodes (e.g., two nodes per diploid). See :ref:`sec_nodes_or_individuals`</span>
<span class="sd">    for more discussion of this distinction.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;id&quot;</span><span class="p">,</span>
        <span class="s2">&quot;flags&quot;</span><span class="p">,</span>
        <span class="s2">&quot;location&quot;</span><span class="p">,</span>
        <span class="s2">&quot;parents&quot;</span><span class="p">,</span>
        <span class="s2">&quot;nodes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_tree_sequence&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># noqa A003</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of this individual. Varies from 0 to</span>
<span class="sd">    :attr:`TreeSequence.num_individuals` - 1.&quot;&quot;&quot;</span>
    <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The bitwise flags for this individual.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">location</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The spatial location of this individual as a numpy array. The location is an empty</span>
<span class="sd">    array if no spatial location is defined.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parents</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The parent individual ids of this individual as a numpy array. The parents is an</span>
<span class="sd">    empty array if no parents are defined.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The IDs of the nodes that are associated with this individual as</span>
<span class="sd">    a numpy array (dtype=np.int32). If no nodes are associated with the</span>
<span class="sd">    individual this array will be empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :ref:`metadata &lt;sec_metadata_definition&gt;`</span>
<span class="sd">    for this individual, decoded if a schema applies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">population</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">populations</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_sequence</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">population</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">populations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Individual has nodes with mis-matched populations&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">populations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span>
        <span class="k">return</span> <span class="n">populations</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">times</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_tree_sequence</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">time</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Individual has nodes with mis-matched times&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tskit</span><span class="o">.</span><span class="n">UNKNOWN_TIME</span>
        <span class="k">return</span> <span class="n">times</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="c1"># Custom eq for the numpy arrays</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">flags</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">location</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">metadata</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="Node">
<a class="viewcode-back" href="../../python-api.html#tskit.Node">[docs]</a>
<span class="nd">@metadata_module</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">()</span>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :ref:`node &lt;sec_node_table_definition&gt;` in a tree sequence, corresponding</span>
<span class="sd">    to a single genome. The ``time`` and ``population`` are attributes of the</span>
<span class="sd">    ``Node``, rather than the ``Individual``, as discussed in</span>
<span class="sd">    :ref:`sec_nodes_or_individuals`.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;flags&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;population&quot;</span><span class="p">,</span> <span class="s2">&quot;individual&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># noqa A003</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of this node. Varies from 0 to :attr:`TreeSequence.num_nodes` - 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The bitwise flags for this node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The birth time of this node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">population</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of the population that this node was born in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">individual</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of the individual that this node was a part of.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :ref:`metadata &lt;sec_metadata_definition&gt;` for this node, decoded if a schema</span>
<span class="sd">    applies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Node.is_sample">
<a class="viewcode-back" href="../../python-api.html#tskit.Node.is_sample">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if this node is a sample. This value is derived from the</span>
<span class="sd">        ``flag`` variable.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NODE_IS_SAMPLE</span></div>
</div>



<div class="viewcode-block" id="Edge">
<a class="viewcode-back" href="../../python-api.html#tskit.Edge">[docs]</a>
<span class="nd">@metadata_module</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">(</span><span class="n">own_init</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Edge</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An :ref:`edge &lt;sec_edge_table_definition&gt;` in a tree sequence.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="s2">&quot;child&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">left</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The left coordinate of this edge.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">right</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The right coordinate of this edge.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parent</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of the parent node for this edge.</span>
<span class="sd">    To obtain further information about a node with a given ID, use</span>
<span class="sd">    :meth:`TreeSequence.node`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">child</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of the child node for this edge.</span>
<span class="sd">    To obtain further information about a node with a given ID, use</span>
<span class="sd">    :meth:`TreeSequence.node`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :ref:`metadata &lt;sec_metadata_definition&gt;` for this edge, decoded if a schema</span>
<span class="sd">    applies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># noqa A003</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of this edge. Varies from 0 to</span>
<span class="sd">    :attr:`TreeSequence.num_edges` - 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Custom init to define default values with slots</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">left</span><span class="p">,</span>
        <span class="n">right</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">,</span>
        <span class="n">child</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># noqa A002</span>
        <span class="n">metadata_decoder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="o">=</span> <span class="n">child</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_metadata_decoder</span> <span class="o">=</span> <span class="n">metadata_decoder</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the span of this edge, i.e., the right position minus the left position</span>

<span class="sd">        :return: The span of this edge.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the left and right positions of this edge as an :class:`Interval`</span>

<span class="sd">        :return: The interval covered by this edge.</span>
<span class="sd">        :rtype: :class:`Interval`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Interval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">)</span></div>



<div class="viewcode-block" id="Site">
<a class="viewcode-back" href="../../python-api.html#tskit.Site">[docs]</a>
<span class="nd">@metadata_module</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">()</span>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Site</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :ref:`site &lt;sec_site_table_definition&gt;` in a tree sequence.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="s2">&quot;ancestral_state&quot;</span><span class="p">,</span> <span class="s2">&quot;mutations&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># noqa A003</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of this site. Varies from 0 to :attr:`TreeSequence.num_sites` - 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">position</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The floating point location of this site in genome coordinates.</span>
<span class="sd">    Ranges from 0 (inclusive) to :attr:`TreeSequence.sequence_length` (exclusive).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ancestral_state</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The ancestral state at this site (i.e., the state inherited by nodes, unless</span>
<span class="sd">    mutations occur).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mutations</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The list of mutations at this site. Mutations within a site are returned in the</span>

<span class="sd">    order they are specified in the underlying :class:`MutationTable`. For canonical</span>
<span class="sd">    (i.e., valid) tables, this means ancestral mutations precede their descendants, so</span>
<span class="sd">    older mutations (as defined by the canonical mutation ordering; see</span>
<span class="sd">    :ref:`sec_mutation_requirements`) appear before younger ones.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :ref:`metadata &lt;sec_metadata_definition&gt;` for this site, decoded if a schema</span>
<span class="sd">    applies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># We need a custom eq for the numpy arrays</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Site</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">position</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ancestral_state</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">ancestral_state</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">mutations</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">metadata</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">alleles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the set of all the alleles defined at this site</span>

<span class="sd">        .. note::</span>
<span class="sd">            This deliberately returns an (unordered) *set* of the possible allelic</span>
<span class="sd">            states (as defined by the site&#39;s ancestral allele and its associated</span>
<span class="sd">            mutations). If you wish to obtain an (ordered) *list* of alleles, for</span>
<span class="sd">            example to translate the numeric genotypes at a site into allelic states,</span>
<span class="sd">            you should instead use ``.alleles`` attribute of the :class:`Variant` class,</span>
<span class="sd">            which unlike this attribute includes ``None`` as a state when there is</span>
<span class="sd">            missing data at a site.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ancestral_state</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="n">m</span><span class="o">.</span><span class="n">derived_state</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutations</span><span class="p">}</span></div>



<div class="viewcode-block" id="Mutation">
<a class="viewcode-back" href="../../python-api.html#tskit.Mutation">[docs]</a>
<span class="nd">@metadata_module</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">()</span>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Mutation</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :ref:`mutation &lt;sec_mutation_table_definition&gt;` in a tree sequence.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;id&quot;</span><span class="p">,</span>
        <span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="s2">&quot;node&quot;</span><span class="p">,</span>
        <span class="s2">&quot;derived_state&quot;</span><span class="p">,</span>
        <span class="s2">&quot;parent&quot;</span><span class="p">,</span>
        <span class="s2">&quot;metadata&quot;</span><span class="p">,</span>
        <span class="s2">&quot;time&quot;</span><span class="p">,</span>
        <span class="s2">&quot;edge&quot;</span><span class="p">,</span>
        <span class="s2">&quot;inherited_state&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># noqa A003</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of this mutation. Varies from 0 to</span>
<span class="sd">    :attr:`TreeSequence.num_mutations` - 1.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">site</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of the site that this mutation occurs at. To obtain</span>
<span class="sd">    further information about a site with a given ID use :meth:`TreeSequence.site`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">node</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of the first node that inherits this mutation.</span>
<span class="sd">    To obtain further information about a node with a given ID, use</span>
<span class="sd">    :meth:`TreeSequence.node`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">derived_state</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The derived state for this mutation. This is the state</span>
<span class="sd">    inherited by nodes in the subtree rooted at this mutation&#39;s node, unless</span>
<span class="sd">    another mutation occurs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parent</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of this mutation&#39;s parent mutation. When multiple</span>
<span class="sd">    mutations occur at a site along a path in the tree, mutations must</span>
<span class="sd">    record the mutation that is immediately above them. If the mutation does</span>
<span class="sd">    not have a parent, this is equal to the :data:`NULL` (-1).</span>
<span class="sd">    To obtain further information about a mutation with a given ID, use</span>
<span class="sd">    :meth:`TreeSequence.mutation`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :ref:`metadata &lt;sec_metadata_definition&gt;` for this mutation, decoded if a schema</span>
<span class="sd">    applies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The occurrence time of this mutation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">edge</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The ID of the edge that this mutation is on.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inherited_state</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The inherited state for this mutation. This is the state that existed at the site</span>
<span class="sd">    before this mutation occurred. This is either the ancestral state of the site</span>
<span class="sd">    (if the mutation has no parent) or the derived state of the mutation&#39;s</span>
<span class="sd">    parent mutation (if it has a parent).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># To get default values on slots we define a custom init</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="nb">id</span><span class="o">=</span><span class="n">NULL</span><span class="p">,</span>  <span class="c1"># noqa A003</span>
        <span class="n">site</span><span class="o">=</span><span class="n">NULL</span><span class="p">,</span>
        <span class="n">node</span><span class="o">=</span><span class="n">NULL</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="n">UNKNOWN_TIME</span><span class="p">,</span>
        <span class="n">derived_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">parent</span><span class="o">=</span><span class="n">NULL</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">edge</span><span class="o">=</span><span class="n">NULL</span><span class="p">,</span>
        <span class="n">inherited_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">site</span> <span class="o">=</span> <span class="n">site</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derived_state</span> <span class="o">=</span> <span class="n">derived_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edge</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inherited_state</span> <span class="o">=</span> <span class="n">inherited_state</span>

    <span class="c1"># We need a custom eq to compare unknown times.</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Mutation</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">site</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">site</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">node</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_state</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">derived_state</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">parent</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">edge</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">metadata</span>
            <span class="ow">and</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">time</span>
                <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">util</span><span class="o">.</span><span class="n">is_unknown_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span> <span class="ow">and</span> <span class="n">util</span><span class="o">.</span><span class="n">is_unknown_time</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="Migration">
<a class="viewcode-back" href="../../python-api.html#tskit.Migration">[docs]</a>
<span class="nd">@metadata_module</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">()</span>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Migration</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :ref:`migration &lt;sec_migration_table_definition&gt;` in a tree sequence.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;node&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;dest&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">]</span>
    <span class="n">left</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The left end of the genomic interval covered by this</span>
<span class="sd">    migration (inclusive).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">right</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The right end of the genomic interval covered by this migration</span>
<span class="sd">    (exclusive).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">node</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of the node involved in this migration event.</span>
<span class="sd">    To obtain further information about a node with a given ID, use</span>
<span class="sd">    :meth:`TreeSequence.node`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">source</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The source population ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dest</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The destination population ID.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span><span class="p">:</span> <span class="nb">float</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The time at which this migration occurred at.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :ref:`metadata &lt;sec_metadata_definition&gt;` for this migration, decoded if a schema</span>
<span class="sd">    applies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># noqa A003</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of this migration. Varies from 0 to</span>
<span class="sd">    :attr:`TreeSequence.num_migrations` - 1.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="Population">
<a class="viewcode-back" href="../../python-api.html#tskit.Population">[docs]</a>
<span class="nd">@metadata_module</span><span class="o">.</span><span class="n">lazy_decode</span><span class="p">()</span>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Population</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :ref:`population &lt;sec_population_table_definition&gt;` in a tree sequence.</span>

<span class="sd">    Modifying the attributes in this class will have **no effect** on the</span>
<span class="sd">    underlying tree sequence data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">]</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># noqa A003</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The integer ID of this population. Varies from 0 to</span>
<span class="sd">    :attr:`TreeSequence.num_populations` - 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :ref:`metadata &lt;sec_metadata_definition&gt;` for this population, decoded if a</span>
<span class="sd">    schema applies.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Edgeset</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;parent&quot;</span><span class="p">,</span> <span class="s2">&quot;children&quot;</span><span class="p">]</span>
    <span class="n">left</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">right</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">parent</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

    <span class="c1"># We need a custom eq for the numpy array</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Edgeset</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">left</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">right</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">parent</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="p">)</span>


<div class="viewcode-block" id="Provenance">
<a class="viewcode-back" href="../../python-api.html#tskit.Provenance">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Provenance</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">Dataclass</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A provenance entry in a tree sequence, detailing how this tree</span>
<span class="sd">    sequence was generated, or subsequent operations on it (see :ref:`sec_provenance`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;timestamp&quot;</span><span class="p">,</span> <span class="s2">&quot;record&quot;</span><span class="p">]</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># noqa A003</span>
    <span class="n">timestamp</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The time that this entry was made</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">record</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A JSON string giving details of the provenance (see :ref:`sec_provenance_example`</span>
<span class="sd">    for an example JSON string)</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="Tree">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Tree</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single tree in a :class:`TreeSequence`. Please see the</span>
<span class="sd">    :ref:`tutorials:sec_processing_trees` section for information</span>
<span class="sd">    on how efficiently access trees sequentially or obtain a list</span>
<span class="sd">    of individual trees in a tree sequence.</span>

<span class="sd">    The ``sample_lists`` parameter controls the features that are enabled</span>
<span class="sd">    for this tree. If ``sample_lists`` is True a more efficient algorithm is</span>
<span class="sd">    used in the :meth:`Tree.samples` method.</span>

<span class="sd">    The ``tracked_samples`` parameter can be used to efficiently count the</span>
<span class="sd">    number of samples in a given set that exist in a particular subtree</span>
<span class="sd">    using the :meth:`Tree.num_tracked_samples` method.</span>

<span class="sd">    The :class:`Tree` class is a state-machine which has a state</span>
<span class="sd">    corresponding to each of the trees in the parent tree sequence. We</span>
<span class="sd">    transition between these states by using the seek functions like</span>
<span class="sd">    :meth:`Tree.first`, :meth:`Tree.last`, :meth:`Tree.seek` and</span>
<span class="sd">    :meth:`Tree.seek_index`. There is one more state, the so-called &quot;null&quot;</span>
<span class="sd">    or &quot;cleared&quot; state. This is the state that a :class:`Tree` is in</span>
<span class="sd">    immediately after initialisation;  it has an index of -1, and no edges. We</span>
<span class="sd">    can also enter the null state by calling :meth:`Tree.next` on the last</span>
<span class="sd">    tree in a sequence, calling :meth:`Tree.prev` on the first tree in a</span>
<span class="sd">    sequence or calling calling the :meth:`Tree.clear` method at any time.</span>

<span class="sd">    The high-level TreeSequence seeking and iterations methods (e.g,</span>
<span class="sd">    :meth:`TreeSequence.trees`) are built on these low-level state-machine</span>
<span class="sd">    seek operations. We recommend these higher level operations for most</span>
<span class="sd">    users.</span>

<span class="sd">    :param TreeSequence tree_sequence: The parent tree sequence.</span>
<span class="sd">    :param list tracked_samples: The list of samples to be tracked and</span>
<span class="sd">        counted using the :meth:`Tree.num_tracked_samples` method.</span>
<span class="sd">    :param bool sample_lists: If True, provide more efficient access</span>
<span class="sd">        to the samples beneath a given node using the</span>
<span class="sd">        :meth:`Tree.samples` method.</span>
<span class="sd">    :param int root_threshold: The minimum number of samples that a node</span>
<span class="sd">        must be ancestral to for it to be in the list of roots. By default</span>
<span class="sd">        this is 1, so that isolated samples (representing missing data)</span>
<span class="sd">        are roots. To efficiently restrict the roots of the tree to</span>
<span class="sd">        those subtending meaningful topology, set this to 2. This value</span>
<span class="sd">        is only relevant when trees have multiple roots.</span>
<span class="sd">    :param bool sample_counts: Deprecated since 0.2.4.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tree_sequence</span><span class="p">,</span>
        <span class="n">tracked_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sample_lists</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">root_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">sample_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">options</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">sample_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The sample_counts option is not supported since 0.2.4 &quot;</span>
                <span class="s2">&quot;and is ignored&quot;</span><span class="p">,</span>
                <span class="ne">RuntimeWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">sample_lists</span><span class="p">:</span>
            <span class="n">options</span> <span class="o">|=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">SAMPLE_LISTS</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="n">options</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">root_threshold</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Root threshold must be greater than 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tracked_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO remove this when we allow numpy arrays in the low-level API.</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;tracked_samples&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tracked_samples</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_tree_sequence</span> <span class="o">=</span> <span class="n">tree_sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">Tree</span><span class="p">(</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">set_root_threshold</span><span class="p">(</span><span class="n">root_threshold</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_arrays</span><span class="p">()</span>

<div class="viewcode-block" id="Tree.copy">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a deep copy of this tree. The returned tree will have identical state</span>
<span class="sd">        to this tree.</span>

<span class="sd">        :return: A copy of this tree.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">copy</span><span class="o">.</span><span class="n">_tree_sequence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_sequence</span>
        <span class="n">copy</span><span class="o">.</span><span class="n">_ll_tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">copy</span><span class="o">.</span><span class="n">_make_arrays</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">copy</span></div>


    <span class="c1"># TODO make this method public and document it.</span>
    <span class="c1"># Note that this probably does not cover all corner cases correctly</span>
    <span class="c1"># https://github.com/tskit-dev/tskit/issues/1908</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_has_isolated_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO Is this definition correct for a single-node tree sequence?</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">roots</span><span class="p">:</span>
            <span class="c1"># If the root has no children then it must be a sample</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_child</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_make_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Store the low-level arrays for efficiency. There&#39;s no real overhead</span>
        <span class="c1"># in this, because the refer to the same underlying memory as the</span>
        <span class="c1"># tree object.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">parent_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_left_child_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">left_child_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_right_child_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">right_child_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_left_sib_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">left_sib_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_right_sib_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">right_sib_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_children_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">num_children_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">edge_array</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tree_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tree sequence that this tree is from.</span>

<span class="sd">        :return: The parent tree sequence for this tree.</span>
<span class="sd">        :rtype: :class:`TreeSequence`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tree_sequence</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">root_threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the minimum number of samples that a node must be an ancestor</span>
<span class="sd">        of to be considered a potential root. This can be set, for example, when</span>
<span class="sd">        calling the :meth:`TreeSequence.trees` iterator.</span>

<span class="sd">        :return: The root threshold.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_root_threshold</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_ll_tree</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.first">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.first">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Seeks to the first tree in the sequence. This can be called whether</span>
<span class="sd">        the tree is in the null state or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">first</span><span class="p">()</span></div>


<div class="viewcode-block" id="Tree.last">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.last">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Seeks to the last tree in the sequence. This can be called whether</span>
<span class="sd">        the tree is in the null state or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">last</span><span class="p">()</span></div>


<div class="viewcode-block" id="Tree.next">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.next">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa A002</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Seeks to the next tree in the sequence. If the tree is in the initial</span>
<span class="sd">        null state we seek to the first tree (equivalent to calling :meth:`~Tree.first`).</span>
<span class="sd">        Calling ``next`` on the last tree in the sequence results in the tree</span>
<span class="sd">        being cleared back into the null initial state (equivalent to calling</span>
<span class="sd">        :meth:`~Tree.clear`). The return value of the function indicates whether the</span>
<span class="sd">        tree is in a non-null state, and can be used to loop over the trees::</span>

<span class="sd">            # Iterate over the trees from left-to-right</span>
<span class="sd">            tree = tskit.Tree(tree_sequence)</span>
<span class="sd">            while tree.next()</span>
<span class="sd">                # Do something with the tree.</span>
<span class="sd">                print(tree.index)</span>
<span class="sd">            # tree is now back in the null state.</span>

<span class="sd">        :return: True if the tree has been transformed into one of the trees</span>
<span class="sd">            in the sequence; False if the tree has been transformed into the</span>
<span class="sd">            null state.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">next</span><span class="p">())</span></div>


<div class="viewcode-block" id="Tree.prev">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.prev">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prev</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Seeks to the previous tree in the sequence. If the tree is in the initial</span>
<span class="sd">        null state we seek to the last tree (equivalent to calling :meth:`~Tree.last`).</span>
<span class="sd">        Calling ``prev`` on the first tree in the sequence results in the tree</span>
<span class="sd">        being cleared back into the null initial state (equivalent to calling</span>
<span class="sd">        :meth:`~Tree.clear`). The return value of the function indicates whether the</span>
<span class="sd">        tree is in a non-null state, and can be used to loop over the trees::</span>

<span class="sd">            # Iterate over the trees from right-to-left</span>
<span class="sd">            tree = tskit.Tree(tree_sequence)</span>
<span class="sd">            while tree.prev()</span>
<span class="sd">                # Do something with the tree.</span>
<span class="sd">                print(tree.index)</span>
<span class="sd">            # tree is now back in the null state.</span>

<span class="sd">        :return: True if the tree has been transformed into one of the trees</span>
<span class="sd">            in the sequence; False if the tree has been transformed into the</span>
<span class="sd">            null state.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">prev</span><span class="p">())</span></div>


<div class="viewcode-block" id="Tree.clear">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.clear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets this tree back to the initial null state. Calling this method</span>
<span class="sd">        on a tree already in the null state has no effect.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>


<div class="viewcode-block" id="Tree.seek_index">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.seek_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">seek_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the state to represent the tree at the specified</span>
<span class="sd">        index in the parent tree sequence. Negative indexes following the</span>
<span class="sd">        standard Python conventions are allowed, i.e., ``index=-1`` will</span>
<span class="sd">        seek to the last tree in the sequence.</span>

<span class="sd">        .. include:: substitutions/linear_traversal_warning.rst</span>

<span class="sd">        :param int index: The tree index to seek to.</span>
<span class="sd">        :raises IndexError: If an index outside the acceptable range is provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_trees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_trees</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="n">num_trees</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">num_trees</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of bounds&quot;</span><span class="p">)</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">skip</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">skip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">seek_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">skip</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.seek">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.seek">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the state to represent the tree that covers the specified</span>
<span class="sd">        position in the parent tree sequence. After a successful return</span>
<span class="sd">        of this method we have ``tree.interval.left`` &lt;= ``position``</span>
<span class="sd">        &lt; ``tree.interval.right``.</span>

<span class="sd">        .. include:: substitutions/linear_traversal_warning.rst</span>

<span class="sd">        :param float position: The position along the sequence length to</span>
<span class="sd">            seek to.</span>
<span class="sd">        :raises ValueError: If ``position`` is less than 0 or ``position`` is greater</span>
<span class="sd">            than or equal to</span>
<span class="sd">            :attr:`TreeSequence.sequence_length`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">position</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Position out of bounds&quot;</span><span class="p">)</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">skip</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">skip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">skip</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.rank">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.rank">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tskit</span><span class="o">.</span><span class="n">Rank</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce the rank of this tree in the enumeration of all leaf-labelled</span>
<span class="sd">        trees of n leaves. See the :ref:`sec_tree_ranks` section for</span>
<span class="sd">        details on ranking and unranking trees.</span>

<span class="sd">        :raises ValueError: If the tree has multiple roots.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">RankTree</span><span class="o">.</span><span class="n">from_tsk_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">rank</span><span class="p">()</span></div>


<div class="viewcode-block" id="Tree.unrank">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.unrank">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">unrank</span><span class="p">(</span><span class="n">num_leaves</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">branch_length</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tree</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct the tree of the given ``rank``</span>
<span class="sd">        (see :meth:`tskit.Tree.rank`) with ``num_leaves`` leaves.</span>
<span class="sd">        The labels and times of internal nodes are assigned by a postorder</span>
<span class="sd">        traversal of the nodes, such that the time of each internal node</span>
<span class="sd">        is the maximum time of its children plus the specified ``branch_length``.</span>
<span class="sd">        The time of each leaf is 0.</span>

<span class="sd">        See the :ref:`sec_tree_ranks` section for details on ranking and</span>
<span class="sd">        unranking trees and what constitutes valid ranks.</span>

<span class="sd">        :param int num_leaves: The number of leaves of the tree to generate.</span>
<span class="sd">        :param tuple(int) rank: The rank of the tree to generate.</span>
<span class="sd">        :param float span: The genomic span of the returned tree. The tree will cover</span>
<span class="sd">            the interval :math:`[0, \\text{span})` and the :attr:`~Tree.tree_sequence`</span>
<span class="sd">            from which the tree is taken will have its</span>
<span class="sd">            :attr:`~tskit.TreeSequence.sequence_length` equal to ``span``.</span>
<span class="sd">        :param float branch_length: The minimum length of a branch in this tree.</span>
<span class="sd">        :raises ValueError: If the given rank is out of bounds for trees</span>
<span class="sd">            with ``num_leaves`` leaves.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rank_tree</span> <span class="o">=</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">RankTree</span><span class="o">.</span><span class="n">unrank</span><span class="p">(</span><span class="n">num_leaves</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rank_tree</span><span class="o">.</span><span class="n">to_tsk_tree</span><span class="p">(</span><span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">,</span> <span class="n">branch_length</span><span class="o">=</span><span class="n">branch_length</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.count_topologies">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.count_topologies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">count_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TopologyCounter</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the distribution of embedded topologies for every combination</span>
<span class="sd">        of the sample sets in ``sample_sets``. ``sample_sets`` defaults to all</span>
<span class="sd">        samples in the tree grouped by population.</span>

<span class="sd">        ``sample_sets`` need not include all samples but must be pairwise disjoint.</span>

<span class="sd">        The returned object is a :class:`tskit.TopologyCounter` that contains</span>
<span class="sd">        counts of topologies per combination of sample sets. For example::</span>

<span class="sd">            topology_counter = tree.count_topologies()</span>
<span class="sd">            rank, count = topology_counter[0, 1, 2].most_common(1)[0]</span>

<span class="sd">        produces the most common tree topology, with populations 0, 1</span>
<span class="sd">        and 2 as its tips, according to the genealogies of those</span>
<span class="sd">        populations&#39; samples in this tree.</span>

<span class="sd">        The counts for each topology in the :class:`tskit.TopologyCounter`</span>
<span class="sd">        are absolute counts that we would get if we were to select all</span>
<span class="sd">        combinations of samples from the relevant sample sets.</span>
<span class="sd">        For sample sets :math:`[s_0, s_1, ..., s_n]`, the total number of</span>
<span class="sd">        topologies for those sample sets is equal to</span>
<span class="sd">        :math:`|s_0| * |s_1| * ... * |s_n|`, so the counts in the counter</span>
<span class="sd">        ``topology_counter[0, 1, ..., n]`` should sum to</span>
<span class="sd">        :math:`|s_0| * |s_1| * ... * |s_n|`.</span>

<span class="sd">        To convert the topology counts to probabilities, divide by the total</span>
<span class="sd">        possible number of sample combinations from the sample sets in question::</span>

<span class="sd">            set_sizes = [len(sample_set) for sample_set in sample_sets]</span>
<span class="sd">            p = count / (set_sizes[0] * set_sizes[1] * set_sizes[2])</span>

<span class="sd">        .. warning:: The interface for this method is preliminary and may be subject to</span>
<span class="sd">            backwards incompatible changes in the near future.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">            Defaults to all samples grouped by population.</span>
<span class="sd">        :raises ValueError: If nodes in ``sample_sets`` are invalid or are</span>
<span class="sd">            internal samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="n">population</span><span class="o">=</span><span class="n">pop</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">populations</span><span class="p">()</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">tree_count_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_branch_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for branch_length</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_length</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.branch_length">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.branch_length">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">branch_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the length of the branch (in units of time) joining the</span>
<span class="sd">        specified node to its parent. This is equivalent to::</span>

<span class="sd">            tree.time(tree.parent(u)) - tree.time(u)</span>

<span class="sd">        The branch length for a node that has no parent (e.g., a root) is</span>
<span class="sd">        defined as zero.</span>

<span class="sd">        Note that this is not related to the property `.length` which</span>
<span class="sd">        is a deprecated alias for the genomic :attr:`~Tree.span` covered by a tree.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The branch length from u to its parent.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_total_branch_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for total_branch_length</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_branch_length</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">total_branch_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sum of all the branch lengths in this tree (in</span>
<span class="sd">        units of time). This is equivalent to::</span>

<span class="sd">            sum(tree.branch_length(u) for u in tree.nodes())</span>

<span class="sd">        Note that the branch lengths for root nodes are defined as zero.</span>

<span class="sd">        As this is defined by a traversal of the tree, technically we</span>
<span class="sd">        return the sum of all branch lengths that are reachable from</span>
<span class="sd">        roots. Thus, this is the total length of all branches that are connected</span>
<span class="sd">        to at least one sample. This distinction is only important</span>
<span class="sd">        in tree sequences that contain &#39;dead branches&#39;, i.e., those</span>
<span class="sd">        that define topology that is not connected to a tree root</span>
<span class="sd">        (see :ref:`sec_data_model_tree_dead_leaves_and_branches`)</span>

<span class="sd">        :return: The sum of lengths of branches in this tree.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_total_branch_length</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_mrca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for mrca</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mrca</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.mrca">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.mrca">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mrca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the most recent common ancestor of the specified nodes.</span>

<span class="sd">        :param int `*args`: input node IDs, at least 2 arguments are required.</span>
<span class="sd">        :return: The node ID of the most recent common ancestor of the</span>
<span class="sd">            input nodes, or :data:`tskit.NULL` if the nodes do not share</span>
<span class="sd">            a common ancestor in the tree.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must supply at least two arguments&quot;</span><span class="p">)</span>
        <span class="n">mrca</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">mrca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_mrca</span><span class="p">(</span><span class="n">mrca</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mrca</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">mrca</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_tmrca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for tmrca</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmrca</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.tmrca">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.tmrca">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tmrca</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the time of the most recent common ancestor of the specified</span>
<span class="sd">        nodes. This is equivalent to::</span>

<span class="sd">            tree.time(tree.mrca(*args))</span>

<span class="sd">        .. note::</span>
<span class="sd">            If you are using this method to calculate average tmrca values along the</span>
<span class="sd">            genome between pairs of sample nodes, for efficiency reasons you should</span>
<span class="sd">            instead consider the ``mode=&quot;branch&quot;`` option of the</span>
<span class="sd">            :meth:`TreeSequence.divergence` or :meth:`TreeSequence.diversity` methods.</span>
<span class="sd">            Since these calculate the average branch length between pairs of sample</span>
<span class="sd">            nodes, for samples at time 0 the resulting statistics will be exactly</span>
<span class="sd">            twice the tmrca value.</span>

<span class="sd">        :param `*args`: input node IDs, at least 2 arguments are required.</span>
<span class="sd">        :return: The time of the most recent common ancestor of all the nodes.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        :raises ValueError: If the nodes do not share a single common ancestor in this</span>
<span class="sd">            tree (i.e., if ``tree.mrca(*args) == tskit.NULL``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mrca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mrca</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mrca</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nodes </span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2"> do not share a common ancestor in the tree&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_time</span><span class="p">(</span><span class="n">mrca</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for parent</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.parent">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.parent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the parent of the specified node. Returns</span>
<span class="sd">        :data:`tskit.NULL` if u is a root or is not a node in</span>
<span class="sd">        the current tree.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The parent of u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parent_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A numpy array (dtype=np.int32) encoding the parent of each node</span>
<span class="sd">        in this tree, such that ``tree.parent_array[u] == tree.parent(u)``</span>
<span class="sd">        for all ``0 &lt;= u &lt;= ts.num_nodes``. See the :meth:`~.parent`</span>
<span class="sd">        method for details on the semantics of tree parents and the</span>
<span class="sd">        :ref:`sec_data_model_tree_structure` section for information on the</span>
<span class="sd">        quintuply linked tree encoding.</span>

<span class="sd">        .. include:: substitutions/virtual_root_array_note.rst</span>

<span class="sd">        .. include:: substitutions/tree_array_warning.rst</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_array</span>

<div class="viewcode-block" id="Tree.ancestors">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.ancestors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the ancestors of node ``u`` in this tree</span>
<span class="sd">        (i.e. the chain of parents from ``u`` to the root).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">u</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">u</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


    <span class="c1"># Quintuply linked tree structure.</span>

<div class="viewcode-block" id="Tree.left_child">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.left_child">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">left_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the leftmost child of the specified node. Returns</span>
<span class="sd">        :data:`tskit.NULL` if u is a leaf or is not a node in</span>
<span class="sd">        the current tree. The left-to-right ordering of children</span>
<span class="sd">        is arbitrary and should not be depended on; see the</span>
<span class="sd">        :ref:`data model &lt;sec_data_model_tree_structure&gt;` section</span>
<span class="sd">        for details.</span>

<span class="sd">        This is a low-level method giving access to the quintuply linked</span>
<span class="sd">        tree structure in memory; the :meth:`.children` method is a more</span>
<span class="sd">        convenient way to obtain the children of a given node.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The leftmost child of u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_left_child</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">left_child_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A numpy array (dtype=np.int32) encoding the left child of each node</span>
<span class="sd">        in this tree, such that ``tree.left_child_array[u] == tree.left_child(u)``</span>
<span class="sd">        for all ``0 &lt;= u &lt;= ts.num_nodes``. See the :meth:`~.left_child`</span>
<span class="sd">        method for details on the semantics of tree left_child and the</span>
<span class="sd">        :ref:`sec_data_model_tree_structure` section for information on the</span>
<span class="sd">        quintuply linked tree encoding.</span>

<span class="sd">        .. include:: substitutions/virtual_root_array_note.rst</span>

<span class="sd">        .. include:: substitutions/tree_array_warning.rst</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_child_array</span>

<div class="viewcode-block" id="Tree.right_child">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.right_child">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">right_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the rightmost child of the specified node. Returns</span>
<span class="sd">        :data:`tskit.NULL` if u is a leaf or is not a node in</span>
<span class="sd">        the current tree. The left-to-right ordering of children</span>
<span class="sd">        is arbitrary and should not be depended on; see the</span>
<span class="sd">        :ref:`data model &lt;sec_data_model_tree_structure&gt;` section</span>
<span class="sd">        for details.</span>

<span class="sd">        This is a low-level method giving access to the quintuply linked</span>
<span class="sd">        tree structure in memory; the :meth:`.children` method is a more</span>
<span class="sd">        convenient way to obtain the children of a given node.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The rightmost child of u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_right_child</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">right_child_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A numpy array (dtype=np.int32) encoding the right child of each node</span>
<span class="sd">        in this tree, such that ``tree.right_child_array[u] == tree.right_child(u)``</span>
<span class="sd">        for all ``0 &lt;= u &lt;= ts.num_nodes``. See the :meth:`~.right_child`</span>
<span class="sd">        method for details on the semantics of tree right_child and the</span>
<span class="sd">        :ref:`sec_data_model_tree_structure` section for information on the</span>
<span class="sd">        quintuply linked tree encoding.</span>

<span class="sd">        .. include:: substitutions/virtual_root_array_note.rst</span>

<span class="sd">        .. include:: substitutions/tree_array_warning.rst</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_child_array</span>

<div class="viewcode-block" id="Tree.left_sib">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.left_sib">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">left_sib</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sibling node to the left of u, or :data:`tskit.NULL`</span>
<span class="sd">        if u does not have a left sibling.</span>
<span class="sd">        The left-to-right ordering of children</span>
<span class="sd">        is arbitrary and should not be depended on; see the</span>
<span class="sd">        :ref:`data model &lt;sec_data_model_tree_structure&gt;` section</span>
<span class="sd">        for details.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The sibling node to the left of u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_left_sib</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">left_sib_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A numpy array (dtype=np.int32) encoding the left sib of each node</span>
<span class="sd">        in this tree, such that ``tree.left_sib_array[u] == tree.left_sib(u)``</span>
<span class="sd">        for all ``0 &lt;= u &lt;= ts.num_nodes``. See the :meth:`~.left_sib`</span>
<span class="sd">        method for details on the semantics of tree left_sib and the</span>
<span class="sd">        :ref:`sec_data_model_tree_structure` section for information on the</span>
<span class="sd">        quintuply linked tree encoding.</span>

<span class="sd">        .. include:: substitutions/virtual_root_array_note.rst</span>

<span class="sd">        .. include:: substitutions/tree_array_warning.rst</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_sib_array</span>

<div class="viewcode-block" id="Tree.right_sib">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.right_sib">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">right_sib</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sibling node to the right of u, or :data:`tskit.NULL`</span>
<span class="sd">        if u does not have a right sibling.</span>
<span class="sd">        The left-to-right ordering of children</span>
<span class="sd">        is arbitrary and should not be depended on; see the</span>
<span class="sd">        :ref:`data model &lt;sec_data_model_tree_structure&gt;` section</span>
<span class="sd">        for details.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The sibling node to the right of u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_right_sib</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">right_sib_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A numpy array (dtype=np.int32) encoding the right sib of each node</span>
<span class="sd">        in this tree, such that ``tree.right_sib_array[u] == tree.right_sib(u)``</span>
<span class="sd">        for all ``0 &lt;= u &lt;= ts.num_nodes``. See the :meth:`~.right_sib`</span>
<span class="sd">        method for details on the semantics of tree right_sib and the</span>
<span class="sd">        :ref:`sec_data_model_tree_structure` section for information on the</span>
<span class="sd">        quintuply linked tree encoding.</span>

<span class="sd">        .. include:: substitutions/virtual_root_array_note.rst</span>

<span class="sd">        .. include:: substitutions/tree_array_warning.rst</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_sib_array</span>

<div class="viewcode-block" id="Tree.siblings">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.siblings">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">siblings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sibling(s) of the specified node ``u`` as a tuple of integer</span>
<span class="sd">        node IDs. If ``u`` has no siblings or is not a node in the current tree,</span>
<span class="sd">        returns an empty tuple. If ``u`` is the root of a single-root tree,</span>
<span class="sd">        returns an empty tuple; if ``u`` is the root of a multi-root tree,</span>
<span class="sd">        returns the other roots (note all the roots are related by the virtual root).</span>
<span class="sd">        If ``u`` is the virtual root (which has no siblings), returns an empty tuple.</span>
<span class="sd">        If ``u`` is an isolated node, whether it has siblings or not depends on</span>
<span class="sd">        whether it is a sample or non-sample node; if it is a sample node,</span>
<span class="sd">        returns the root(s) of the tree, otherwise, returns an empty tuple.</span>
<span class="sd">        The ordering of siblings  is arbitrary and should not be depended on;</span>
<span class="sd">        see the :ref:`data model &lt;sec_data_model_tree_structure&gt;` section for details.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The siblings of ``u``.</span>
<span class="sd">        :rtype: tuple(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_root</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_root</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_root</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="o">!=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_children_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A numpy array (dtype=np.int32) encoding the number of children of</span>
<span class="sd">        each node in this tree, such that</span>
<span class="sd">        ``tree.num_children_array[u] == tree.num_children(u)`` for all</span>
<span class="sd">        ``0 &lt;= u &lt;= ts.num_nodes``. See the :meth:`~.num_children`</span>
<span class="sd">        method for details on the semantics of tree num_children and the</span>
<span class="sd">        :ref:`sec_data_model_tree_structure` section for information on the</span>
<span class="sd">        quintuply linked tree encoding.</span>

<span class="sd">        .. include:: substitutions/virtual_root_array_note.rst</span>

<span class="sd">        .. include:: substitutions/tree_array_warning.rst</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_children_array</span>

<div class="viewcode-block" id="Tree.edge">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.edge">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the id of the edge encoding the relationship between ``u``</span>
<span class="sd">        and its parent, or :data:`tskit.NULL` if ``u`` is a root, virtual root</span>
<span class="sd">        or is not a node in the current tree.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: Id of edge connecting u to its parent.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_edge</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">edge_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A numpy array (dtype=np.int32) of edge ids encoding the relationship</span>
<span class="sd">        between the child node ``u`` and its parent, such that</span>
<span class="sd">        ``tree.edge_array[u] == tree.edge(u)`` for all</span>
<span class="sd">        ``0 &lt;= u &lt;= ts.num_nodes``. See the :meth:`~.edge`</span>
<span class="sd">        method for details on the semantics of tree edge and the</span>
<span class="sd">        :ref:`sec_data_model_tree_structure` section for information on the</span>
<span class="sd">        quintuply linked tree encoding.</span>

<span class="sd">        .. include:: substitutions/virtual_root_array_note.rst</span>

<span class="sd">        .. include:: substitutions/tree_array_warning.rst</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_array</span>

    <span class="c1"># Sample list.</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">left_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_left_sample</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">right_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_right_sample</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">next_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_next_sample</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">virtual_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ID of the virtual root in this tree. This is equal to</span>
<span class="sd">        :attr:`TreeSequence.num_nodes`.</span>

<span class="sd">        Please see the :ref:`tree roots &lt;sec_data_model_tree_roots&gt;`</span>
<span class="sd">        section for more details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_virtual_root</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The total number of edges in this tree. This is equal to the</span>
<span class="sd">        number of tree sequence edges that intersect with this tree&#39;s</span>
<span class="sd">        genomic interval.</span>

<span class="sd">        Note that this may be greater than the number of branches that</span>
<span class="sd">        are reachable from the tree&#39;s roots, since we can have topology</span>
<span class="sd">        that is not associated with any samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_edges</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">left_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The leftmost root in this tree. If there are multiple roots</span>
<span class="sd">        in this tree, they are siblings of this node, and so we can</span>
<span class="sd">        use :meth:`.right_sib` to iterate over all roots:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            u = tree.left_root</span>
<span class="sd">            while u != tskit.NULL:</span>
<span class="sd">                print(&quot;Root:&quot;, u)</span>
<span class="sd">                u = tree.right_sib(u)</span>

<span class="sd">        The left-to-right ordering of roots is arbitrary and should</span>
<span class="sd">        not be depended on; see the</span>
<span class="sd">        :ref:`data model &lt;sec_data_model_tree_structure&gt;`</span>
<span class="sd">        section for details.</span>

<span class="sd">        This is a low-level method giving access to the quintuply linked</span>
<span class="sd">        tree structure in memory; the :attr:`~Tree.roots` attribute is a more</span>
<span class="sd">        convenient way to obtain the roots of a tree. If you are assuming</span>
<span class="sd">        that there is a single root in the tree you should use the</span>
<span class="sd">        :attr:`~Tree.root` property.</span>

<span class="sd">        .. warning:: Do not use this property if you are assuming that there</span>
<span class="sd">            is a single root in trees that are being processed. The</span>
<span class="sd">            :attr:`~Tree.root` property should be used in this case, as it will</span>
<span class="sd">            raise an error when multiple roots exists.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_child</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">virtual_root</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">right_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_child</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">virtual_root</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.children</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.children">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.children">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the children of the specified node ``u`` as a tuple of integer node IDs.</span>
<span class="sd">        If ``u`` is a leaf, return the empty tuple. The ordering of children</span>
<span class="sd">        is arbitrary and should not be depended on; see the</span>
<span class="sd">        :ref:`data model &lt;sec_data_model_tree_structure&gt;` section</span>
<span class="sd">        for details.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The children of ``u`` as a tuple of integers</span>
<span class="sd">        :rtype: tuple(int)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_children</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.time</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.time">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.time">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the time of the specified node. This is equivalently</span>
<span class="sd">        to ``tree.tree_sequence.node(u).time`` except for the special</span>
<span class="sd">        case of the tree&#39;s :ref:`virtual root &lt;sec_data_model_tree_roots&gt;`,</span>
<span class="sd">        which is defined as positive infinity.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The time of u.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_time</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.depth">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.depth">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of nodes on the path from ``u`` to a</span>
<span class="sd">        root, not including ``u``. Thus, the depth of a root is</span>
<span class="sd">        zero.</span>

<span class="sd">        As a special case, the depth of the :ref:`virtual root</span>
<span class="sd">        &lt;sec_data_model_tree_roots&gt;` is defined as -1.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The depth of u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">depth</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.population</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.population">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.population">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the population associated with the specified node.</span>
<span class="sd">        Equivalent to ``tree.tree_sequence.node(u).population``.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The ID of the population associated with node u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_population</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.is_internal">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.is_internal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the specified node is not a leaf. A node is internal</span>
<span class="sd">        if it has one or more children in the current tree.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: True if u is not a leaf node.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.is_leaf">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.is_leaf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the specified node is a leaf. A node :math:`u` is a</span>
<span class="sd">        leaf if it has zero children.</span>

<span class="sd">        .. note::</span>
<span class="sd">            :math:`u` can be any node in the entire tree sequence, including ones</span>
<span class="sd">            which are not connected via branches to a root node of the tree (and which</span>
<span class="sd">            are therefore not conventionally considered part of the tree). Indeed, if</span>
<span class="sd">            there are many trees in the tree sequence, it is common for the majority of</span>
<span class="sd">            non-sample nodes to be :meth:`isolated&lt;is_isolated&gt;` in any one</span>
<span class="sd">            tree. By the definition above, this method will return ``True`` for such</span>
<span class="sd">            a tree when a node of this sort is specified. Such nodes can be thought of</span>
<span class="sd">            as &quot;dead leaves&quot;, see :ref:`sec_data_model_tree_dead_leaves_and_branches`.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: True if u is a leaf node.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="Tree.is_isolated">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.is_isolated">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_isolated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the specified node is isolated in this tree: that is</span>
<span class="sd">        it has no parents and no children (note that all isolated nodes in the tree</span>
<span class="sd">        are therefore also :meth:`leaves&lt;Tree.is_leaf&gt;`). Sample nodes that are isolated</span>
<span class="sd">        and have no mutations above them are used to represent</span>
<span class="sd">        :ref:`missing data&lt;sec_data_model_missing_data&gt;`.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: True if u is an isolated node.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_children</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="n">NULL</span></div>


<div class="viewcode-block" id="Tree.is_sample">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.is_sample">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the specified node is a sample. A node :math:`u` is a</span>
<span class="sd">        sample if it has been marked as a sample in the parent tree sequence.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: True if u is a sample.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">is_sample</span><span class="p">(</span><span class="n">u</span><span class="p">))</span></div>


<div class="viewcode-block" id="Tree.is_descendant">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.is_descendant">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_descendant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the specified node u is a descendant of node v and False</span>
<span class="sd">        otherwise. A node :math:`u` is a descendant of another node :math:`v` if</span>
<span class="sd">        :math:`v` is on the path from :math:`u` to root. A node is considered</span>
<span class="sd">        to be a descendant of itself, so ``tree.is_descendant(u, u)`` will be</span>
<span class="sd">        True for any valid node.</span>

<span class="sd">        :param int u: The descendant node.</span>
<span class="sd">        :param int v: The ancestral node.</span>
<span class="sd">        :return: True if u is a descendant of v.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        :raises ValueError: If u or v are not valid node IDs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">is_descendant</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of nodes in the :class:`TreeSequence` this tree is in.</span>
<span class="sd">        Equivalent to ``tree.tree_sequence.num_nodes``.</span>

<span class="sd">        .. deprecated:: 0.4</span>
<span class="sd">            Use :attr:`Tree.tree_sequence.num_nodes&lt;TreeSequence.num_nodes&gt;` if you want</span>
<span class="sd">            the number of nodes in the entire tree sequence, or</span>
<span class="sd">            ``len(tree.preorder())`` to find the number of nodes that are</span>
<span class="sd">            reachable from all roots in this tree.</span>

<span class="sd">        :rtype: int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;This property is a deprecated alias for Tree.tree_sequence.num_nodes &quot;</span>
            <span class="s2">&quot;and will be removed in the future. To obtain the number of nodes &quot;</span>
            <span class="s2">&quot;in the topology of the current tree (i.e. reachable from the roots) &quot;</span>
            <span class="s2">&quot;use len(tree.preorder()).&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_nodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of roots in this tree, as defined in the :attr:`~Tree.roots`</span>
<span class="sd">        attribute.</span>

<span class="sd">        Only requires O(number of roots) time.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_roots</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_single_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ``True`` if this tree has a single root, ``False`` otherwise.</span>
<span class="sd">        Equivalent to tree.num_roots == 1. This is a O(1) operation.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_root</span>
        <span class="k">if</span> <span class="n">root</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_sib</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_multiple_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ``True`` if this tree has more than one root, ``False`` otherwise.</span>
<span class="sd">        Equivalent to tree.num_roots &gt; 1. This is a O(1) operation.</span>

<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_root</span>
        <span class="k">if</span> <span class="n">root</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_sib</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The list of roots in this tree. A root is defined as a unique endpoint of the</span>
<span class="sd">        paths starting at samples, subject to the condition that it is connected to at</span>
<span class="sd">        least :attr:`root_threshold` samples. We can define the set of roots as follows:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            roots = set()</span>
<span class="sd">            for u in tree_sequence.samples():</span>
<span class="sd">                while tree.parent(u) != tskit.NULL:</span>
<span class="sd">                    u = tree.parent(u)</span>
<span class="sd">                if tree.num_samples(u) &gt;= tree.root_threshold:</span>
<span class="sd">                    roots.add(u)</span>
<span class="sd">            # roots is now the set of all roots in this tree.</span>
<span class="sd">            assert sorted(roots) == sorted(tree.roots)</span>

<span class="sd">        The roots of the tree are returned in a list, in no particular order.</span>

<span class="sd">        Only requires O(number of roots) time.</span>

<span class="sd">        .. note::</span>
<span class="sd">            In trees with large amounts of :ref:`sec_data_model_missing_data`,</span>
<span class="sd">            for example where a region of the genome lacks any ancestral information,</span>
<span class="sd">            there can be a very large number of roots, potentially all the samples</span>
<span class="sd">            in the tree sequence.</span>

<span class="sd">        :return: The list of roots in this tree.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_root</span>
        <span class="k">while</span> <span class="n">u</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">:</span>
            <span class="n">roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_sib</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">roots</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.root</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The root of this tree. If the tree contains multiple roots, a ValueError is</span>
<span class="sd">        raised indicating that the :attr:`~Tree.roots` attribute should be used instead.</span>

<span class="sd">        :return: The root node.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        :raises ValueError: if this tree contains more than one root.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_multiple_roots</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;More than one root exists. Use tree.roots instead&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_root</span>

<div class="viewcode-block" id="Tree.is_root">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.is_root">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns ``True`` if the specified node is a root in this tree (see</span>
<span class="sd">        :attr:`~Tree.roots` for the definition of a root). This is exactly equivalent to</span>
<span class="sd">        finding the node ID in :attr:`~Tree.roots`, but is more efficient for trees</span>
<span class="sd">        with large numbers of roots, such as in regions with extensive</span>
<span class="sd">        :ref:`sec_data_model_missing_data`.  Note that ``False`` is returned for all</span>
<span class="sd">        other nodes, including :ref:`isolated&lt;sec_data_model_tree_isolated_nodes&gt;`</span>
<span class="sd">        non-sample nodes which are not found in the topology of the current tree.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: ``True`` if u is a root.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_threshold</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.index</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index this tree occupies in the parent tree sequence.</span>
<span class="sd">        This index is zero based, so the first tree in the sequence has index 0.</span>

<span class="sd">        :return: The index of this tree.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_index</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.interval</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the coordinates of the genomic interval that this tree</span>
<span class="sd">        represents the history of. The interval is returned as a tuple</span>
<span class="sd">        :math:`(l, r)` and is a half-open interval such that the left</span>
<span class="sd">        coordinate is inclusive and the right coordinate is exclusive. This</span>
<span class="sd">        tree therefore applies to all genomic locations :math:`x` such that</span>
<span class="sd">        :math:`l \\leq x &lt; r`.</span>

<span class="sd">        :return: A named tuple (l, r) representing the left-most (inclusive)</span>
<span class="sd">            and right-most (exclusive) coordinates of the genomic region</span>
<span class="sd">            covered by this tree. The coordinates can be accessed by index</span>
<span class="sd">            (``0`` or ``1``) or equivalently by name (``.left`` or ``.right``)</span>
<span class="sd">        :rtype: Interval</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Interval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_left</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_right</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.span</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.span</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">span</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">span</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the genomic distance that this tree spans.</span>
<span class="sd">        This is defined as :math:`r - l`, where :math:`(l, r)` is the genomic</span>
<span class="sd">        interval returned by :attr:`~Tree.interval`.</span>

<span class="sd">        :return: The genomic distance covered by this tree.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">span</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the midpoint of the genomic interval that this tree represents</span>
<span class="sd">        the history of. This is defined as :math:`(l + (r - l) / 2)`, where</span>
<span class="sd">        :math:`(l, r)` is the genomic interval returned by</span>
<span class="sd">        :attr:`~Tree.interval`.</span>

<span class="sd">        :return: The genomic distance covered by this tree.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">mid</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_sample_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.sample_size</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sample_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deliberately undocumented but kept for backwards compatibility.</span>
        <span class="c1"># The proper way to access this is via tree.tree_sequence.num_samples</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_sample_size</span><span class="p">()</span>

<div class="viewcode-block" id="Tree.draw_text">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.draw_text">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw_text</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">orientation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">node_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_ascii</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a text representation of a tree.</span>

<span class="sd">        :param str orientation: one of ``&quot;top&quot;``, ``&quot;left&quot;``, ``&quot;bottom&quot;``, or</span>
<span class="sd">            ``&quot;right&quot;``, specifying the margin on which the root is placed. Specifying</span>
<span class="sd">            ``&quot;left&quot;`` or ``&quot;right&quot;`` will lead to time being shown on the x axis (i.e.</span>
<span class="sd">            a &quot;horizontal&quot; tree. If ``None`` (default) use the standard coalescent</span>
<span class="sd">            arrangement of a vertical tree with recent nodes at the bottom of the plot</span>
<span class="sd">            and older nodes above.</span>
<span class="sd">        :param dict node_labels: If specified, show custom labels for the nodes</span>
<span class="sd">            that are present in the map. Any nodes not specified in the map will</span>
<span class="sd">            not have a node label.</span>
<span class="sd">        :param str max_time: If equal to ``&quot;tree&quot;`` (the default), the maximum time</span>
<span class="sd">            is set to be that of the oldest root in the tree. If equal to ``&quot;ts&quot;`` the</span>
<span class="sd">            maximum time is set to be the time of the oldest root in the tree</span>
<span class="sd">            sequence; this is useful when drawing trees from the same tree sequence as it</span>
<span class="sd">            ensures that node heights are consistent.</span>
<span class="sd">        :param bool use_ascii: If ``False`` (default) then use unicode</span>
<span class="sd">            `box drawing characters \</span>
<span class="sd">&lt;https://en.wikipedia.org/wiki/Box-drawing_character&gt;`_</span>
<span class="sd">            to render the tree. If ``True``, use plain ascii characters, which look</span>
<span class="sd">            cruder but are less susceptible to misalignment or font substitution.</span>
<span class="sd">            Alternatively, if you are having alignment problems with Unicode, you can try</span>
<span class="sd">            out the solution documented `here \</span>
<span class="sd">&lt;https://github.com/tskit-dev/tskit/issues/189#issuecomment-499114811&gt;`_.</span>
<span class="sd">        :param str order: The left-to-right ordering of child nodes in the drawn tree.</span>
<span class="sd">            This can be either: ``&quot;minlex&quot;``, which minimises the differences</span>
<span class="sd">            between adjacent trees (see also the ``&quot;minlex_postorder&quot;`` traversal</span>
<span class="sd">            order for the :meth:`.nodes` method); or ``&quot;tree&quot;`` which draws trees</span>
<span class="sd">            in the left-to-right order defined by the</span>
<span class="sd">            :ref:`quintuply linked tree structure &lt;sec_data_model_tree_structure&gt;`.</span>
<span class="sd">            If not specified or None, this defaults to ``&quot;minlex&quot;``.</span>

<span class="sd">        :return: A text representation of a tree.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="n">drawing</span><span class="o">.</span><span class="n">check_orientation</span><span class="p">(</span><span class="n">orientation</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="ow">in</span> <span class="p">(</span><span class="n">drawing</span><span class="o">.</span><span class="n">LEFT</span><span class="p">,</span> <span class="n">drawing</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">):</span>
            <span class="n">text_tree</span> <span class="o">=</span> <span class="n">drawing</span><span class="o">.</span><span class="n">HorizontalTextTree</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span>
                <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span>
                <span class="n">max_time</span><span class="o">=</span><span class="n">max_time</span><span class="p">,</span>
                <span class="n">use_ascii</span><span class="o">=</span><span class="n">use_ascii</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">text_tree</span> <span class="o">=</span> <span class="n">drawing</span><span class="o">.</span><span class="n">VerticalTextTree</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span>
                <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span>
                <span class="n">max_time</span><span class="o">=</span><span class="n">max_time</span><span class="p">,</span>
                <span class="n">use_ascii</span><span class="o">=</span><span class="n">use_ascii</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">text_tree</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.draw_svg">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.draw_svg">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw_svg</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tree_height_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">min_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_tree_height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mutation_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_titles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mutation_titles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">root_svg_attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">force_root_branch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">symbol_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_regions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">y_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">y_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">y_ticks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">y_gridlines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">all_edge_mutations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">omit_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">canvas_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">preamble</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an SVG representation of a single tree. By default, numeric</span>
<span class="sd">        labels are drawn beside nodes and mutations: these can be altered using the</span>
<span class="sd">        ``node_labels`` and ``mutation_labels`` parameters. See the</span>
<span class="sd">        :ref:`visualization tutorial&lt;tutorials:sec_tskit_viz&gt;` for more details.</span>

<span class="sd">        :param str path: The path to the file to write the output. If None, do not</span>
<span class="sd">            write to file.</span>
<span class="sd">        :param tuple(int, int) size: A tuple of (width, height) specifying a target</span>
<span class="sd">            drawing size in abstract user units (usually interpreted as pixels on</span>
<span class="sd">            initial display). Components of the drawing will be scaled so that the total</span>
<span class="sd">            plot including labels etc. normally fits onto a canvas of this size (see</span>
<span class="sd">            ``canvas_size`` below). If ``None``, pick a size appropriate for a tree</span>
<span class="sd">            with a reasonably small number (i.e. tens) of samples. Default: ``None``</span>
<span class="sd">        :type size:</span>
<span class="sd">        :param str time_scale: Control how height values for nodes are computed.</span>
<span class="sd">            If this is equal to ``&quot;time&quot;`` (the default), node heights are proportional</span>
<span class="sd">            to their time values. If this is equal to ``&quot;log_time&quot;``, node heights are</span>
<span class="sd">            proportional to their log(time) values. If it is equal to ``&quot;rank&quot;``, node</span>
<span class="sd">            heights are spaced equally according to their ranked times.</span>
<span class="sd">        :param str tree_height_scale: Deprecated alias for time_scale. (Deprecated in</span>
<span class="sd">                0.3.6)</span>
<span class="sd">        :param str title: A title string to be included in the SVG output. If ``None``</span>
<span class="sd">            (default) no title is shown, which gives more vertical space for the tree.</span>
<span class="sd">        :param str,float max_time: The maximum plotted time value in the current</span>
<span class="sd">            scaling system (see ``time_scale``). Can be either a string or a</span>
<span class="sd">            numeric value. If equal to ``&quot;tree&quot;`` (the default), the maximum time</span>
<span class="sd">            is set to be that of the oldest root in the tree. If equal to ``&quot;ts&quot;`` the</span>
<span class="sd">            maximum time is set to be the time of the oldest root in the tree</span>
<span class="sd">            sequence; this is useful when drawing trees from the same tree sequence as it</span>
<span class="sd">            ensures that node heights are consistent. If a numeric value, this is used as</span>
<span class="sd">            the maximum plotted time by which to scale other nodes.</span>
<span class="sd">        :param str,float min_time: The minimum plotted time value in the current</span>
<span class="sd">            scaling system (see ``time_scale``). Can be either a string or a</span>
<span class="sd">            numeric value. If equal to ``&quot;tree&quot;`` (the default), the minimum time</span>
<span class="sd">            is set to be that of the youngest node in the tree. If equal to ``&quot;ts&quot;`` the</span>
<span class="sd">            minimum time is set to be the time of the youngest node in the tree</span>
<span class="sd">            sequence; this is useful when drawing trees from the same tree sequence as it</span>
<span class="sd">            ensures that node heights are consistent. If a numeric value, this is used as</span>
<span class="sd">            the minimum plotted time.</span>
<span class="sd">        :param str,float max_tree_height: Deprecated alias for max_time. (Deprecated in</span>
<span class="sd">            0.3.6)</span>
<span class="sd">        :param node_labels: If specified, show custom labels for the nodes</span>
<span class="sd">            (specified by ID) that are present in this map; any nodes not present will</span>
<span class="sd">            not have a label. To use a metadata key, for example, use</span>
<span class="sd">            ``node_labels={node.id: node.metadata[&quot;key&quot;] for node in ts.nodes()}``.</span>
<span class="sd">        :type node_labels: dict(int, str)</span>
<span class="sd">        :param mutation_labels: If specified, show custom labels for the</span>
<span class="sd">            mutations (specified by ID) that are present in the map; any mutations</span>
<span class="sd">            not present will not have a label.</span>
<span class="sd">        :type mutation_labels: dict(int, str)</span>
<span class="sd">        :param dict(int, str) node_titles: If specified, add a ``&lt;title&gt;`` string to</span>
<span class="sd">            symbols for each node (specified by ID) present in this map. SVG visualizers</span>
<span class="sd">            such as web browsers will commonly display this string on mousing over the</span>
<span class="sd">            node symbol.</span>
<span class="sd">        :param dict(int, str) mutation_titles: If specified, add a ``&lt;title&gt;`` string to</span>
<span class="sd">            symbols for each mutation (specified by ID) present in this map. SVG</span>
<span class="sd">            visualizers such as web browsers will commonly display this string on</span>
<span class="sd">            mousing over the mutation symbol in the tree and (if show) on the x axis.</span>
<span class="sd">        :param dict root_svg_attributes: Additional attributes, such as an id, that will</span>
<span class="sd">            be embedded in the root ``&lt;svg&gt;`` tag of the generated drawing.</span>
<span class="sd">        :param str style: A</span>
<span class="sd">            `css style string &lt;https://www.w3.org/TR/CSS22/syndata.html&gt;`_ that will be</span>
<span class="sd">            included in the ``&lt;style&gt;`` tag of the generated svg.</span>
<span class="sd">        :param str order: The left-to-right ordering of child nodes in the drawn tree.</span>
<span class="sd">            This can be either: ``&quot;minlex&quot;``, which minimises the differences</span>
<span class="sd">            between adjacent trees (see also the ``&quot;minlex_postorder&quot;`` traversal</span>
<span class="sd">            order for the :meth:`.nodes` method); or ``&quot;tree&quot;`` which draws trees</span>
<span class="sd">            in the left-to-right order defined by the</span>
<span class="sd">            :ref:`quintuply linked tree structure &lt;sec_data_model_tree_structure&gt;`.</span>
<span class="sd">            If not specified or None, this defaults to ``&quot;minlex&quot;``.</span>
<span class="sd">        :param bool force_root_branch: If ``True`` always plot a branch (edge) above the</span>
<span class="sd">            root(s) in the tree. If ``None`` (default) then only plot such root branches</span>
<span class="sd">            if there is a mutation above a root of the tree.</span>
<span class="sd">        :param float symbol_size: Change the default size of the node and mutation</span>
<span class="sd">            plotting symbols. If ``None`` (default) use a standard size.</span>
<span class="sd">        :param bool x_axis: Should the plot have an X axis line, showing the start and</span>
<span class="sd">            end position of this tree along the genome. If ``None`` (default) do not</span>
<span class="sd">            plot an X axis.</span>
<span class="sd">        :param str x_label: Place a label under the plot. If ``None`` (default) and</span>
<span class="sd">            there is an X axis, create and place an appropriate label.</span>
<span class="sd">        :param dict x_regions: A dictionary mapping (left, right) tuples to names. This</span>
<span class="sd">            draws a box, labelled with the name, on the X axis between the left and</span>
<span class="sd">            right positions, and can be used for annotating genomic regions (e.g.</span>
<span class="sd">            genes) on the X axis. If ``None`` (default) do not plot any regions.</span>
<span class="sd">        :param bool y_axis: Should the plot have an Y axis line, showing time (or</span>
<span class="sd">            ranked node time if ``time_scale=&quot;rank&quot;``). If ``None`` (default)</span>
<span class="sd">            do not plot a Y axis.</span>
<span class="sd">        :param str y_label: Place a label to the left of the plot. If ``None`` (default)</span>
<span class="sd">            and there is a Y axis,  create and place an appropriate label.</span>
<span class="sd">        :param Union[list, dict] y_ticks: A list of Y values at which to plot</span>
<span class="sd">            tickmarks, or a dictionary mapping Y values to labels (``[]`` gives no</span>
<span class="sd">            tickmarks). If ``None`` (default), plot one tickmark for each unique node</span>
<span class="sd">            value. Note that if ``time_scale=&quot;rank&quot;``, the Y values refer to the</span>
<span class="sd">            zero-based rank of the plotted nodes, rather than the node time itself.</span>
<span class="sd">        :param bool y_gridlines: Whether to plot horizontal lines behind the tree</span>
<span class="sd">            at each y tickmark.</span>
<span class="sd">        :param bool all_edge_mutations: The edge on which a mutation occurs may span</span>
<span class="sd">            multiple trees. If ``False`` or ``None`` (default) mutations are only drawn</span>
<span class="sd">            on an edge if their site position exists within the genomic interval covered</span>
<span class="sd">            by this tree. If ``True``, all mutations on each edge of the tree are drawn,</span>
<span class="sd">            even if their genomic position is to the left or right of the tree</span>
<span class="sd">            itself. Note that this means that independent drawings of different trees</span>
<span class="sd">            from the same tree sequence may share some plotted mutations.</span>
<span class="sd">        :param bool omit_sites: If True, omit sites and mutations from the drawing.</span>
<span class="sd">            Default: False</span>
<span class="sd">        :param tuple(int, int) canvas_size: The (width, height) of the SVG canvas.</span>
<span class="sd">            This will change the SVG width and height without rescaling graphical</span>
<span class="sd">            elements, allowing extra room e.g. for unusually long labels. If ``None``</span>
<span class="sd">            take the canvas size to be the same as the target drawing size (see</span>
<span class="sd">            ``size``, above). Default: None</span>
<span class="sd">        :param str preamble: SVG commands to be included at the start of the returned</span>
<span class="sd">            object, immediately after the opening tag. These can include custom svg</span>
<span class="sd">            elements such as legends or annotations or even entire ``&lt;svg&gt;`` elements.</span>
<span class="sd">            The preamble is not checked for validity, so it is up to the user to</span>
<span class="sd">            ensure that it is valid SVG. Default: None</span>

<span class="sd">        :return: An SVG representation of a tree.</span>
<span class="sd">        :rtype: SVGString</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">svgtree</span> <span class="o">=</span> <span class="n">drawing</span><span class="o">.</span><span class="n">SvgTree</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">size</span><span class="p">,</span>
            <span class="n">time_scale</span><span class="o">=</span><span class="n">time_scale</span><span class="p">,</span>
            <span class="n">tree_height_scale</span><span class="o">=</span><span class="n">tree_height_scale</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
            <span class="n">max_time</span><span class="o">=</span><span class="n">max_time</span><span class="p">,</span>
            <span class="n">min_time</span><span class="o">=</span><span class="n">min_time</span><span class="p">,</span>
            <span class="n">max_tree_height</span><span class="o">=</span><span class="n">max_tree_height</span><span class="p">,</span>
            <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span>
            <span class="n">mutation_labels</span><span class="o">=</span><span class="n">mutation_labels</span><span class="p">,</span>
            <span class="n">node_titles</span><span class="o">=</span><span class="n">node_titles</span><span class="p">,</span>
            <span class="n">mutation_titles</span><span class="o">=</span><span class="n">mutation_titles</span><span class="p">,</span>
            <span class="n">root_svg_attributes</span><span class="o">=</span><span class="n">root_svg_attributes</span><span class="p">,</span>
            <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>  <span class="c1"># NB undocumented: Tree.draw_svg can also take an iterable here</span>
            <span class="n">force_root_branch</span><span class="o">=</span><span class="n">force_root_branch</span><span class="p">,</span>
            <span class="n">symbol_size</span><span class="o">=</span><span class="n">symbol_size</span><span class="p">,</span>
            <span class="n">x_axis</span><span class="o">=</span><span class="n">x_axis</span><span class="p">,</span>
            <span class="n">x_label</span><span class="o">=</span><span class="n">x_label</span><span class="p">,</span>
            <span class="n">x_regions</span><span class="o">=</span><span class="n">x_regions</span><span class="p">,</span>
            <span class="n">y_axis</span><span class="o">=</span><span class="n">y_axis</span><span class="p">,</span>
            <span class="n">y_label</span><span class="o">=</span><span class="n">y_label</span><span class="p">,</span>
            <span class="n">y_ticks</span><span class="o">=</span><span class="n">y_ticks</span><span class="p">,</span>
            <span class="n">y_gridlines</span><span class="o">=</span><span class="n">y_gridlines</span><span class="p">,</span>
            <span class="n">all_edge_mutations</span><span class="o">=</span><span class="n">all_edge_mutations</span><span class="p">,</span>
            <span class="n">omit_sites</span><span class="o">=</span><span class="n">omit_sites</span><span class="p">,</span>
            <span class="n">canvas_size</span><span class="o">=</span><span class="n">canvas_size</span><span class="p">,</span>
            <span class="n">preamble</span><span class="o">=</span><span class="n">preamble</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">svgtree</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.draw">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.draw">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_colours</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mutation_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mutation_colours</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># noqa A002</span>
        <span class="n">edge_colours</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tree_height_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">min_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_tree_height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">omit_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a drawing of this tree.</span>

<span class="sd">        When working in a Jupyter notebook, use the ``IPython.display.SVG``</span>
<span class="sd">        function to display the SVG output from this function inline in the notebook::</span>

<span class="sd">            SVG(tree.draw())</span>

<span class="sd">        The unicode format uses unicode `box drawing characters</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Box-drawing_character&gt;`_ to render the tree.</span>
<span class="sd">        This allows rendered trees to be printed out to the terminal::</span>

<span class="sd">            print(tree.draw(format=&quot;unicode&quot;))</span>
<span class="sd">              6</span>
<span class="sd">            </span>
<span class="sd">               5</span>
<span class="sd">             </span>
<span class="sd">               4</span>
<span class="sd">              </span>
<span class="sd">            3 0 1 2</span>

<span class="sd">        The ``node_labels`` argument allows the user to specify custom labels</span>
<span class="sd">        for nodes, or no labels at all::</span>

<span class="sd">            print(tree.draw(format=&quot;unicode&quot;, node_labels={}))</span>
<span class="sd">              </span>
<span class="sd">            </span>
<span class="sd">               </span>
<span class="sd">             </span>
<span class="sd">               </span>
<span class="sd">              </span>
<span class="sd">               </span>

<span class="sd">        Note: in some environments such as Jupyter notebooks with Windows or Mac,</span>
<span class="sd">        users have observed that the Unicode box drawings can be misaligned. In</span>
<span class="sd">        these cases, we recommend using the SVG or ASCII display formats instead.</span>
<span class="sd">        If you have a strong preference for aligned Unicode, you can try out the</span>
<span class="sd">        solution documented</span>
<span class="sd">        `here &lt;https://github.com/tskit-dev/tskit/issues/189#issuecomment-499114811&gt;`_.</span>

<span class="sd">        :param str path: The path to the file to write the output. If None, do not</span>
<span class="sd">            write to file.</span>
<span class="sd">        :param int width: The width of the image in pixels. If not specified, either</span>
<span class="sd">            defaults to the minimum size required to depict the tree (text formats)</span>
<span class="sd">            or 200 pixels.</span>
<span class="sd">        :param int height: The height of the image in pixels. If not specified, either</span>
<span class="sd">            defaults to the minimum size required to depict the tree (text formats)</span>
<span class="sd">            or 200 pixels.</span>
<span class="sd">        :param dict node_labels: If specified, show custom labels for the nodes</span>
<span class="sd">            that are present in the map. Any nodes not specified in the map will</span>
<span class="sd">            not have a node label.</span>
<span class="sd">        :param dict node_colours: If specified, show custom colours for the nodes</span>
<span class="sd">            given in the map. Any nodes not specified in the map will take the default</span>
<span class="sd">            colour; a value of ``None`` is treated as transparent and hence the node</span>
<span class="sd">            symbol is not plotted. (Only supported in the SVG format.)</span>
<span class="sd">        :param dict mutation_labels: If specified, show custom labels for the mutations</span>
<span class="sd">            (specified by ID) that are present in the map. Any mutations not in the map</span>
<span class="sd">            will not have a label. (Showing mutations is currently only supported in the</span>
<span class="sd">            SVG format)</span>
<span class="sd">        :param dict mutation_colours: If specified, show custom colours for the mutations</span>
<span class="sd">            given in the map (specified by ID). As for ``node_colours``, mutations not</span>
<span class="sd">            present in the map take the default colour, and those mapping to ``None``</span>
<span class="sd">            are not drawn. (Only supported in the SVG format.)</span>
<span class="sd">        :param str format: The format of the returned image. Currently supported</span>
<span class="sd">            are &#39;svg&#39;, &#39;ascii&#39; and &#39;unicode&#39;. Note that the :meth:`Tree.draw_svg`</span>
<span class="sd">            method provides more comprehensive functionality for creating SVGs.</span>
<span class="sd">        :param dict edge_colours: If specified, show custom colours for the edge</span>
<span class="sd">            joining each node in the map to its parent. As for ``node_colours``,</span>
<span class="sd">            unspecified edges take the default colour, and ``None`` values result in the</span>
<span class="sd">            edge being omitted. (Only supported in the SVG format.)</span>
<span class="sd">        :param str time_scale: Control how height values for nodes are computed.</span>
<span class="sd">            If this is equal to ``&quot;time&quot;``, node heights are proportional to their time</span>
<span class="sd">            values. If this is equal to ``&quot;log_time&quot;``, node heights are proportional to</span>
<span class="sd">            their log(time) values. If it is equal to ``&quot;rank&quot;``, node heights are spaced</span>
<span class="sd">            equally according to their ranked times. For SVG output the default is</span>
<span class="sd">            &#39;time&#39;-scale whereas for text output the default is &#39;rank&#39;-scale.</span>
<span class="sd">            Time scaling is not currently supported for text output.</span>
<span class="sd">        :param str tree_height_scale: Deprecated alias for time_scale. (Deprecated in</span>
<span class="sd">                0.3.6)</span>
<span class="sd">        :param str,float max_time: The maximum time value in the current</span>
<span class="sd">            scaling system (see ``time_scale``). Can be either a string or a</span>
<span class="sd">            numeric value. If equal to ``&quot;tree&quot;``, the maximum time is set to be</span>
<span class="sd">            that of the oldest root in the tree. If equal to ``&quot;ts&quot;`` the maximum</span>
<span class="sd">            time is set to be the time of the oldest root in the tree sequence;</span>
<span class="sd">            this is useful when drawing trees from the same tree sequence as it ensures</span>
<span class="sd">            that node heights are consistent. If a numeric value, this is used as the</span>
<span class="sd">            maximum time by which to scale other nodes. This parameter</span>
<span class="sd">            is not currently supported for text output.</span>
<span class="sd">        :param str,float min_time: The minimum time value in the current</span>
<span class="sd">            scaling system (see ``time_scale``). Can be either a string or a</span>
<span class="sd">            numeric value. If equal to ``&quot;tree&quot;``, the minimum time is set to be</span>
<span class="sd">            that of the youngest node in the tree. If equal to ``&quot;ts&quot;`` the minimum</span>
<span class="sd">            time is set to be the time of the youngest node in the tree sequence;</span>
<span class="sd">            this is useful when drawing trees from the same tree sequence as it ensures</span>
<span class="sd">            that node heights are consistent. If a numeric value, this is used as the</span>
<span class="sd">            minimum time to display. This parameter is not currently supported for text</span>
<span class="sd">            output.</span>
<span class="sd">        :param str max_tree_height: Deprecated alias for max_time. (Deprecated in</span>
<span class="sd">                0.3.6)</span>
<span class="sd">        :param str order: The left-to-right ordering of child nodes in the drawn tree.</span>
<span class="sd">            This can be either: ``&quot;minlex&quot;``, which minimises the differences</span>
<span class="sd">            between adjacent trees (see also the ``&quot;minlex_postorder&quot;`` traversal</span>
<span class="sd">            order for the :meth:`.nodes` method); or ``&quot;tree&quot;`` which draws trees</span>
<span class="sd">            in the left-to-right order defined by the</span>
<span class="sd">            :ref:`quintuply linked tree structure &lt;sec_data_model_tree_structure&gt;`.</span>
<span class="sd">            If not specified or None, this defaults to ``&quot;minlex&quot;``.</span>
<span class="sd">        :param bool omit_sites: If True, omit sites and mutations from the drawing</span>
<span class="sd">            (only relevant to the SVG format). Default: False</span>
<span class="sd">        :return: A representation of this tree in the requested format.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">drawing</span><span class="o">.</span><span class="n">draw_tree</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
            <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span>
            <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span>
            <span class="n">node_colours</span><span class="o">=</span><span class="n">node_colours</span><span class="p">,</span>
            <span class="n">mutation_labels</span><span class="o">=</span><span class="n">mutation_labels</span><span class="p">,</span>
            <span class="n">mutation_colours</span><span class="o">=</span><span class="n">mutation_colours</span><span class="p">,</span>
            <span class="n">edge_colours</span><span class="o">=</span><span class="n">edge_colours</span><span class="p">,</span>
            <span class="n">time_scale</span><span class="o">=</span><span class="n">time_scale</span><span class="p">,</span>
            <span class="n">tree_height_scale</span><span class="o">=</span><span class="n">tree_height_scale</span><span class="p">,</span>
            <span class="n">max_time</span><span class="o">=</span><span class="n">max_time</span><span class="p">,</span>
            <span class="n">min_time</span><span class="o">=</span><span class="n">min_time</span><span class="p">,</span>
            <span class="n">max_tree_height</span><span class="o">=</span><span class="n">max_tree_height</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">omit_sites</span><span class="o">=</span><span class="n">omit_sites</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_mutations</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total number of mutations across all sites on this tree.</span>

<span class="sd">        :return: The total number of mutations over all sites on this tree.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">mutations</span><span class="p">)</span> <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of sites on this tree.</span>

<span class="sd">        :return: The number of sites on this tree.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_sites</span><span class="p">()</span>

<div class="viewcode-block" id="Tree.sites">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.sites">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all the :ref:`sites &lt;sec_site_table_definition&gt;`</span>
<span class="sd">        in this tree. Sites are returned in order of increasing ID</span>
<span class="sd">        (and also position). See the :class:`Site` class for details on</span>
<span class="sd">        the available fields for each site.</span>

<span class="sd">        :return: An iterator over all sites in this tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO change the low-level API to just return the IDs of the sites.</span>
        <span class="k">for</span> <span class="n">ll_site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_sites</span><span class="p">():</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">id_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">ll_site</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">site</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.mutations">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.mutations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all the</span>
<span class="sd">        :ref:`mutations &lt;sec_mutation_table_definition&gt;` in this tree.</span>
<span class="sd">        Mutations are returned in their</span>
<span class="sd">        :ref:`order in the mutations table&lt;sec_mutation_requirements&gt;`,</span>
<span class="sd">        that is, by nondecreasing site ID, and within a site, by decreasing</span>
<span class="sd">        mutation time with parent mutations before their children.</span>
<span class="sd">        See the :class:`Mutation` class for details on the available fields for</span>
<span class="sd">        each mutation.</span>

<span class="sd">        The returned iterator is equivalent to iterating over all sites</span>
<span class="sd">        and all mutations in each site, i.e.::</span>

<span class="sd">            for site in tree.sites():</span>
<span class="sd">                for mutation in site.mutations:</span>
<span class="sd">                    yield mutation</span>

<span class="sd">        :return: An iterator over all :class:`Mutation` objects in this tree.</span>
<span class="sd">        :rtype: iter(:class:`Mutation`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">():</span>
            <span class="k">yield from</span> <span class="n">site</span><span class="o">.</span><span class="n">mutations</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for samples. See the discussion in the get_num_leaves</span>
        <span class="c1"># method for why this method is here and why it is semantically incorrect.</span>
        <span class="c1"># The &#39;leaves&#39; iterator below correctly returns the leaves below a given</span>
        <span class="c1"># node.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.leaves">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.leaves">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all the leaves in this tree that descend from</span>
<span class="sd">        the specified node. If :math:`u`  is not specified, return all leaves on</span>
<span class="sd">        the tree (i.e. all leaves reachable from the tree root(s), see note below).</span>

<span class="sd">        .. note::</span>
<span class="sd">            :math:`u` can be any node in the entire tree sequence, including ones</span>
<span class="sd">            which are not connected via branches to a root node of the tree. If</span>
<span class="sd">            called on such a node, the iterator will return &quot;dead&quot; leaves</span>
<span class="sd">            (see :ref:`sec_data_model_tree_dead_leaves_and_branches`) which cannot</span>
<span class="sd">            be reached from a root of this tree. However, dead leaves will never be</span>
<span class="sd">            returned if :math:`u` is left unspecified.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: An iterator over all leaves in the subtree rooted at u.</span>
<span class="sd">        :rtype: collections.abc.Iterable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roots</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">v</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_sample_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_options</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">SAMPLE_LISTS</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">left_sample</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">:</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right_sample</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">samples</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_sample</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fall back on iterating over all nodes in the tree, yielding</span>
            <span class="c1"># samples as we see them.</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sample</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">v</span>

<div class="viewcode-block" id="Tree.samples">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.samples">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the numerical IDs of all the sample nodes in</span>
<span class="sd">        this tree that are underneath the node with ID ``u``. If ``u`` is a sample,</span>
<span class="sd">        it is included in the returned iterator. If ``u`` is not a sample, it is</span>
<span class="sd">        possible for the returned iterator to be empty, for example if ``u`` is an</span>
<span class="sd">        :meth:`isolated&lt;Tree.is_isolated&gt;` node that is not part of the the current</span>
<span class="sd">        topology. If u is not specified, return all sample node IDs in the tree</span>
<span class="sd">        (equivalent to all the sample node IDs in the tree sequence).</span>

<span class="sd">        If the :meth:`TreeSequence.trees` method is called with</span>
<span class="sd">        ``sample_lists=True``, this method uses an efficient algorithm to find</span>
<span class="sd">        the sample nodes. If not, a simple traversal based method is used.</span>

<span class="sd">        .. note::</span>

<span class="sd">            The iterator is *not* guaranteed to return the sample node IDs in</span>
<span class="sd">            numerical or any other particular order.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: An iterator over all sample node IDs in the subtree rooted at u.</span>
<span class="sd">        :rtype: collections.abc.Iterable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="p">[</span><span class="n">u</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roots</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample_generator</span><span class="p">(</span><span class="n">root</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.num_children">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.num_children">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of children of the specified</span>
<span class="sd">        node (i.e., ``len(tree.children(u))``)</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The number of immediate children of the node u in this tree.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_children</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for num_samples. The method name is inaccurate</span>
        <span class="c1"># as this will count the number of tracked _samples_. This is only provided to</span>
        <span class="c1"># avoid breaking existing code and should not be used in new code. We could</span>
        <span class="c1"># change this method to be semantically correct and just count the</span>
        <span class="c1"># number of leaves we hit in the leaves() iterator. However, this would</span>
        <span class="c1"># have the undesirable effect of making code that depends on the constant</span>
        <span class="c1"># time performance of get_num_leaves many times slower. So, the best option</span>
        <span class="c1"># is to leave this method as is, and to slowly deprecate it out. Once this</span>
        <span class="c1"># has been removed, we might add in a ``num_leaves`` method that returns the</span>
        <span class="c1"># length of the leaves() iterator as one would expect.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for num_samples.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.num_samples">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.num_samples">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of sample nodes in this tree underneath the specified</span>
<span class="sd">        node (including the node itself). If u is not specified return</span>
<span class="sd">        the total number of samples in the tree.</span>

<span class="sd">        This is a constant time operation.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The number of samples in the subtree rooted at u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_root</span> <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">u</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_tracked_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for num_tracked_samples. The method name is inaccurate</span>
        <span class="c1"># as this will count the number of tracked _samples_. This is only provided to</span>
        <span class="c1"># avoid breaking existing code and should not be used in new code.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_tracked_samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_tracked_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for num_tracked_samples</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_tracked_samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.num_tracked_samples">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.num_tracked_samples">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_tracked_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of samples in the set specified in the</span>
<span class="sd">        ``tracked_samples`` parameter of the :meth:`TreeSequence.trees` method</span>
<span class="sd">        underneath the specified node. If the input node is not specified,</span>
<span class="sd">        return the total number of tracked samples in the tree.</span>

<span class="sd">        This is a constant time operation.</span>

<span class="sd">        :param int u: The node of interest.</span>
<span class="sd">        :return: The number of samples within the set of tracked samples in</span>
<span class="sd">            the subtree rooted at u.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_root</span> <span class="k">if</span> <span class="n">u</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">u</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_tracked_samples</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.preorder">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.preorder">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">preorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">NULL</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a numpy array of node ids in `preorder</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)&gt;`_. If the node u</span>
<span class="sd">        is specified the traversal is rooted at this node (and it will be the first</span>
<span class="sd">        element in the returned array). Otherwise, all nodes reachable from the tree</span>
<span class="sd">        roots will be returned. See :ref:`tutorials:sec_analysing_trees_traversals` for</span>
<span class="sd">        examples.</span>

<span class="sd">        :param int u: If specified, return all nodes in the subtree rooted at u</span>
<span class="sd">            (including u) in traversal order.</span>
<span class="sd">        :return: Array of node ids</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_preorder</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.postorder">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.postorder">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">postorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">NULL</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a numpy array of node ids in `postorder</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Tree_traversal##Post-order_(LRN)&gt;`_. If the node u</span>
<span class="sd">        is specified the traversal is rooted at this node (and it will be the last</span>
<span class="sd">        element in the returned array). Otherwise, all nodes reachable from the tree</span>
<span class="sd">        roots will be returned. See :ref:`tutorials:sec_analysing_trees_traversals` for</span>
<span class="sd">        examples.</span>

<span class="sd">        :param int u: If specified, return all nodes in the subtree rooted at u</span>
<span class="sd">            (including u) in traversal order.</span>
<span class="sd">        :return: Array of node ids</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_postorder</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.timeasc">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.timeasc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">timeasc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">NULL</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a numpy array of node ids. Starting at `u`, returns the reachable</span>
<span class="sd">        descendant nodes in order of increasing time (most recent first), falling back</span>
<span class="sd">        to increasing ID if times are equal. Also see</span>
<span class="sd">        :ref:`tutorials:sec_analysing_trees_traversals` for examples of how to use</span>
<span class="sd">        traversals.</span>

<span class="sd">        :param int u: If specified, return all nodes in the subtree rooted at u</span>
<span class="sd">            (including u) in traversal order.</span>
<span class="sd">        :return: Array of node ids</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">is_virtual_root</span> <span class="o">=</span> <span class="n">u</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_root</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">nodes_time</span>
        <span class="k">if</span> <span class="n">is_virtual_root</span><span class="p">:</span>
            <span class="c1"># We could avoid creating this array if we wanted to, but</span>
            <span class="c1"># it&#39;s not that often people will be using this with the</span>
            <span class="c1"># virtual_root as an argument, so doesn&#39;t seem worth</span>
            <span class="c1"># the complexity</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">([</span><span class="n">nodes</span><span class="p">,</span> <span class="n">time</span><span class="p">[</span><span class="n">nodes</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">nodes</span><span class="p">[</span><span class="n">order</span><span class="p">]</span></div>


<div class="viewcode-block" id="Tree.timedesc">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.timedesc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">timedesc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">NULL</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a numpy array of node ids. Starting at `u`, returns the reachable</span>
<span class="sd">        descendant nodes in order of decreasing time (least recent first), falling back</span>
<span class="sd">        to decreasing ID if times are equal. Also see</span>
<span class="sd">        :ref:`tutorials:sec_analysing_trees_traversals` for examples of how to use</span>
<span class="sd">        traversals.</span>

<span class="sd">        :param int u: If specified, return all nodes in the subtree rooted at u</span>
<span class="sd">            (including u) in traversal order.</span>
<span class="sd">        :return: Array of node ids</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeasc</span><span class="p">(</span><span class="n">u</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_preorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="c1"># Return Python integers for compatibility</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_postorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="c1"># Return Python integers for compatibility</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">postorder</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_inorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="c1"># TODO add a nonrecursive version of the inorder traversal.</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">traverse</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
            <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">[:</span><span class="n">mid</span><span class="p">]:</span>
                <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">u</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">[</span><span class="n">mid</span><span class="p">:]:</span>
                <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

        <span class="n">roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roots</span> <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="n">NULL</span> <span class="k">else</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">roots</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">traverse</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_levelorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
        <span class="n">roots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">roots</span> <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="n">NULL</span> <span class="k">else</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="c1"># For perf we store these to avoid lookups in the tight loop</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span>
        <span class="n">extend</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">extend</span>
        <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
        <span class="c1"># Note: the usual style is to be explicit about what we&#39;re testing</span>
        <span class="c1"># and use while len(queue) &gt; 0, but this form is slightly faster.</span>
        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">pop</span><span class="p">()</span>
            <span class="n">extend</span><span class="p">(</span><span class="n">children</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
            <span class="k">yield</span> <span class="n">v</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_timeasc_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sorts by increasing time but falls back to increasing ID for equal times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeasc</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_timedesc_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The reverse of timeasc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timedesc</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_minlex_postorder_traversal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Postorder traversal that visits leaves in minimum lexicographic order.</span>

<span class="sd">        Minlex stands for minimum lexicographic. We wish to visit a tree in such</span>
<span class="sd">        a way that the leaves visited, when their IDs are listed out, have</span>
<span class="sd">        minimum lexicographic order. This is a useful ordering for drawing</span>
<span class="sd">        multiple Trees of a TreeSequence, as it leads to more consistency</span>
<span class="sd">        between adjacent Trees.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We compute a dictionary mapping from internal node ID to min leaf ID</span>
        <span class="c1"># under the node, using a first postorder traversal</span>
        <span class="n">min_leaf</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;postorder&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_leaf</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="n">min_leaf</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_leaf</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_leaf</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

        <span class="c1"># If we deliberately specify the virtual root, it should also be returned</span>
        <span class="n">is_virtual_root</span> <span class="o">=</span> <span class="n">root</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_root</span>
        <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_root</span>

        <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">root</span><span class="p">,</span> <span class="kc">False</span><span class="p">)]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_root</span> <span class="ow">or</span> <span class="n">is_virtual_root</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">u</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>  <span class="c1"># Reappend, marking visited</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="nb">sorted</span><span class="p">(</span>
                        <span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">u</span><span class="p">)),</span>
                        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">min_leaf</span><span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>

<div class="viewcode-block" id="Tree.nodes">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;preorder&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the node IDs reachable from the specified node in this</span>
<span class="sd">        tree in the specified traversal order.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Unlike the :meth:`TreeSequence.nodes` method, this iterator produces</span>
<span class="sd">            integer node IDs, not :class:`Node` objects.</span>

<span class="sd">        If the ``root`` parameter is not provided or ``None``, iterate over all</span>
<span class="sd">        nodes reachable from the roots (see :attr:`Tree.roots` for details</span>
<span class="sd">        on which nodes are considered roots). If the ``root`` parameter</span>
<span class="sd">        is provided, only the nodes in the subtree rooted at this node</span>
<span class="sd">        (including the specified node) will be iterated over. If the</span>
<span class="sd">        :attr:`.virtual_root` is specified as the traversal root, it will</span>
<span class="sd">        be included in the traversed nodes in the appropriate position</span>
<span class="sd">        for the given ordering. (See the</span>
<span class="sd">        :ref:`tree roots &lt;sec_data_model_tree_virtual_root&gt;` section for more</span>
<span class="sd">        information on the virtual root.)</span>

<span class="sd">        The ``order`` parameter defines the order in which tree nodes are visited</span>
<span class="sd">        in the iteration (also see the :ref:`sec_analysing_trees_traversals` section</span>
<span class="sd">        in the `tutorials &lt;https://tskit.dev/tutorials&gt;`__). The available orders are:</span>

<span class="sd">        - &#39;preorder&#39;: starting at root, yield the current node, then recurse</span>
<span class="sd">          and do a preorder on each child of the current node. See also `Wikipedia</span>
<span class="sd">          &lt;https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)&gt;`__.</span>
<span class="sd">        - &#39;inorder&#39;: starting at root, assuming binary trees, recurse and do</span>
<span class="sd">          an inorder on the first child, then yield the current node, then</span>
<span class="sd">          recurse and do an inorder on the second child. In the case of ``n``</span>
<span class="sd">          child nodes (not necessarily 2), the first ``n // 2`` children are</span>
<span class="sd">          visited in the first stage, and the remaining ``n - n // 2`` children</span>
<span class="sd">          are visited in the second stage. See also `Wikipedia</span>
<span class="sd">          &lt;https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)&gt;`__.</span>
<span class="sd">        - &#39;postorder&#39;: starting at root, recurse and do a postorder on each</span>
<span class="sd">          child of the current node, then yield the current node. See also</span>
<span class="sd">          `Wikipedia</span>
<span class="sd">          &lt;https://en.wikipedia.org/wiki/Tree_traversal#Post-order_(LRN)&gt;`__.</span>
<span class="sd">        - &#39;levelorder&#39; (&#39;breadthfirst&#39;): visit the nodes under root (including</span>
<span class="sd">          the root) in increasing order of their depth from root. See also</span>
<span class="sd">          `Wikipedia</span>
<span class="sd">          &lt;https://en.wikipedia.org/wiki/Tree_traversal\</span>
<span class="sd">#Breadth-first_search_/_level_order&gt;`__.</span>
<span class="sd">        - &#39;timeasc&#39;: visits the nodes in order of increasing time, falling back to</span>
<span class="sd">          increasing ID if times are equal.</span>
<span class="sd">        - &#39;timedesc&#39;: visits the nodes in order of decreasing time, falling back to</span>
<span class="sd">          decreasing ID if times are equal.</span>
<span class="sd">        - &#39;minlex_postorder&#39;: a usual postorder has ambiguity in the order in</span>
<span class="sd">          which children of a node are visited. We constrain this by outputting</span>
<span class="sd">          a postorder such that the leaves visited, when their IDs are</span>
<span class="sd">          listed out, have minimum `lexicographic order</span>
<span class="sd">          &lt;https://en.wikipedia.org/wiki/Lexicographical_order&gt;`__ out of all valid</span>
<span class="sd">          traversals. This traversal is useful for drawing multiple trees of</span>
<span class="sd">          a ``TreeSequence``, as it leads to more consistency between adjacent</span>
<span class="sd">          trees. Note that internal non-leaf nodes are not counted in</span>
<span class="sd">          assessing the lexicographic order.</span>

<span class="sd">        :param int root: The root of the subtree we are traversing.</span>
<span class="sd">        :param str order: The traversal ordering. Currently &#39;preorder&#39;,</span>
<span class="sd">            &#39;inorder&#39;, &#39;postorder&#39;, &#39;levelorder&#39; (&#39;breadthfirst&#39;), &#39;timeasc&#39; and</span>
<span class="sd">            &#39;timedesc&#39; and &#39;minlex_postorder&#39; are supported.</span>
<span class="sd">        :return: An iterator over the node IDs in the tree in some traversal order.</span>
<span class="sd">        :rtype: collections.abc.Iterable, int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">methods</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;preorder&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preorder_traversal</span><span class="p">,</span>
            <span class="s2">&quot;inorder&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inorder_traversal</span><span class="p">,</span>
            <span class="s2">&quot;postorder&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_postorder_traversal</span><span class="p">,</span>
            <span class="s2">&quot;levelorder&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levelorder_traversal</span><span class="p">,</span>
            <span class="s2">&quot;breadthfirst&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levelorder_traversal</span><span class="p">,</span>
            <span class="s2">&quot;timeasc&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timeasc_traversal</span><span class="p">,</span>
            <span class="s2">&quot;timedesc&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_timedesc_traversal</span><span class="p">,</span>
            <span class="s2">&quot;minlex_postorder&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minlex_postorder_traversal</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">iterator</span> <span class="o">=</span> <span class="n">methods</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Traversal ordering &#39;</span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&#39; not supported&quot;</span><span class="p">)</span>

        <span class="n">root</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">root</span>
        <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">root</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_as_newick_fast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">legacy_ms_labels</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call into the fast but limited C implementation of the newick conversion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">root_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
        <span class="n">max_label_size</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">))</span>
        <span class="n">single_node_size</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">5</span> <span class="o">+</span> <span class="n">max_label_size</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">root_time</span><span class="p">))</span> <span class="o">+</span> <span class="n">precision</span>
        <span class="p">)</span>
        <span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">single_node_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_nodes</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_newick</span><span class="p">(</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span>
            <span class="n">buffer_size</span><span class="o">=</span><span class="n">buffer_size</span><span class="p">,</span>
            <span class="n">legacy_ms_labels</span><span class="o">=</span><span class="n">legacy_ms_labels</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Tree.as_newick">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.as_newick">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_newick</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">include_branch_lengths</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a `newick encoding</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Newick_format&gt;`_ of this tree.</span>
<span class="sd">        For example, a binary tree with 3 leaves generated by</span>
<span class="sd">        :meth:`Tree.generate_balanced(3)&lt;Tree.generate_balanced&gt;`</span>
<span class="sd">        encodes as::</span>

<span class="sd">            (n0:2,(n1:1,n2:1):1);</span>

<span class="sd">        By default :ref:`sample nodes&lt;sec_data_model_definitions&gt;` are</span>
<span class="sd">        labelled using the form ``f&quot;n{node_id}&quot;``, i.e. the sample node&#39;s</span>
<span class="sd">        ID prefixed with the string ``&quot;n&quot;``. Node labels can be specified</span>
<span class="sd">        explicitly using the ``node_labels`` argument, which is a mapping from</span>
<span class="sd">        integer node IDs to the corresponding string label. If a node is not</span>
<span class="sd">        present in the mapping, no label is associated with the node in</span>
<span class="sd">        output.</span>

<span class="sd">        .. warning:: Node labels are **not** Newick escaped, so care must be taken</span>
<span class="sd">            to provide labels that will not break the encoding.</span>

<span class="sd">        .. note:: Specifying a ``node_labels`` dictionary or setting</span>
<span class="sd">            ``include_branch_lengths=False`` results in a less efficient</span>
<span class="sd">            method being used to generate the newick output. The performance</span>
<span class="sd">            difference can be substantial for large trees.</span>

<span class="sd">        By default, branch lengths are printed out with sufficient precision</span>
<span class="sd">        for them to be recovered exactly in double precision (although note</span>
<span class="sd">        that this does not necessarily mean that we can precisely recover the</span>
<span class="sd">        corresponding node times, since branch lengths are obtained by</span>
<span class="sd">        subtraction). If all times on the tree sequence are discrete, then</span>
<span class="sd">        branch lengths are printed as integers. Otherwise, branch lengths are</span>
<span class="sd">        printed with 17 digits of precision (i.e., ``&quot;%.17f&quot;`` in</span>
<span class="sd">        printf-notation).</span>

<span class="sd">        The precision for branch lengths can be specified using the ``precision``</span>
<span class="sd">        argument. Branch lengths can be omitted entirely by setting</span>
<span class="sd">        ``include_branch_lengths=False``.</span>

<span class="sd">        If the ``root`` argument is specified, we return the newick encoding of</span>
<span class="sd">        the specified subtree, otherwise the full tree is returned. If the tree</span>
<span class="sd">        has :ref:`multiple roots &lt;sec_data_model_tree_roots&gt;` and a root node</span>
<span class="sd">        is not explicitly specified, we raise a ``ValueError``. This is because</span>
<span class="sd">        most libraries and downstream software consider a newick string that</span>
<span class="sd">        contains multiple disconnected subtrees an error, and it is therefore</span>
<span class="sd">        best to consider how such topologies should be interchanged on a</span>
<span class="sd">        case-by-base basis. A list of the newick strings for each root can be</span>
<span class="sd">        obtained by ``[tree.as_newick(root=root) for root in tree.roots]``.</span>

<span class="sd">        :param int precision: The numerical precision with which branch lengths are</span>
<span class="sd">            printed. If not specified or None default to 0 if the tree sequence</span>
<span class="sd">            contains only integer node times, or 17 otherwise.</span>
<span class="sd">        :param int root: If specified, return the tree rooted at this node.</span>
<span class="sd">        :param dict node_labels: If specified, show custom labels for the nodes</span>
<span class="sd">            that are present in the map. Any nodes not specified in the map will</span>
<span class="sd">            not have a node label.</span>
<span class="sd">        :param include_branch_lengths: If True (default), output branch lengths in the</span>
<span class="sd">            Newick string. If False, only output the topology, without branch lengths.</span>
<span class="sd">        :return: A newick representation of this tree.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_single_root</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot get newick unless a tree has a single root. Try &quot;</span>
                    <span class="s2">&quot;[t.as_newick(root) for root in t.roots] to get a list of &quot;</span>
                    <span class="s2">&quot;newick trees, one for each root.&quot;</span>
                <span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>

        <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># 17 decimal digits provides the full precision of an IEEE double,</span>
            <span class="c1"># as defined by DBL_DECIMAL_DIG macro. If we have discrete time</span>
            <span class="c1"># then write out integer branch lengths.</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">discrete_time</span> <span class="k">else</span> <span class="mi">17</span>
        <span class="n">include_branch_lengths</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">True</span> <span class="k">if</span> <span class="n">include_branch_lengths</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">include_branch_lengths</span>
        <span class="p">)</span>
        <span class="c1"># Can we run this through the fast path?</span>
        <span class="k">if</span> <span class="n">include_branch_lengths</span> <span class="ow">and</span> <span class="n">node_labels</span> <span class="ow">in</span> <span class="p">[</span><span class="n">LEGACY_MS_LABELS</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
            <span class="c1"># Note the LEGACY_MS_LABELS code path is not part of the documented</span>
            <span class="c1"># interface and should not be depended on by client code.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_newick_fast</span><span class="p">(</span>
                <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span>
                <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                <span class="n">legacy_ms_labels</span><span class="o">=</span><span class="n">node_labels</span> <span class="o">==</span> <span class="n">LEGACY_MS_LABELS</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># No, we have to use the slower Python code.</span>
        <span class="k">if</span> <span class="n">node_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">u</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;n</span><span class="si">{</span><span class="n">u</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">samples</span><span class="p">()}</span>
        <span class="k">elif</span> <span class="n">node_labels</span> <span class="o">==</span> <span class="n">LEGACY_MS_LABELS</span><span class="p">:</span>
            <span class="c1"># NOTE in the ms format it&#39;s the *leaf* nodes we label not</span>
            <span class="c1"># necessarily the samples. We keep this behaviour to avoid</span>
            <span class="c1"># breaking legacy code that may depend on it.</span>
            <span class="n">node_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">u</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">u</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaves</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">text_formats</span><span class="o">.</span><span class="n">build_newick</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span>
            <span class="n">include_branch_lengths</span><span class="o">=</span><span class="n">include_branch_lengths</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.newick">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.newick">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">newick</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">include_branch_lengths</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. warning:: This method is deprecated and may be removed in future</span>
<span class="sd">            versions of tskit. Please use the :meth:`.as_newick` method</span>
<span class="sd">            in new code.</span>

<span class="sd">        This method is a deprecated version of the :meth:`.as_newick` method.</span>
<span class="sd">        Functionality is equivalent, except for the default node labels.</span>

<span class="sd">        By default, *leaf* nodes are labelled with their numerical ID + 1,</span>
<span class="sd">        and internal nodes are not labelled. This default strategy was originally</span>
<span class="sd">        used to mimic the output of the ``ms`` simulator. However, the choice</span>
<span class="sd">        of labelling leaf nodes rather than samples is problematic, and this</span>
<span class="sd">        behaviour is only retained to avoid breaking existing code which may</span>
<span class="sd">        rely on it.</span>

<span class="sd">        Other parameters behave as documented in the :meth:`.as_newick` method.</span>

<span class="sd">        :param int precision: The numerical precision with which branch lengths are</span>
<span class="sd">            printed. Defaults to 14.</span>
<span class="sd">        :param int root: If specified, return the tree rooted at this node.</span>
<span class="sd">        :param dict node_labels: If specified, show custom labels for the nodes</span>
<span class="sd">            that are present in the map. Any nodes not specified in the map will</span>
<span class="sd">            not have a node label.</span>
<span class="sd">        :param include_branch_lengths: If True (default), output branch lengths in the</span>
<span class="sd">            Newick string. If False, only output the topology, without branch lengths.</span>
<span class="sd">        :return: A newick representation of this tree.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node_labels</span> <span class="o">=</span> <span class="n">LEGACY_MS_LABELS</span> <span class="k">if</span> <span class="n">node_labels</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">node_labels</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_newick</span><span class="p">(</span>
            <span class="n">root</span><span class="o">=</span><span class="n">root</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span>
            <span class="n">include_branch_lengths</span><span class="o">=</span><span class="n">include_branch_lengths</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.as_dict_of_dicts">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.as_dict_of_dicts">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_dict_of_dicts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert tree to dict of dicts for conversion to a</span>
<span class="sd">        `networkx graph &lt;https://networkx.github.io/documentation/stable/</span>
<span class="sd">        reference/classes/digraph.html&gt;`_.</span>

<span class="sd">        For example::</span>

<span class="sd">            import networkx as nx</span>
<span class="sd">            nx.DiGraph(tree.as_dict_of_dicts())</span>
<span class="sd">            # undirected graphs work as well</span>
<span class="sd">            nx.Graph(tree.as_dict_of_dicts())</span>

<span class="sd">        :return: Dictionary of dictionaries of dictionaries where the first key</span>
<span class="sd">            is the source, the second key is the target of an edge, and the</span>
<span class="sd">            third key is an edge annotation. At this point the only annotation</span>
<span class="sd">            is &quot;branch_length&quot;, the length of the branch (in units of time).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dod</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">dod</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">parent</span><span class="p">):</span>
                <span class="n">dod</span><span class="p">[</span><span class="n">parent</span><span class="p">][</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;branch_length&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_length</span><span class="p">(</span><span class="n">child</span><span class="p">)}</span>
        <span class="k">return</span> <span class="n">dod</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parent_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_dict</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_parent_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">u</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NULL</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">pi</span>

<div class="viewcode-block" id="Tree.__str__">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.__str__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a plain text summary of a tree in a tree sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree_rows</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">util</span><span class="o">.</span><span class="n">format_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
            <span class="p">[</span>
                <span class="s2">&quot;Interval&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">util</span><span class="o">.</span><span class="n">format_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">-&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">util</span><span class="o">.</span><span class="n">format_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">util</span><span class="o">.</span><span class="n">format_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">span</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;Roots&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">util</span><span class="o">.</span><span class="n">format_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_roots</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;Nodes&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">util</span><span class="o">.</span><span class="n">format_number</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preorder</span><span class="p">()),</span><span class="w"> </span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;Sites&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">util</span><span class="o">.</span><span class="n">format_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;Mutations&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">util</span><span class="o">.</span><span class="n">format_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_mutations</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
            <span class="p">[</span>
                <span class="s2">&quot;Total Branch Length&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">util</span><span class="o">.</span><span class="n">format_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_branch_length</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">unicode_table</span><span class="p">(</span><span class="n">tree_rows</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Tree&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree._repr_html_">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree._repr_html_">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an html summary of a tree in a tree sequence. Called by jupyter</span>
<span class="sd">        notebooks to render trees</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">tree_html</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.map_mutations">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.map_mutations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">map_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">genotypes</span><span class="p">,</span> <span class="n">alleles</span><span class="p">,</span> <span class="n">ancestral_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given observations for the samples in this tree described by the specified</span>
<span class="sd">        set of genotypes and alleles, return a parsimonious set of state transitions</span>
<span class="sd">        explaining these observations. The genotypes array is interpreted as indexes</span>
<span class="sd">        into the alleles list in the same manner as described in the</span>
<span class="sd">        :meth:`TreeSequence.variants` method. Thus, if sample ``j`` carries the</span>
<span class="sd">        allele at index ``k``, then we have ``genotypes[j] = k``.</span>
<span class="sd">        Missing observations can be specified for a sample using the value</span>
<span class="sd">        ``tskit.MISSING_DATA`` (-1), in which case the state at this sample does not</span>
<span class="sd">        influence the ancestral state or the position of mutations returned. At least</span>
<span class="sd">        one non-missing observation must be provided. A maximum of 64 alleles are</span>
<span class="sd">        supported.</span>

<span class="sd">        The current implementation uses the Hartigan parsimony algorithm to determine</span>
<span class="sd">        the minimum number of state transitions required to explain the data. In this</span>
<span class="sd">        model, transitions between any of the non-missing states is equally likely.</span>

<span class="sd">        The returned values correspond directly to the data model for describing</span>
<span class="sd">        variation at sites using mutations. See the :ref:`sec_site_table_definition`</span>
<span class="sd">        and :ref:`sec_mutation_table_definition` definitions for details and background.</span>

<span class="sd">        The state reconstruction is returned as two-tuple, ``(ancestral_state,</span>
<span class="sd">        mutations)``, where ``ancestral_state`` is the allele assigned to the</span>
<span class="sd">        tree root(s) and ``mutations`` is a list of :class:`Mutation` objects,</span>
<span class="sd">        ordered as :ref:`required in a mutation table&lt;sec_mutation_requirements&gt;`.</span>
<span class="sd">        For each mutation, ``derived_state`` is the new state after this mutation and</span>
<span class="sd">        ``node`` is the tree node immediately beneath the mutation (if there are unary</span>
<span class="sd">        nodes between two branch points, hence multiple nodes above which the</span>
<span class="sd">        mutation could be parsimoniously placed, the oldest node is used). The</span>
<span class="sd">        ``parent`` property contains the index in the returned list of the previous</span>
<span class="sd">        mutation on the path to root, or ``tskit.NULL``</span>
<span class="sd">        if there are no previous mutations (see the :ref:`sec_mutation_table_definition`</span>
<span class="sd">        for more information on the concept of mutation parents). All other attributes</span>
<span class="sd">        of the :class:`Mutation` object are undefined and should not be used.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Sample states observed as missing in the input ``genotypes`` need</span>
<span class="sd">            not correspond to samples whose nodes are actually &quot;missing&quot; (i.e.,</span>
<span class="sd">            :ref:`isolated&lt;sec_data_model_missing_data&gt;`) in the tree. In this</span>
<span class="sd">            case, mapping the mutations returned by this method onto the tree</span>
<span class="sd">            will result in these missing observations being imputed to the</span>
<span class="sd">            most parsimonious state.</span>

<span class="sd">        Because the ``parent`` in the returned list of mutations refers to the index</span>
<span class="sd">        in that list, if you are adding mutations to an existing tree sequence, you</span>
<span class="sd">        will need to maintain a map of list IDs to the newly added mutations, for</span>
<span class="sd">        instance::</span>

<span class="sd">            last_tree = ts.last()</span>
<span class="sd">            anc_state, parsimonious_muts = last_tree.map_mutations([0, 1, 0], (&quot;A&quot;, &quot;T&quot;))</span>
<span class="sd">            # Edit the tree sequence, see the &quot;Tables and Editing&quot; tutorial</span>
<span class="sd">            tables = ts.dump_tables()</span>
<span class="sd">            # add a new site at the end of ts, assumes there isn&#39;t one there already</span>
<span class="sd">            site_id = tables.sites.add_row(ts.sequence_length - 1, anc_state)</span>

<span class="sd">            mut_id_map = {tskit.NULL: tskit.NULL}  # don&#39;t change if parent id is -1</span>
<span class="sd">            for list_id, mutation in enumerate(parsimonious_muts):</span>
<span class="sd">                mut_id_map[list_id] = tables.mutations.append(</span>
<span class="sd">                    mutation.replace(site=site_id, parent=mut_id_map[mutation.parent]))</span>
<span class="sd">            tables.sort()  # Redundant here, but needed if the site is not the last one</span>
<span class="sd">            new_ts = tables.tree_sequence()</span>

<span class="sd">        See the :ref:`tutorials:sec_analysing_trees_parsimony` section in the tutorial</span>
<span class="sd">        for further examples of how to use this method.</span>

<span class="sd">        :param array_like genotypes: The input observations for the samples in this tree.</span>
<span class="sd">        :param tuple(str) alleles: The alleles for the specified ``genotypes``. Each</span>
<span class="sd">            positive value in the ``genotypes`` array is treated as an index into this</span>
<span class="sd">            list of alleles.</span>
<span class="sd">        :param ancestral_state: A fixed ancestral state, specified either as a</span>
<span class="sd">            non-negative integer less than the number of alleles, or a string which</span>
<span class="sd">            must be one of the ``alleles`` provided above. If ``None`` (default) then</span>
<span class="sd">            an ancestral state is chosen arbitrarily from among those that provide</span>
<span class="sd">            the most parsimonious placement of mutations. Note that if the ancestral</span>
<span class="sd">            state is specified, the placement of mutations may not be as parsimonious</span>
<span class="sd">            as that which could be achieved by leaving the ancestral state unspecified;</span>
<span class="sd">            additionally it may lead to mutations being placed above the root node(s) of</span>
<span class="sd">            the tree (for example if all the samples have a genotype of 1 but the</span>
<span class="sd">            ancestral state is fixed to be 0).</span>
<span class="sd">        :type ancestral_state: Union[int, str]</span>
<span class="sd">        :return: The inferred ancestral state and list of mutations on this tree</span>
<span class="sd">            that encode the specified observations.</span>
<span class="sd">        :rtype: (str, list(tskit.Mutation))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">genotypes</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">genotypes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
        <span class="n">max_alleles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">genotypes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ancestral_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ancestral_state</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># Will raise a ValueError if not in the list</span>
                <span class="n">ancestral_state</span> <span class="o">=</span> <span class="n">alleles</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ancestral_state</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ancestral_state</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ancestral_state</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ancestral_state not between 0 and (num_alleles-1)&quot;</span><span class="p">)</span>
            <span class="n">max_alleles</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ancestral_state</span><span class="p">,</span> <span class="n">max_alleles</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_alleles</span> <span class="o">&gt;=</span> <span class="mi">64</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;A maximum of 64 states is supported&quot;</span><span class="p">)</span>
        <span class="n">ancestral_state</span><span class="p">,</span> <span class="n">transitions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">map_mutations</span><span class="p">(</span>
            <span class="n">genotypes</span><span class="p">,</span> <span class="n">ancestral_state</span>
        <span class="p">)</span>
        <span class="c1"># Translate back into string alleles</span>
        <span class="n">ancestral_state</span> <span class="o">=</span> <span class="n">alleles</span><span class="p">[</span><span class="n">ancestral_state</span><span class="p">]</span>
        <span class="n">mutations</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">Mutation</span><span class="p">(</span>
                <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                <span class="n">derived_state</span><span class="o">=</span><span class="n">alleles</span><span class="p">[</span><span class="n">derived_state</span><span class="p">],</span>
                <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">mutation</span><span class="o">.</span><span class="n">empty_value</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">derived_state</span> <span class="ow">in</span> <span class="n">transitions</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">ancestral_state</span><span class="p">,</span> <span class="n">mutations</span></div>


<div class="viewcode-block" id="Tree.kc_distance">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.kc_distance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">kc_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">lambda_</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Kendall-Colijn distance between the specified pair of trees.</span>
<span class="sd">        The ``lambda_`` parameter  determines the relative weight of topology</span>
<span class="sd">        vs branch lengths in calculating the distance. If ``lambda_`` is 0</span>
<span class="sd">        (the default) we only consider topology, and if it is 1 we only</span>
<span class="sd">        consider branch lengths. See `Kendall &amp; Colijn (2016)</span>
<span class="sd">        &lt;https://academic.oup.com/mbe/article/33/10/2735/2925548&gt;`_ for details.</span>

<span class="sd">        The trees we are comparing to must have identical lists of sample</span>
<span class="sd">        nodes (i.e., the same IDs in the same order). The metric operates on</span>
<span class="sd">        samples, not leaves, so internal samples are treated identically to</span>
<span class="sd">        sample tips. Subtrees with no samples do not contribute to the metric.</span>

<span class="sd">        :param Tree other: The other tree to compare to.</span>
<span class="sd">        :param float lambda_: The KC metric lambda parameter determining the</span>
<span class="sd">            relative weight of topology and branch length.</span>
<span class="sd">        :return: The computed KC distance between this tree and other.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_kc_distance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_ll_tree</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_sample_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;postorder&quot;</span><span class="p">):</span>
            <span class="n">u_sample_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sample</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="n">u_sample_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
                <span class="n">u_sample_set</span> <span class="o">|=</span> <span class="n">ret</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">u_sample_set</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

<div class="viewcode-block" id="Tree.rf_distance">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.rf_distance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rf_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the (unweighted) Robinson-Foulds distance between the specified pair</span>
<span class="sd">        of trees, where corresponding samples between the two trees are identified by</span>
<span class="sd">        node ID. The Robinson-Foulds distance (also known as the symmetric difference)</span>
<span class="sd">        is defined as the number of bipartitions that are present in one tree but</span>
<span class="sd">        not the other (see</span>
<span class="sd">        `Robinson &amp; Foulds (1981) &lt;https://doi.org/10.1016/0025-5564(81)90043-2&gt;`_).</span>
<span class="sd">        This method returns the unnormalised RF distance: if the</span>
<span class="sd">        trees are strictly bifurcating, i.e. binary, the value can be</span>
<span class="sd">        normalised by dividing by the maximum, which is $2n-4$ for two rooted</span>
<span class="sd">        trees of $n$ samples (however, if the trees contain polytomies, the maximum</span>
<span class="sd">        RF distance is less easily defined).</span>

<span class="sd">        .. note::</span>
<span class="sd">            The RF distance can be sensitive to small changes in topology: in some</span>
<span class="sd">            cases, changing the position of a single leaf can result in the maximum</span>
<span class="sd">            RF distance. Therefore even if adjacent trees in a tree sequence differ</span>
<span class="sd">            by a single subtree-prune-and-regraft operation, the RF distance</span>
<span class="sd">            between them can be large.</span>

<span class="sd">        :param Tree other: The other tree to compare to. Trees are treated as rooted.</span>
<span class="sd">        :return: The unweighted Robinson-Foulds distance between this tree and ``other``.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        :raises ValueError: If either tree has multiple roots, or the trees have</span>
<span class="sd">            different sample nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_roots</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">num_roots</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Trees must have a single root&quot;</span><span class="p">)</span>

        <span class="n">s1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_sample_sets</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_get_sample_sets</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">s2</span><span class="p">))</span></div>


<div class="viewcode-block" id="Tree.path_length">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.path_length">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">path_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of edges on the path in this tree between the two nodes.</span>
<span class="sd">        If the two nodes have a most recent common ancestor, then this is defined as</span>
<span class="sd">        ``tree.depth(u) + tree.depth(v) - 2 * tree.depth(tree.mrca(u, v))``. If the nodes</span>
<span class="sd">        do not have an MRCA (i.e., they are in disconnected subtrees) the path length</span>
<span class="sd">        is infinity.</span>

<span class="sd">        .. note:: This counts the number of &quot;hops&quot; between two nodes. To find the branch</span>
<span class="sd">            length distance between them, in units of time (i.e. the sum of edge lengths</span>
<span class="sd">            that separate two nodes) use the :meth:`.distance_between` method instead.</span>

<span class="sd">        .. seealso:: See also the :meth:`.depth` method</span>

<span class="sd">        :param int u: The first node for path length computation.</span>
<span class="sd">        :param int v: The second node for path length computation.</span>
<span class="sd">        :return: The number of edges between the two nodes.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mrca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mrca</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mrca</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">(</span><span class="n">mrca</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.distance_between">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.distance_between">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total distance between two nodes in the tree, expressed as</span>
<span class="sd">        the sum of &quot;branch lengths&quot; from both nodes to their most recent common ancestor.</span>

<span class="sd">        :param int u: The first node for path length computation.</span>
<span class="sd">        :param int v: The second node for path length computation.</span>
<span class="sd">        :return: The distance between the two nodes, the sum of &quot;branch lengths&quot; .</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmrca</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmrca</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tmrca</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="n">tmrca</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.b1_index">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.b1_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">b1_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the</span>
<span class="sd">        `B1 balance index &lt;https://treebalance.wordpress.com/b-index/&gt;`_</span>
<span class="sd">        for this tree. This is defined as the inverse of the sum of all</span>
<span class="sd">        longest paths to leaves for each node besides roots.</span>

<span class="sd">        .. seealso:: See `Shao and Sokal (1990)</span>
<span class="sd">            &lt;https://www.jstor.org/stable/2992186&gt;`_ for details.</span>

<span class="sd">        :return: The B1 balance index.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_b1_index</span><span class="p">()</span></div>


<div class="viewcode-block" id="Tree.b2_index">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.b2_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">b2_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the</span>
<span class="sd">        `B2 balance index &lt;https://treebalance.wordpress.com/b-index/&gt;`_</span>
<span class="sd">        this tree.</span>
<span class="sd">        This is defined as the Shannon entropy of the probability</span>
<span class="sd">        distribution to reach leaves assuming a random walk</span>
<span class="sd">        from a root. The default base is 10, following Shao and Sokal (1990).</span>

<span class="sd">        .. seealso:: See `Shao and Sokal (1990)</span>
<span class="sd">            &lt;https://www.jstor.org/stable/2992186&gt;`_ for details.</span>

<span class="sd">        :param int base: The base used for the logarithm in the</span>
<span class="sd">            Shannon entropy computation.</span>
<span class="sd">        :return: The B2 balance index.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Let Python decide if the base is acceptable</span>
        <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_b2_index</span><span class="p">(</span><span class="n">base</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.colless_index">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.colless_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">colless_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the</span>
<span class="sd">        `Colless imbalance index &lt;https://treebalance.wordpress.com/colless-index/&gt;`_</span>
<span class="sd">        for this tree. This is defined as the sum of all differences between</span>
<span class="sd">        number of leaves subtended by the left and right child of each node.</span>
<span class="sd">        The Colless index is undefined for non-binary trees and trees with</span>
<span class="sd">        multiple roots. This method will raise a LibraryError if the tree is</span>
<span class="sd">        not singly-rooted and binary.</span>

<span class="sd">        .. seealso:: See `Shao and Sokal (1990)</span>
<span class="sd">            &lt;https://www.jstor.org/stable/2992186&gt;`_ for details.</span>

<span class="sd">        :return: The Colless imbalance index.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_colless_index</span><span class="p">()</span></div>


<div class="viewcode-block" id="Tree.sackin_index">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.sackin_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sackin_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the</span>
<span class="sd">        `Sackin imbalance index &lt;https://treebalance.wordpress.com/sackin-index/&gt;`_</span>
<span class="sd">        for this tree. This is defined as the sum of the depths of all leaves</span>
<span class="sd">        in the tree. Equivalent to ``sum(tree.depth(u) for u in</span>
<span class="sd">        tree.leaves())``</span>

<span class="sd">        .. seealso:: See `Shao and Sokal (1990)</span>
<span class="sd">            &lt;https://www.jstor.org/stable/2992186&gt;`_ for details.</span>

<span class="sd">        :return: The Sackin imbalance index.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_sackin_index</span><span class="p">()</span></div>


<div class="viewcode-block" id="Tree.num_lineages">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.num_lineages">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_lineages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of lineages present in this tree at time ``t``. This</span>
<span class="sd">        is defined as the number of branches in this tree (reachable from the</span>
<span class="sd">        samples) that intersect with ``t``. Thus, ``tree.num_lineages(t)``</span>
<span class="sd">        is equal to 0 for any ``t`` greater than or equal to the time of</span>
<span class="sd">        the root in a singly-rooted tree.</span>

<span class="sd">        .. note:: Note that this definition means that if a (non root) node</span>
<span class="sd">            with three children has time ``t``, then it will count as one lineage,</span>
<span class="sd">            not three.</span>

<span class="sd">        :param int t: The time to count lineages at.</span>
<span class="sd">        :return: The number of lineages in the tree at time t.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree</span><span class="o">.</span><span class="n">get_num_lineages</span><span class="p">(</span><span class="n">t</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tree.split_polytomies">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.split_polytomies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_polytomies</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new :class:`.Tree` where extra nodes and edges have been inserted</span>
<span class="sd">        so that any any node ``u`` with greater than 2 children --- a multifurcation</span>
<span class="sd">        or &quot;polytomy&quot; --- is resolved into successive bifurcations. New nodes are</span>
<span class="sd">        inserted at times fractionally less than than the time of node ``u``.</span>
<span class="sd">        Times are allocated to different levels of the tree, such that any newly</span>
<span class="sd">        inserted sibling nodes will have the same time.</span>

<span class="sd">        By default, the times of the newly generated children of a particular</span>
<span class="sd">        node are the minimum representable distance in floating point arithmetic</span>
<span class="sd">        from their parents (using the `nextafter</span>
<span class="sd">        &lt;https://numpy.org/doc/stable/reference/generated/numpy.nextafter.html&gt;`_</span>
<span class="sd">        function). Thus, the generated branches have the shortest possible nonzero</span>
<span class="sd">        length. A fixed branch length between inserted nodes and their parents</span>
<span class="sd">        can also be specified by using the ``epsilon`` parameter.</span>

<span class="sd">        .. note::</span>
<span class="sd">            A tree sequence :ref:`requires&lt;sec_valid_tree_sequence_requirements&gt;` that</span>
<span class="sd">            parents be older than children and that mutations are younger than the</span>
<span class="sd">            parent of the edge on which they lie. If a fixed ``epsilon`` is specifed</span>
<span class="sd">            and is not small enough compared to the distance between a polytomy and</span>
<span class="sd">            its oldest child (or oldest child mutation) these requirements may not</span>
<span class="sd">            be met. In this case an error will be raised.</span>

<span class="sd">        If the ``method`` is ``&quot;random&quot;`` (currently the only option, and the default</span>
<span class="sd">        when no method is specified), then for a node with :math:`n` children, the</span>
<span class="sd">        :math:`(2n - 3)! / (2^(n - 2) (n - 2!))` possible binary trees with equal</span>
<span class="sd">        probability.</span>

<span class="sd">        The returned :class:`.Tree` will have the same genomic span as this tree,</span>
<span class="sd">        and node IDs will be conserved (that is, node ``u`` in this tree will</span>
<span class="sd">        be the same node in the returned tree). The returned tree is derived from a</span>
<span class="sd">        tree sequence that contains only one non-degenerate tree, that is, where</span>
<span class="sd">        edges cover only the interval spanned by this tree.</span>

<span class="sd">        :param epsilon: If specified, the fixed branch length between inserted</span>
<span class="sd">            nodes and their parents. If None (the default), the minimal possible</span>
<span class="sd">            nonzero branch length is generated for each node.</span>
<span class="sd">        :param str method: The method used to break polytomies. Currently only &quot;random&quot;</span>
<span class="sd">            is supported, which can also be specified by ``method=None``</span>
<span class="sd">            (Default: ``None``).</span>
<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: True).</span>
<span class="sd">        :param int random_seed: The random seed. If this is None, a random seed will</span>
<span class="sd">            be automatically generated. Valid random seeds must be between 1 and</span>
<span class="sd">            :math:`2^32  1`.</span>
<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned :class:`Tree`. For example</span>
<span class="sd">            ``tree.split_polytomies(sample_lists=True)`` will</span>
<span class="sd">            return a :class:`Tree` created with ``sample_lists=True``.</span>
<span class="sd">        :return: A new tree with polytomies split into random bifurcations.</span>
<span class="sd">        :rtype: tskit.Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">split_polytomies</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">epsilon</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
            <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.generate_star">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.generate_star">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_star</span><span class="p">(</span>
        <span class="n">num_leaves</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">branch_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a :class:`Tree` whose leaf nodes all have the same parent (i.e.,</span>
<span class="sd">        a &quot;star&quot; tree). The leaf nodes are all at time 0 and are marked as sample nodes.</span>

<span class="sd">        The tree produced by this method is identical to</span>
<span class="sd">        ``tskit.Tree.unrank(n, (0, 0))``, but generated more efficiently for large ``n``.</span>

<span class="sd">        :param int num_leaves: The number of leaf nodes in the returned tree (must be</span>
<span class="sd">            2 or greater).</span>
<span class="sd">        :param float span: The span of the tree, and therefore the</span>
<span class="sd">            :attr:`~TreeSequence.sequence_length` of the :attr:`.tree_sequence`</span>
<span class="sd">            property of the returned :class:`Tree`.</span>
<span class="sd">        :param float branch_length: The length of every branch in the tree (equivalent</span>
<span class="sd">            to the time of the root node).</span>
<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: True).</span>
<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned :class:`Tree`. For example</span>
<span class="sd">            ``tskit.Tree.generate_star(sample_lists=True)`` will</span>
<span class="sd">            return a :class:`Tree` created with ``sample_lists=True``.</span>
<span class="sd">        :return: A star-shaped tree. Its corresponding :class:`TreeSequence` is available</span>
<span class="sd">            via the :attr:`.tree_sequence` attribute.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">generate_star</span><span class="p">(</span>
            <span class="n">num_leaves</span><span class="p">,</span>
            <span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">,</span>
            <span class="n">branch_length</span><span class="o">=</span><span class="n">branch_length</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.generate_balanced">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.generate_balanced">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_balanced</span><span class="p">(</span>
        <span class="n">num_leaves</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">arity</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">span</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">branch_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a :class:`Tree` with the specified number of leaves that is maximally</span>
<span class="sd">        balanced. By default, the tree returned is binary, such that for each</span>
<span class="sd">        node that subtends :math:`n` leaves, the left child will subtend</span>
<span class="sd">        :math:`\\lfloor{n / 2}\\rfloor` leaves and the right child the</span>
<span class="sd">        remainder. Balanced trees with higher arity can also generated using the</span>
<span class="sd">        ``arity`` parameter, where the leaves subtending a node are distributed</span>
<span class="sd">        among its children analogously.</span>

<span class="sd">        In the returned tree, the leaf nodes are all at time 0, marked as samples,</span>
<span class="sd">        and labelled 0 to n from left-to-right. Internal node IDs are assigned</span>
<span class="sd">        sequentially from n in a postorder traversal, and the time of an internal</span>
<span class="sd">        node is the maximum time of its children plus the specified ``branch_length``.</span>

<span class="sd">        :param int num_leaves: The number of leaf nodes in the returned tree (must be</span>
<span class="sd">            be 2 or greater).</span>
<span class="sd">        :param int arity: The maximum number of children a node can have in the returned</span>
<span class="sd">            tree.</span>
<span class="sd">        :param float span: The span of the tree, and therefore the</span>
<span class="sd">            :attr:`~TreeSequence.sequence_length` of the :attr:`.tree_sequence`</span>
<span class="sd">            property of the returned :class:`Tree`.</span>
<span class="sd">        :param float branch_length: The minimum length of a branch in the tree (see</span>
<span class="sd">            above for details on how internal node times are assigned).</span>
<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: True).</span>
<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned :class:`Tree`. For example</span>
<span class="sd">            ``tskit.Tree.generate_balanced(sample_lists=True)`` will</span>
<span class="sd">            return a :class:`Tree` created with ``sample_lists=True``.</span>
<span class="sd">        :return: A balanced tree. Its corresponding :class:`TreeSequence` is available</span>
<span class="sd">            via the :attr:`.tree_sequence` attribute.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">generate_balanced</span><span class="p">(</span>
            <span class="n">num_leaves</span><span class="p">,</span>
            <span class="n">arity</span><span class="o">=</span><span class="n">arity</span><span class="p">,</span>
            <span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">,</span>
            <span class="n">branch_length</span><span class="o">=</span><span class="n">branch_length</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.generate_comb">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.generate_comb">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_comb</span><span class="p">(</span>
        <span class="n">num_leaves</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">span</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">branch_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a :class:`Tree` in which all internal nodes have two children</span>
<span class="sd">        and the left child is a leaf. This is a &quot;comb&quot;, &quot;ladder&quot; or &quot;pectinate&quot;</span>
<span class="sd">        phylogeny, and also known as a `caterpillar tree</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Caterpillar_tree&gt;`_.</span>

<span class="sd">        The leaf nodes are all at time 0, marked as samples,</span>
<span class="sd">        and labelled 0 to n from left-to-right. Internal node IDs are assigned</span>
<span class="sd">        sequentially from n as we ascend the tree, and the time of an internal</span>
<span class="sd">        node is the maximum time of its children plus the specified ``branch_length``.</span>

<span class="sd">        :param int num_leaves: The number of leaf nodes in the returned tree (must be</span>
<span class="sd">            2 or greater).</span>
<span class="sd">        :param float span: The span of the tree, and therefore the</span>
<span class="sd">            :attr:`~TreeSequence.sequence_length` of the :attr:`.tree_sequence`</span>
<span class="sd">            property of the returned :class:`Tree`.</span>
<span class="sd">        :param float branch_length: The branch length between each internal node; the</span>
<span class="sd">            root node is therefore placed at time ``branch_length * (num_leaves - 1)``.</span>
<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: True).</span>
<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned :class:`Tree`. For example</span>
<span class="sd">            ``tskit.Tree.generate_comb(sample_lists=True)`` will</span>
<span class="sd">            return a :class:`Tree` created with ``sample_lists=True``.</span>
<span class="sd">        :return: A comb-shaped bifurcating tree. Its corresponding :class:`TreeSequence`</span>
<span class="sd">            is available via the :attr:`.tree_sequence` attribute.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">generate_comb</span><span class="p">(</span>
            <span class="n">num_leaves</span><span class="p">,</span>
            <span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">,</span>
            <span class="n">branch_length</span><span class="o">=</span><span class="n">branch_length</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Tree.generate_random_binary">
<a class="viewcode-back" href="../../python-api.html#tskit.Tree.generate_random_binary">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_random_binary</span><span class="p">(</span>
        <span class="n">num_leaves</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">span</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">branch_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a random binary :class:`Tree` with :math:`n` = ``num_leaves``</span>
<span class="sd">        leaves with an equal probability of returning any topology and</span>
<span class="sd">        leaf label permutation among the :math:`(2n - 3)! / (2^{n - 2} (n - 2)!)`</span>
<span class="sd">        leaf-labelled binary trees.</span>

<span class="sd">        The leaf nodes are marked as samples, labelled 0 to n, and placed at</span>
<span class="sd">        time 0. Internal node IDs are assigned sequentially from n as we ascend</span>
<span class="sd">        the tree, and the time of an internal node is the maximum time of its</span>
<span class="sd">        children plus the specified ``branch_length``.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The returned tree has not been created under any explicit model of</span>
<span class="sd">            evolution. In order to simulate such trees, additional software</span>
<span class="sd">            such as `msprime &lt;https://github.com/tskit-dev/msprime&gt;`` is required.</span>

<span class="sd">        :param int num_leaves: The number of leaf nodes in the returned tree (must</span>
<span class="sd">            be 2 or greater).</span>
<span class="sd">        :param float span: The span of the tree, and therefore the</span>
<span class="sd">            :attr:`~TreeSequence.sequence_length` of the :attr:`.tree_sequence`</span>
<span class="sd">            property of the returned :class:`Tree`.</span>
<span class="sd">        :param float branch_length: The minimum time between parent and child nodes.</span>
<span class="sd">        :param int random_seed: The random seed. If this is None, a random seed will</span>
<span class="sd">            be automatically generated. Valid random seeds must be between 1 and</span>
<span class="sd">            :math:`2^32  1`.</span>
<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: True).</span>
<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned :class:`Tree`. For example</span>
<span class="sd">            ``tskit.Tree.generate_comb(sample_lists=True)`` will</span>
<span class="sd">            return a :class:`Tree` created with ``sample_lists=True``.</span>
<span class="sd">        :return: A random binary tree. Its corresponding :class:`TreeSequence` is</span>
<span class="sd">            available via the :attr:`.tree_sequence` attribute.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">generate_random_binary</span><span class="p">(</span>
            <span class="n">num_leaves</span><span class="p">,</span>
            <span class="n">span</span><span class="o">=</span><span class="n">span</span><span class="p">,</span>
            <span class="n">branch_length</span><span class="o">=</span><span class="n">branch_length</span><span class="p">,</span>
            <span class="n">random_seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="load">
<a class="viewcode-back" href="../../python-api.html#tskit.load">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">skip_tables</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_reference_sequence</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a :class:`TreeSequence` instance loaded from the specified file object or</span>
<span class="sd">    path. The file must be in the</span>
<span class="sd">    :ref:`tree sequence file format &lt;sec_tree_sequence_file_format&gt;`</span>
<span class="sd">    produced by the :meth:`TreeSequence.dump` method.</span>

<span class="sd">    .. warning:: With any of the ``skip_tables`` or ``skip_reference_sequence``</span>
<span class="sd">        options set, it is not possible to load data from a non-seekable stream</span>
<span class="sd">        (e.g. a socket or STDIN) of multiple tree sequences using consecutive</span>
<span class="sd">        calls to :meth:`tskit.load`.</span>

<span class="sd">    :param str file: The file object or path of the ``.trees`` file containing the</span>
<span class="sd">        tree sequence we wish to load.</span>
<span class="sd">    :param bool skip_tables: If True, no tables are read from the ``.trees``</span>
<span class="sd">        file and only the top-level information is populated in the tree</span>
<span class="sd">        sequence object.</span>
<span class="sd">    :param bool skip_reference_sequence: If True, the tree sequence is read</span>
<span class="sd">        without loading its reference sequence.</span>
<span class="sd">    :return: The tree sequence object containing the information</span>
<span class="sd">        stored in the specified file path.</span>
<span class="sd">    :rtype: :class:`tskit.TreeSequence`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">TreeSequence</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
        <span class="n">file</span><span class="p">,</span> <span class="n">skip_tables</span><span class="o">=</span><span class="n">skip_tables</span><span class="p">,</span> <span class="n">skip_reference_sequence</span><span class="o">=</span><span class="n">skip_reference_sequence</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="parse_individuals">
<a class="viewcode-back" href="../../python-api.html#tskit.parse_individuals">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_individuals</span><span class="p">(</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span> <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified file-like object containing a whitespace delimited</span>
<span class="sd">    description of an individual table and returns the corresponding</span>
<span class="sd">    :class:`IndividualTable` instance. See the :ref:`individual text format</span>
<span class="sd">    &lt;sec_individual_text_format&gt;` section for the details of the required</span>
<span class="sd">    format and the :ref:`individual table definition</span>
<span class="sd">    &lt;sec_individual_table_definition&gt;` section for the required properties of</span>
<span class="sd">    the contents.</span>

<span class="sd">    See :func:`tskit.load_text` for a detailed explanation of the ``strict``</span>
<span class="sd">    parameter.</span>

<span class="sd">    :param io.TextIOBase source: The file-like object containing the text.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    :param IndividualTable table: If specified write into this table. If not,</span>
<span class="sd">        create a new :class:`IndividualTable` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">IndividualTable</span><span class="p">()</span>
    <span class="c1"># Read the header and find the indexes of the required fields.</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">flags_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;flags&quot;</span><span class="p">)</span>
    <span class="n">location_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">parents_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">metadata_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">location_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;location&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">parents_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;parents&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">metadata_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">flags_index</span><span class="p">])</span>
            <span class="n">location</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">if</span> <span class="n">location_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">location_string</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">location_index</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location_string</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">location</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">location_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)))</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="p">()</span>
            <span class="k">if</span> <span class="n">parents_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parents_string</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">parents_index</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents_string</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">parents</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">parents_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)))</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">metadata_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">metadata_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">metadata_index</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>



<div class="viewcode-block" id="parse_nodes">
<a class="viewcode-back" href="../../python-api.html#tskit.parse_nodes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_nodes</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span> <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified file-like object containing a whitespace delimited</span>
<span class="sd">    description of a node table and returns the corresponding :class:`NodeTable`</span>
<span class="sd">    instance. See the :ref:`node text format &lt;sec_node_text_format&gt;` section</span>
<span class="sd">    for the details of the required format and the</span>
<span class="sd">    :ref:`node table definition &lt;sec_node_table_definition&gt;` section for the</span>
<span class="sd">    required properties of the contents.</span>

<span class="sd">    See :func:`tskit.load_text` for a detailed explanation of the ``strict``</span>
<span class="sd">    parameter.</span>

<span class="sd">    :param io.TextIOBase source: The file-like object containing the text.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    :param NodeTable table: If specified write into this table. If not,</span>
<span class="sd">        create a new :class:`NodeTable` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">NodeTable</span><span class="p">()</span>
    <span class="c1"># Read the header and find the indexes of the required fields.</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">is_sample_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;is_sample&quot;</span><span class="p">)</span>
    <span class="n">time_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
    <span class="n">population_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">individual_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">metadata_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">population_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;population&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">individual_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;individual&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">metadata_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">is_sample</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">is_sample_index</span><span class="p">])</span>
            <span class="n">time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">time_index</span><span class="p">])</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">is_sample</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">flags</span> <span class="o">|=</span> <span class="n">NODE_IS_SAMPLE</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">NULL</span>
            <span class="k">if</span> <span class="n">population_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">population</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">population_index</span><span class="p">])</span>
            <span class="n">individual</span> <span class="o">=</span> <span class="n">NULL</span>
            <span class="k">if</span> <span class="n">individual_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">individual</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">individual_index</span><span class="p">])</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">metadata_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">metadata_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">metadata_index</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
                <span class="n">individual</span><span class="o">=</span><span class="n">individual</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>



<div class="viewcode-block" id="parse_edges">
<a class="viewcode-back" href="../../python-api.html#tskit.parse_edges">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_edges</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span> <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified file-like object containing a whitespace delimited</span>
<span class="sd">    description of a edge table and returns the corresponding :class:`EdgeTable`</span>
<span class="sd">    instance. See the :ref:`edge text format &lt;sec_edge_text_format&gt;` section</span>
<span class="sd">    for the details of the required format and the</span>
<span class="sd">    :ref:`edge table definition &lt;sec_edge_table_definition&gt;` section for the</span>
<span class="sd">    required properties of the contents.</span>

<span class="sd">    See :func:`tskit.load_text` for a detailed explanation of the ``strict`` parameter.</span>

<span class="sd">    :param io.TextIOBase source: The file-like object containing the text.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param EdgeTable table: If specified, write the edges into this table. If</span>
<span class="sd">        not, create a new :class:`EdgeTable` instance and return.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">EdgeTable</span><span class="p">()</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">left_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">right_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
    <span class="n">parent_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;parent&quot;</span><span class="p">)</span>
    <span class="n">children_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;child&quot;</span><span class="p">)</span>
    <span class="n">metadata_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">metadata_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">default_metadata</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">left_index</span><span class="p">])</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">right_index</span><span class="p">])</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">parent_index</span><span class="p">])</span>
            <span class="n">children</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">tokens</span><span class="p">[</span><span class="n">children_index</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)))</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">default_metadata</span>
            <span class="k">if</span> <span class="n">metadata_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">metadata_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">metadata_index</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                    <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span>
                    <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span>
                    <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                    <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>
                    <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>



<div class="viewcode-block" id="parse_sites">
<a class="viewcode-back" href="../../python-api.html#tskit.parse_sites">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_sites</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span> <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified file-like object containing a whitespace delimited</span>
<span class="sd">    description of a site table and returns the corresponding :class:`SiteTable`</span>
<span class="sd">    instance. See the :ref:`site text format &lt;sec_site_text_format&gt;` section</span>
<span class="sd">    for the details of the required format and the</span>
<span class="sd">    :ref:`site table definition &lt;sec_site_table_definition&gt;` section for the</span>
<span class="sd">    required properties of the contents.</span>

<span class="sd">    See :func:`tskit.load_text` for a detailed explanation of the ``strict``</span>
<span class="sd">    parameter.</span>

<span class="sd">    :param io.TextIOBase source: The file-like object containing the text.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    :param SiteTable table: If specified write site into this table. If not,</span>
<span class="sd">        create a new :class:`SiteTable` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">SiteTable</span><span class="p">()</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">position_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;position&quot;</span><span class="p">)</span>
    <span class="n">ancestral_state_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;ancestral_state&quot;</span><span class="p">)</span>
    <span class="n">metadata_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">metadata_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">position_index</span><span class="p">])</span>
            <span class="n">ancestral_state</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">ancestral_state_index</span><span class="p">]</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">metadata_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">metadata_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">metadata_index</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">position</span><span class="o">=</span><span class="n">position</span><span class="p">,</span> <span class="n">ancestral_state</span><span class="o">=</span><span class="n">ancestral_state</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>



<div class="viewcode-block" id="parse_mutations">
<a class="viewcode-back" href="../../python-api.html#tskit.parse_mutations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_mutations</span><span class="p">(</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span> <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified file-like object containing a whitespace delimited</span>
<span class="sd">    description of a mutation table and returns the corresponding :class:`MutationTable`</span>
<span class="sd">    instance. See the :ref:`mutation text format &lt;sec_mutation_text_format&gt;` section</span>
<span class="sd">    for the details of the required format and the</span>
<span class="sd">    :ref:`mutation table definition &lt;sec_mutation_table_definition&gt;` section for the</span>
<span class="sd">    required properties of the contents. Note that if the ``time`` column is missing its</span>
<span class="sd">    entries are filled with ``UNKNOWN_TIME``.</span>

<span class="sd">    See :func:`tskit.load_text` for a detailed explanation of the ``strict``</span>
<span class="sd">    parameter.</span>

<span class="sd">    :param io.TextIOBase source: The file-like object containing the text.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    :param MutationTable table: If specified, write mutations into this table.</span>
<span class="sd">        If not, create a new :class:`MutationTable` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">MutationTable</span><span class="p">()</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">site_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;site&quot;</span><span class="p">)</span>
    <span class="n">node_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;node&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">time_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="n">time_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">derived_state_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;derived_state&quot;</span><span class="p">)</span>
    <span class="n">parent_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="n">NULL</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">parent_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;parent&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">metadata_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">metadata_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">site</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">site_index</span><span class="p">])</span>
            <span class="n">node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">node_index</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">time_index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">tokens</span><span class="p">[</span><span class="n">time_index</span><span class="p">]</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TIME_UNITS_UNKNOWN</span><span class="p">:</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">UNKNOWN_TIME</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">time_index</span><span class="p">])</span>
            <span class="n">derived_state</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">derived_state_index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">parent_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">parent_index</span><span class="p">])</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">metadata_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">metadata_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">metadata_index</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">site</span><span class="o">=</span><span class="n">site</span><span class="p">,</span>
                <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">derived_state</span><span class="o">=</span><span class="n">derived_state</span><span class="p">,</span>
                <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>



<div class="viewcode-block" id="parse_populations">
<a class="viewcode-back" href="../../python-api.html#tskit.parse_populations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_populations</span><span class="p">(</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span> <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified file-like object containing a whitespace delimited</span>
<span class="sd">    description of a population table and returns the corresponding</span>
<span class="sd">    :class:`PopulationTable` instance. See the :ref:`population text format</span>
<span class="sd">    &lt;sec_population_text_format&gt;` section for the details of the required</span>
<span class="sd">    format and the :ref:`population table definition</span>
<span class="sd">    &lt;sec_population_table_definition&gt;` section for the required properties of</span>
<span class="sd">    the contents.</span>

<span class="sd">    See :func:`tskit.load_text` for a detailed explanation of the ``strict``</span>
<span class="sd">    parameter.</span>

<span class="sd">    :param io.TextIOBase source: The file-like object containing the text.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    :param PopulationTable table: If specified write into this table. If not,</span>
<span class="sd">        create a new :class:`PopulationTable` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">PopulationTable</span><span class="p">()</span>
    <span class="c1"># Read the header and find the indexes of the required fields.</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">metadata_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">metadata_index</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>



<div class="viewcode-block" id="parse_migrations">
<a class="viewcode-back" href="../../python-api.html#tskit.parse_migrations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_migrations</span><span class="p">(</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span> <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">table</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the specified file-like object containing a whitespace delimited</span>
<span class="sd">    description of a migration table and returns the corresponding</span>
<span class="sd">    :class:`MigrationTable` instance.</span>

<span class="sd">    See the :ref:`migration text format &lt;sec_migration_text_format&gt;` section</span>
<span class="sd">    for the details of the required format and the</span>
<span class="sd">    :ref:`migration table definition &lt;sec_migration_table_definition&gt;` section</span>
<span class="sd">    for the required properties of the contents. Note that if the ``time`` column</span>
<span class="sd">    is missing its entries are filled with :data:`UNKNOWN_TIME`.</span>

<span class="sd">    See :func:`tskit.load_text` for a detailed explanation of the ``strict``</span>
<span class="sd">    parameter.</span>

<span class="sd">    :param io.TextIOBase source: The file-like object containing the text.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    :param MigrationTable table: If specified, write migrations into this table.</span>
<span class="sd">        If not, create a new :class:`MigrationTable` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">MigrationTable</span><span class="p">()</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
    <span class="n">left_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">right_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
    <span class="n">node_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;node&quot;</span><span class="p">)</span>
    <span class="n">source_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;source&quot;</span><span class="p">)</span>
    <span class="n">dest_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;dest&quot;</span><span class="p">)</span>
    <span class="n">time_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
    <span class="n">metadata_index</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">metadata_index</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;metadata&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">left_index</span><span class="p">])</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">right_index</span><span class="p">])</span>
            <span class="n">node</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">node_index</span><span class="p">])</span>
            <span class="n">source</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">source_index</span><span class="p">])</span>
            <span class="n">dest</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">dest_index</span><span class="p">])</span>
            <span class="n">time</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="n">time_index</span><span class="p">])</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">metadata_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">metadata_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
                <span class="n">metadata</span> <span class="o">=</span> <span class="n">tokens</span><span class="p">[</span><span class="n">metadata_index</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">base64_metadata</span><span class="p">:</span>
                    <span class="n">metadata</span> <span class="o">=</span> <span class="n">base64</span><span class="o">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
            <span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span>
                <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span>
                <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
                <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
                <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span></div>



<div class="viewcode-block" id="load_text">
<a class="viewcode-back" href="../../python-api.html#tskit.load_text">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">load_text</span><span class="p">(</span>
    <span class="n">nodes</span><span class="p">,</span>
    <span class="n">edges</span><span class="p">,</span>
    <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">mutations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">individuals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">populations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">migrations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sequence_length</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span>
    <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a :class:`TreeSequence` instance parsed from tabulated text data</span>
<span class="sd">    contained in the specified file-like objects. The format</span>
<span class="sd">    for these files is documented in the :ref:`sec_text_file_format` section,</span>
<span class="sd">    and is produced by the :meth:`TreeSequence.dump_text` method. Further</span>
<span class="sd">    properties required for an input tree sequence are described in the</span>
<span class="sd">    :ref:`sec_valid_tree_sequence_requirements` section. This method is intended as a</span>
<span class="sd">    convenient interface for importing external data into tskit; the binary</span>
<span class="sd">    file format using by :meth:`tskit.load` is many times more efficient than</span>
<span class="sd">    this text format.</span>

<span class="sd">    The ``nodes`` and ``edges`` parameters are mandatory and must be file-like</span>
<span class="sd">    objects containing text with whitespace delimited columns,  parsable by</span>
<span class="sd">    :func:`parse_nodes` and :func:`parse_edges`, respectively. ``sites``,</span>
<span class="sd">    ``individuals``, ``populations``, ``mutations``, and ``migrations`` are optional,</span>
<span class="sd">    and must be parsable by :func:`parse_sites`, :func:`parse_individuals`,</span>
<span class="sd">    :func:`parse_populations`, :func:`parse_mutations`, and :func:`parse_migrations`,</span>
<span class="sd">    respectively. For convenience, if the node table refers to populations,</span>
<span class="sd">    but the ``populations`` parameter is not provided, a minimal set of rows are</span>
<span class="sd">    added to the population table, so that a valid tree sequence can be returned.</span>

<span class="sd">    The ``sequence_length`` parameter determines the</span>
<span class="sd">    :attr:`TreeSequence.sequence_length` of the returned tree sequence. If it</span>
<span class="sd">    is 0 or not specified, the value is taken to be the maximum right</span>
<span class="sd">    coordinate of the input edges. This parameter is useful in degenerate</span>
<span class="sd">    situations (such as when there are zero edges), but can usually be ignored.</span>

<span class="sd">    The ``strict`` parameter controls the field delimiting algorithm that</span>
<span class="sd">    is used. If ``strict`` is True (the default), we require exactly one</span>
<span class="sd">    tab character separating each field. If ``strict`` is False, a more relaxed</span>
<span class="sd">    whitespace delimiting algorithm is used, such that any run of whitespace</span>
<span class="sd">    is regarded as a field separator. In most situations, ``strict=False``</span>
<span class="sd">    is more convenient, but it can lead to error in certain situations. For</span>
<span class="sd">    example, if a deletion is encoded in the mutation table this will not</span>
<span class="sd">    be parseable when ``strict=False``.</span>

<span class="sd">    After parsing the tables, :meth:`TableCollection.sort` is called to ensure that</span>
<span class="sd">    the loaded tables satisfy the tree sequence :ref:`ordering requirements</span>
<span class="sd">    &lt;sec_valid_tree_sequence_requirements&gt;`. Note that this may result in the</span>
<span class="sd">    IDs of various entities changing from their positions in the input file.</span>

<span class="sd">    :param io.TextIOBase nodes: The file-like object containing text describing a</span>
<span class="sd">        :class:`NodeTable`.</span>
<span class="sd">    :param io.TextIOBase edges: The file-like object containing text</span>
<span class="sd">        describing an :class:`EdgeTable`.</span>
<span class="sd">    :param io.TextIOBase sites: The file-like object containing text describing a</span>
<span class="sd">        :class:`SiteTable`.</span>
<span class="sd">    :param io.TextIOBase mutations: The file-like object containing text</span>
<span class="sd">        describing a :class:`MutationTable`.</span>
<span class="sd">    :param io.TextIOBase individuals: The file-like object containing text</span>
<span class="sd">        describing a :class:`IndividualTable`.</span>
<span class="sd">    :param io.TextIOBase populations: The file-like object containing text</span>
<span class="sd">        describing a :class:`PopulationTable`.</span>
<span class="sd">    :param io.TextIOBase migrations: The file-like object containing text</span>
<span class="sd">        describing a :class:`MigrationTable`.</span>
<span class="sd">    :param float sequence_length: The sequence length of the returned tree sequence. If</span>
<span class="sd">        not supplied or zero this will be inferred from the set of edges.</span>
<span class="sd">    :param bool strict: If True, require strict tab delimiting (default). If</span>
<span class="sd">        False, a relaxed whitespace splitting algorithm is used.</span>
<span class="sd">    :param str encoding: Encoding used for text representation.</span>
<span class="sd">    :param bool base64_metadata: If True, metadata is encoded using Base64</span>
<span class="sd">        encoding; otherwise, as plain text.</span>
<span class="sd">    :return: The tree sequence object containing the information</span>
<span class="sd">        stored in the specified file paths.</span>
<span class="sd">    :rtype: :class:`tskit.TreeSequence`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We need to parse the edges so we can figure out the sequence length, and</span>
    <span class="c1"># TableCollection.sequence_length is immutable so we need to create a temporary</span>
    <span class="c1"># edge table.</span>
    <span class="n">edge_table</span> <span class="o">=</span> <span class="n">parse_edges</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sequence_length</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_table</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sequence_length</span> <span class="o">=</span> <span class="n">edge_table</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tc</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span><span class="n">sequence_length</span><span class="p">)</span>
    <span class="n">tc</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">set_columns</span><span class="p">(</span>
        <span class="n">left</span><span class="o">=</span><span class="n">edge_table</span><span class="o">.</span><span class="n">left</span><span class="p">,</span>
        <span class="n">right</span><span class="o">=</span><span class="n">edge_table</span><span class="o">.</span><span class="n">right</span><span class="p">,</span>
        <span class="n">parent</span><span class="o">=</span><span class="n">edge_table</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span>
        <span class="n">child</span><span class="o">=</span><span class="n">edge_table</span><span class="o">.</span><span class="n">child</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parse_nodes</span><span class="p">(</span>
        <span class="n">nodes</span><span class="p">,</span>
        <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
        <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
        <span class="n">base64_metadata</span><span class="o">=</span><span class="n">base64_metadata</span><span class="p">,</span>
        <span class="n">table</span><span class="o">=</span><span class="n">tc</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">sites</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">parse_sites</span><span class="p">(</span>
            <span class="n">sites</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">base64_metadata</span><span class="o">=</span><span class="n">base64_metadata</span><span class="p">,</span>
            <span class="n">table</span><span class="o">=</span><span class="n">tc</span><span class="o">.</span><span class="n">sites</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">mutations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">parse_mutations</span><span class="p">(</span>
            <span class="n">mutations</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">base64_metadata</span><span class="o">=</span><span class="n">base64_metadata</span><span class="p">,</span>
            <span class="n">table</span><span class="o">=</span><span class="n">tc</span><span class="o">.</span><span class="n">mutations</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">individuals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">parse_individuals</span><span class="p">(</span>
            <span class="n">individuals</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">base64_metadata</span><span class="o">=</span><span class="n">base64_metadata</span><span class="p">,</span>
            <span class="n">table</span><span class="o">=</span><span class="n">tc</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">populations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># As a convenience we add any populations referenced in the node table.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">max_population</span> <span class="o">=</span> <span class="n">tc</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">max_population</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_population</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">tc</span><span class="o">.</span><span class="n">populations</span><span class="o">.</span><span class="n">add_row</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">parse_populations</span><span class="p">(</span>
            <span class="n">populations</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">base64_metadata</span><span class="o">=</span><span class="n">base64_metadata</span><span class="p">,</span>
            <span class="n">table</span><span class="o">=</span><span class="n">tc</span><span class="o">.</span><span class="n">populations</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">migrations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">parse_migrations</span><span class="p">(</span>
            <span class="n">migrations</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">base64_metadata</span><span class="o">=</span><span class="n">base64_metadata</span><span class="p">,</span>
            <span class="n">table</span><span class="o">=</span><span class="n">tc</span><span class="o">.</span><span class="n">migrations</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="n">tc</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">tc</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>



<span class="k">class</span><span class="w"> </span><span class="nc">TreeIterator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple class providing forward and backward iteration over a tree sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">more_trees</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forward</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forward</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">more_trees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">more_trees</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">more_trees</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">more_trees</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">prev</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">more_trees</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">tree_sequence</span><span class="o">.</span><span class="n">num_trees</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SimpleContainerSequence</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple wrapper to allow arrays of SimpleContainers (e.g. edges, nodes) that have a</span>
<span class="sd">    function allowing access by index (e.g. ts.edge(i), ts.node(i)) to be treated as a</span>
<span class="sd">    python sequence, allowing forward and reverse iteration.</span>

<span class="sd">    To generate a sequence of items in a different order, the ``order`` parameter allows</span>
<span class="sd">    an array of indexes to be passed in, such as returned from np.argsort or np.lexsort.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">getter</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getter</span> <span class="o">=</span> <span class="n">getter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">getter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">index</span><span class="p">:</span> <span class="n">getter</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">getter</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>


<div class="viewcode-block" id="TableMetadataSchemas">
<a class="viewcode-back" href="../../python-api.html#tskit.TableMetadataSchemas">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TableMetadataSchemas</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenience class for returning the schemas of all the tables in a tree sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">node</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The metadata schema of the node table.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">edge</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The metadata schema of the edge table.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">site</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The metadata schema of the site table.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mutation</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The metadata schema of the mutation table.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">migration</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The metadata schema of the migration table.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">individual</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The metadata schema of the individual table.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">population</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The metadata schema of the population table.</span>
<span class="sd">    &quot;&quot;&quot;</span></div>



<div class="viewcode-block" id="TreeSequence">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeSequence</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single tree sequence, as defined by the :ref:`data model &lt;sec_data_model&gt;`.</span>
<span class="sd">    A TreeSequence instance can be created from a set of</span>
<span class="sd">    :ref:`tables &lt;sec_table_definitions&gt;` using</span>
<span class="sd">    :meth:`TableCollection.tree_sequence`, or loaded from a set of text files</span>
<span class="sd">    using :func:`tskit.load_text`, or loaded from a native binary file using</span>
<span class="sd">    :func:`tskit.load`.</span>

<span class="sd">    TreeSequences are immutable. To change the data held in a particular</span>
<span class="sd">    tree sequence, first get the table information as a :class:`TableCollection`</span>
<span class="sd">    instance (using :meth:`.dump_tables`), edit those tables using the</span>
<span class="sd">    :ref:`tables api &lt;sec_tables_api&gt;`, and create a new tree sequence using</span>
<span class="sd">    :meth:`TableCollection.tree_sequence`.</span>

<span class="sd">    The :meth:`.trees` method iterates over all trees in a tree sequence, and</span>
<span class="sd">    the :meth:`.variants` method iterates over all sites and their genotypes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ll_tree_sequence</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span> <span class="o">=</span> <span class="n">ll_tree_sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_immutable_tables</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">metadata_schema_strings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_table_metadata_schemas</span><span class="p">()</span>
        <span class="n">metadata_schema_instances</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">parse_metadata_schema</span><span class="p">(</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">metadata_schema_strings</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">TableMetadataSchemas</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_table_metadata_schemas</span> <span class="o">=</span> <span class="n">TableMetadataSchemas</span><span class="p">(</span><span class="o">**</span><span class="n">metadata_schema_instances</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_population</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_location</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_nodes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_edge</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_inherited_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sites_ancestral_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_derived_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># NOTE: when we&#39;ve implemented read-only access via the underlying</span>
        <span class="c1"># tables we can replace these arrays with reference to the read-only</span>
        <span class="c1"># tables here (and remove the low-level boilerplate).</span>
        <span class="n">llts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_flags</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">individuals_flags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_metadata</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">individuals_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_time</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">nodes_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_flags</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">nodes_flags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_population</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">nodes_population</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_individual</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">nodes_individual</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_metadata</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">nodes_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_left</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">edges_left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_right</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">edges_right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_parent</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">edges_parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_child</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">edges_child</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_metadata</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">edges_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sites_position</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">sites_position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sites_metadata</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">sites_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_site</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">mutations_site</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_node</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">mutations_node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_parent</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">mutations_parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_time</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">mutations_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_metadata</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">mutations_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_left</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">migrations_left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_right</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">migrations_right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_node</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">migrations_node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_source</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">migrations_source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_dest</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">migrations_dest</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_time</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">migrations_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_metadata</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">migrations_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_populations_metadata</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">populations_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indexes_edge_insertion_order</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">indexes_edge_insertion_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indexes_edge_removal_order</span> <span class="o">=</span> <span class="n">llts</span><span class="o">.</span><span class="n">indexes_edge_removal_order</span>

    <span class="c1"># Implement the pickle protocol for TreeSequence</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">tables</span>

<div class="viewcode-block" id="TreeSequence.equals">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.equals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">equals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">ignore_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_timestamps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_tables</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_reference_sequence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if  `self` and `other` are equal. Uses the underlying table</span>
<span class="sd">        equality, see :meth:`TableCollection.equals` for details and options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">tables</span><span class="p">,</span>
            <span class="n">ignore_metadata</span><span class="o">=</span><span class="n">ignore_metadata</span><span class="p">,</span>
            <span class="n">ignore_ts_metadata</span><span class="o">=</span><span class="n">ignore_ts_metadata</span><span class="p">,</span>
            <span class="n">ignore_provenance</span><span class="o">=</span><span class="n">ignore_provenance</span><span class="p">,</span>
            <span class="n">ignore_timestamps</span><span class="o">=</span><span class="n">ignore_timestamps</span><span class="p">,</span>
            <span class="n">ignore_tables</span><span class="o">=</span><span class="n">ignore_tables</span><span class="p">,</span>
            <span class="n">ignore_reference_sequence</span><span class="o">=</span><span class="n">ignore_reference_sequence</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ll_tree_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ll_tree_sequence</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_ll_tree_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span>

<div class="viewcode-block" id="TreeSequence.aslist">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.aslist">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">aslist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the trees in this tree sequence as a list. Each tree is</span>
<span class="sd">        represented by a different instance of :class:`Tree`. As such, this</span>
<span class="sd">        method is inefficient and may use a large amount of memory, and should</span>
<span class="sd">        not be used when performance is a consideration. The :meth:`.trees`</span>
<span class="sd">        method is the recommended way to efficiently iterate over the trees</span>
<span class="sd">        in a tree sequence.</span>

<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned trees. For example ``ts.aslist(sample_lists=True)`` will result</span>
<span class="sd">            in a list of :class:`Tree` instances created with ``sample_lists=True``.</span>
<span class="sd">        :return: A list of the trees in this tree sequence.</span>
<span class="sd">        :rtype: list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">tree</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)]</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">file_or_path</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">skip_tables</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_reference_sequence</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">file</span><span class="p">,</span> <span class="n">local_file</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">convert_file_like_to_open_file</span><span class="p">(</span><span class="n">file_or_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">TreeSequence</span><span class="p">()</span>
            <span class="n">ts</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                <span class="n">file</span><span class="p">,</span>
                <span class="n">skip_tables</span><span class="o">=</span><span class="n">skip_tables</span><span class="p">,</span>
                <span class="n">skip_reference_sequence</span><span class="o">=</span><span class="n">skip_reference_sequence</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">TreeSequence</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">tskit</span><span class="o">.</span><span class="n">FileFormatError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">raise_known_file_format_errors</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">local_file</span><span class="p">:</span>
                <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">load_tables</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tables</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">build_indexes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">TreeSequence</span><span class="p">()</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">load_tables</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">_ll_tables</span><span class="p">,</span> <span class="n">build_indexes</span><span class="o">=</span><span class="n">build_indexes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TreeSequence</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

<div class="viewcode-block" id="TreeSequence.dump">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.dump">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_or_path</span><span class="p">,</span> <span class="n">zlib_compression</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the tree sequence to the specified path or file object.</span>

<span class="sd">        :param str file_or_path: The file object or path to write the TreeSequence to.</span>
<span class="sd">        :param bool zlib_compression: This parameter is deprecated and ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">zlib_compression</span><span class="p">:</span>
            <span class="c1"># Note: the msprime CLI before version 1.0 uses this option, so we need</span>
            <span class="c1"># to keep it indefinitely.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The zlib_compression option is no longer supported and is ignored&quot;</span><span class="p">,</span>
                <span class="ne">RuntimeWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">file</span><span class="p">,</span> <span class="n">local_file</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">convert_file_like_to_open_file</span><span class="p">(</span><span class="n">file_or_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">local_file</span><span class="p">:</span>
                <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reference_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`.ReferenceSequence` associated with this :class:`.TreeSequence`</span>
<span class="sd">        if one is defined (see :meth:`.TreeSequence.has_reference_sequence`),</span>
<span class="sd">        or None otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_reference_sequence</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">ReferenceSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">reference_sequence</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="TreeSequence.has_reference_sequence">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.has_reference_sequence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_reference_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if this :class:`.TreeSequence` has an associated</span>
<span class="sd">        :ref:`reference sequence&lt;sec_data_model_reference_sequence&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">has_reference_sequence</span><span class="p">())</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tables_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary mapping names to tables in the</span>
<span class="sd">        underlying :class:`.TableCollection`. Equivalent to calling</span>
<span class="sd">        ``ts.tables.table_name_map``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">table_name_map</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an immutable view of the tables underlying this tree sequence.</span>

<span class="sd">        This view shares the same data as the TreeSequence (zero-copy).</span>
<span class="sd">        Use :meth:`.dump_tables` for a modifiable copy.</span>

<span class="sd">        Note that if tskit was built with Numpy 1, this method acts as</span>
<span class="sd">        :meth:`.dump_tables` and returns a mutable TableCollection.</span>

<span class="sd">        :return: An immutable view of the TableCollection underlying this tree sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">HAS_NUMPY_2</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Immutable table views require tskit to be built against NumPy 2.0 or &quot;</span>
                <span class="s2">&quot;newer. Falling back to returning a mutable TableCollection.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_immutable_tables</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_immutable_tables</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">ImmutableTableCollection</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_immutable_tables</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total number of bytes required to store the data</span>
<span class="sd">        in this tree sequence. Note that this may not be equal to</span>
<span class="sd">        the actual memory footprint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">nbytes</span>

<div class="viewcode-block" id="TreeSequence.dump_tables">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.dump_tables">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dump_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a modifiable copy of the :class:`tables&lt;TableCollection&gt;` defining</span>
<span class="sd">        this tree sequence.</span>

<span class="sd">        :return: A :class:`TableCollection` containing all tables underlying</span>
<span class="sd">            the tree sequence.</span>
<span class="sd">        :rtype: TableCollection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ll_tables</span> <span class="o">=</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">(</span><span class="n">ll_tables</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">TableCollection</span><span class="p">(</span><span class="n">ll_tables</span><span class="o">=</span><span class="n">ll_tables</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.link_ancestors">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.link_ancestors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">link_ancestors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="p">,</span> <span class="n">ancestors</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equivalent to :meth:`TableCollection.link_ancestors`; see that method for full</span>
<span class="sd">        documentation and parameter semantics.</span>

<span class="sd">        :param list[int] samples: Node IDs to retain as samples.</span>
<span class="sd">        :param list[int] ancestors: Node IDs to treat as ancestors.</span>
<span class="sd">        :return: An :class:`tables.EdgeTable` containing the genealogical links between</span>
<span class="sd">            the supplied ``samples`` and ``ancestors``.</span>
<span class="sd">        :rtype: tables.EdgeTable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">ancestors</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">ancestors</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">ll_edge_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">link_ancestors</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">ancestors</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">EdgeTable</span><span class="p">(</span><span class="n">ll_table</span><span class="o">=</span><span class="n">ll_edge_table</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.dump_text">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.dump_text">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dump_text</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mutations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">individuals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">populations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">migrations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">provenances</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
        <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf8&quot;</span><span class="p">,</span>
        <span class="n">base64_metadata</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes a text representation of the tables underlying the tree sequence</span>
<span class="sd">        to the specified connections.</span>

<span class="sd">        If Base64 encoding is not used, then metadata will be saved directly, possibly</span>
<span class="sd">        resulting in errors reading the tables back in if metadata includes whitespace.</span>

<span class="sd">        :param io.TextIOBase nodes: The file-like object (having a .write() method) to</span>
<span class="sd">            write the NodeTable to.</span>
<span class="sd">        :param io.TextIOBase edges: The file-like object to write the EdgeTable to.</span>
<span class="sd">        :param io.TextIOBase sites: The file-like object to write the SiteTable to.</span>
<span class="sd">        :param io.TextIOBase mutations: The file-like object to write the</span>
<span class="sd">            MutationTable to.</span>
<span class="sd">        :param io.TextIOBase individuals: The file-like object to write the</span>
<span class="sd">            IndividualTable to.</span>
<span class="sd">        :param io.TextIOBase populations: The file-like object to write the</span>
<span class="sd">            PopulationTable to.</span>
<span class="sd">        :param io.TextIOBase migrations: The file-like object to write the</span>
<span class="sd">            MigrationTable to.</span>
<span class="sd">        :param io.TextIOBase provenances: The file-like object to write the</span>
<span class="sd">            ProvenanceTable to.</span>
<span class="sd">        :param int precision: The number of digits of precision.</span>
<span class="sd">        :param str encoding: Encoding used for text representation.</span>
<span class="sd">        :param bool base64_metadata: Only used if a schema is not present on each table</span>
<span class="sd">            being dumped. If True, metadata is encoded using Base64</span>
<span class="sd">            encoding; otherwise, as plain text.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">text_formats</span><span class="o">.</span><span class="n">dump_text</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span>
            <span class="n">sites</span><span class="o">=</span><span class="n">sites</span><span class="p">,</span>
            <span class="n">mutations</span><span class="o">=</span><span class="n">mutations</span><span class="p">,</span>
            <span class="n">individuals</span><span class="o">=</span><span class="n">individuals</span><span class="p">,</span>
            <span class="n">populations</span><span class="o">=</span><span class="n">populations</span><span class="p">,</span>
            <span class="n">migrations</span><span class="o">=</span><span class="n">migrations</span><span class="p">,</span>
            <span class="n">provenances</span><span class="o">=</span><span class="n">provenances</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">base64_metadata</span><span class="o">=</span><span class="n">base64_metadata</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.__str__">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.__str__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a plain text summary of the contents of a tree sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts_rows</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;Trees&quot;</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">format_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)],</span>
            <span class="p">[</span><span class="s2">&quot;Sequence Length&quot;</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">format_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)],</span>
            <span class="p">[</span><span class="s2">&quot;Time Units&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_units</span><span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;Sample Nodes&quot;</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">format_number</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">)],</span>
            <span class="p">[</span><span class="s2">&quot;Total Size&quot;</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">naturalsize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbytes</span><span class="p">)],</span>
        <span class="p">]</span>
        <span class="n">header</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Table&quot;</span><span class="p">,</span> <span class="s2">&quot;Rows&quot;</span><span class="p">,</span> <span class="s2">&quot;Size&quot;</span><span class="p">,</span> <span class="s2">&quot;Has Metadata&quot;</span><span class="p">]</span>
        <span class="n">table_rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">table</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">table_name_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">table_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">name</span><span class="o">.</span><span class="n">capitalize</span><span class="p">(),</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">util</span><span class="o">.</span><span class="n">format_number</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span><span class="w"> </span><span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">util</span><span class="o">.</span><span class="n">naturalsize</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">nbytes</span><span class="p">),</span>
                    <span class="p">(</span>
                        <span class="s2">&quot;Yes&quot;</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="s2">&quot;metadata&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">metadata</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
                        <span class="k">else</span> <span class="s2">&quot;No&quot;</span>
                    <span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">unicode_table</span><span class="p">(</span><span class="n">ts_rows</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;TreeSequence&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">util</span><span class="o">.</span><span class="n">unicode_table</span><span class="p">(</span>
            <span class="n">table_rows</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence._repr_html_">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence._repr_html_">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an html summary of a tree sequence. Called by jupyter notebooks</span>
<span class="sd">        to render a TreeSequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">tree_sequence_html</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="c1"># num_samples was originally called sample_size, and so we must keep sample_size</span>
    <span class="c1"># around as a deprecated alias.</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of sample nodes in this tree sequence. This is also the</span>
<span class="sd">        number of sample nodes in each tree.</span>

<span class="sd">        :return: The number of sample nodes in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_samples</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">table_metadata_schemas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TableMetadataSchemas</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The set of metadata schemas for the tables in this tree sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table_metadata_schemas</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sample_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for num_samples</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_sample_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for num_samples</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">file_uuid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_file_uuid</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">discrete_genome</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if all genome coordinates in this TreeSequence are</span>
<span class="sd">        discrete integer values. This is true iff all the following are true:</span>

<span class="sd">        - The sequence length is discrete</span>
<span class="sd">        - All site positions are discrete</span>
<span class="sd">        - All left and right edge coordinates are discrete</span>
<span class="sd">        - All migration left and right coordinates are discrete</span>

<span class="sd">        :return: True if this TreeSequence uses discrete genome coordinates.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_discrete_genome</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">discrete_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if all time coordinates in this TreeSequence are</span>
<span class="sd">        discrete integer values. This is true iff all the following are true:</span>

<span class="sd">        - All node times are discrete</span>
<span class="sd">        - All mutation times are discrete</span>
<span class="sd">        - All migration times are discrete</span>

<span class="sd">        Note that ``tskit.UNKNOWN_TIME`` counts as discrete.</span>

<span class="sd">        :return: True if this TreeSequence uses discrete time coordinates.</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_discrete_time</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">min_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the min time in this tree sequence. This is the minimum</span>
<span class="sd">        of the node times and mutation times.</span>

<span class="sd">        Note that mutation times with the value ``tskit.UNKNOWN_TIME``</span>
<span class="sd">        are ignored.</span>

<span class="sd">        :return: The min time of the nodes and mutations in this tree sequence.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_min_time</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">max_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the max time in this tree sequence. This is the maximum</span>
<span class="sd">        of the node times and mutation times.</span>

<span class="sd">        Note that mutation times with the value ``tskit.UNKNOWN_TIME``</span>
<span class="sd">        are ignored.</span>

<span class="sd">        :return: The max time of the nodes and mutations in this tree sequence.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_max_time</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sequence_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the sequence length in this tree sequence. This defines the</span>
<span class="sd">        genomic scale over which tree coordinates are defined. Given a</span>
<span class="sd">        tree sequence with a sequence length :math:`L`, the constituent</span>
<span class="sd">        trees will be defined over the half-closed interval</span>
<span class="sd">        :math:`[0, L)`. Each tree then covers some subset of this</span>
<span class="sd">        interval --- see :attr:`tskit.Tree.interval` for details.</span>

<span class="sd">        :return: The length of the sequence in this tree sequence in bases.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sequence_length</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_sequence_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_sequence_length</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The decoded metadata for this TreeSequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_schema</span><span class="o">.</span><span class="n">decode_row</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_metadata</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metadata_schema</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">MetadataSchema</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`tskit.MetadataSchema` for this TreeSequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">metadata_module</span><span class="o">.</span><span class="n">parse_metadata_schema</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_metadata_schema</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time_units</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String describing the units of the time dimension for this TreeSequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_time_units</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`edges &lt;sec_edge_table_definition&gt;` in this</span>
<span class="sd">        tree sequence.</span>

<span class="sd">        :return: The number of edges in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_edges</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.num_trees</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of distinct trees in this tree sequence. This</span>
<span class="sd">        is equal to the number of trees returned by the :meth:`.trees`</span>
<span class="sd">        method.</span>

<span class="sd">        :return: The number of trees in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_trees</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.num_sites</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_sites</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`sites &lt;sec_site_table_definition&gt;` in</span>
<span class="sd">        this tree sequence.</span>

<span class="sd">        :return: The number of sites in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_sites</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.num_mutations</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_mutations</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`mutations &lt;sec_mutation_table_definition&gt;`</span>
<span class="sd">        in this tree sequence.</span>

<span class="sd">        :return: The number of mutations in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_mutations</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.num_nodes</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`individuals &lt;sec_individual_table_definition&gt;` in</span>
<span class="sd">        this tree sequence.</span>

<span class="sd">        :return: The number of individuals in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_individuals</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`nodes &lt;sec_node_table_definition&gt;` in</span>
<span class="sd">        this tree sequence.</span>

<span class="sd">        :return: The number of nodes in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_nodes</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_provenances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`provenances &lt;sec_provenance_table_definition&gt;`</span>
<span class="sd">        in this tree sequence.</span>

<span class="sd">        :return: The number of provenances in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_provenances</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_populations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`populations &lt;sec_population_table_definition&gt;`</span>
<span class="sd">        in this tree sequence.</span>

<span class="sd">        :return: The number of populations in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_populations</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">num_migrations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of :ref:`migrations &lt;sec_migration_table_definition&gt;`</span>
<span class="sd">        in this tree sequence.</span>

<span class="sd">        :return: The number of migrations in this tree sequence.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_num_migrations</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">max_root_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the time of the oldest root in any of the trees in this tree sequence.</span>
<span class="sd">        This is usually equal to ``np.max(ts.tables.nodes.time)`` but may not be</span>
<span class="sd">        since there can be non-sample nodes that are not present in any tree. Note that</span>
<span class="sd">        isolated samples are also defined as roots (so there can be a max_root_time</span>
<span class="sd">        even in a tree sequence with no edges).</span>

<span class="sd">        :return: The maximum time of a root in this tree sequence.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        :raises ValueError: If there are no samples in the tree, and hence no roots (as</span>
<span class="sd">            roots are defined by the ends of the upward paths from the set of samples).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;max_root_time is not defined in a tree sequence with 0 samples&quot;</span>
            <span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_time</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Edges are guaranteed to be listed in parent-time order, so we can get the</span>
            <span class="c1"># last one to get the oldest root</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># However, we can have situations where there is a sample older than a</span>
            <span class="c1"># &#39;proper&#39; root</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_time</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ret</span>

<div class="viewcode-block" id="TreeSequence.migrations">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.migrations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">migrations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the</span>
<span class="sd">        :ref:`migrations &lt;sec_migration_table_definition&gt;` in this tree sequence.</span>

<span class="sd">        Migrations are returned in nondecreasing order of the ``time`` value.</span>

<span class="sd">        :return: An iterable sequence of all migrations.</span>
<span class="sd">        :rtype: Sequence(:class:`.Migration`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">migration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_migrations</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.individuals">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.individuals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the</span>
<span class="sd">        :ref:`individuals &lt;sec_individual_table_definition&gt;` in this tree sequence.</span>

<span class="sd">        :return: An iterable sequence of all individuals.</span>
<span class="sd">        :rtype: Sequence(:class:`.Individual`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individual</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.nodes">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.nodes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the :ref:`nodes &lt;sec_node_table_definition&gt;`</span>
<span class="sd">        in this tree sequence.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Although node ids are commonly ordered by node time, this is not a</span>
<span class="sd">            formal tree sequence requirement. If you wish to iterate over nodes in</span>
<span class="sd">            time order, you should therefore use ``order=&quot;timeasc&quot;`` (and wrap the</span>
<span class="sd">            resulting sequence in the standard Python :func:`python:reversed` function</span>
<span class="sd">            if you wish to iterate over older nodes before younger ones)</span>

<span class="sd">        :param str order: The order in which the nodes should be returned: must be</span>
<span class="sd">            one of &quot;id&quot; (default) or &quot;timeasc&quot; (ascending order of time, then by</span>
<span class="sd">            ascending node id, matching the first two ordering requirements of</span>
<span class="sd">            parent nodes in a :meth:`sorted &lt;TableCollection.sort&gt;` edge table).</span>
<span class="sd">        :return: An iterable sequence of all nodes.</span>
<span class="sd">        :rtype: Sequence(:class:`.Node`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;id&quot;</span> <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">order</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;timeasc&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;order must be &quot;id&quot; or &quot;timeasc&quot;&#39;</span><span class="p">)</span>
        <span class="n">odr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;timeasc&quot;</span><span class="p">:</span>
            <span class="n">odr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_time</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">odr</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.edges">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the :ref:`edges &lt;sec_edge_table_definition&gt;`</span>
<span class="sd">        in this tree sequence. Edges are returned in the order required</span>
<span class="sd">        for a :ref:`valid tree sequence &lt;sec_valid_tree_sequence_requirements&gt;`. So,</span>
<span class="sd">        edges are guaranteed to be ordered such that (a) all parents with a</span>
<span class="sd">        given ID are contiguous; (b) edges are returned in non-decreasing</span>
<span class="sd">        order of parent time ago; (c) within the edges for a given parent, edges</span>
<span class="sd">        are sorted first by child ID and then by left coordinate.</span>

<span class="sd">        :return: An iterable sequence of all edges.</span>
<span class="sd">        :rtype: Sequence(:class:`.Edge`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">edgesets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO the order that these records are returned in is not well specified.</span>
        <span class="c1"># Hopefully this does not matter, and we can just state that the ordering</span>
        <span class="c1"># should not be depended on.</span>
        <span class="n">children</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="n">active_edgesets</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">edges_out</span><span class="p">,</span> <span class="n">edges_in</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_diffs</span><span class="p">():</span>
            <span class="c1"># Complete and return any edgesets that are affected by this tree</span>
            <span class="c1"># transition</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">edges_out</span><span class="p">,</span> <span class="n">edges_in</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">active_edgesets</span><span class="p">:</span>
                    <span class="n">edgeset</span> <span class="o">=</span> <span class="n">active_edgesets</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                    <span class="n">edgeset</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">left</span>
                    <span class="n">edgeset</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="n">parent</span><span class="p">])</span>
                    <span class="k">yield</span> <span class="n">edgeset</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges_out</span><span class="p">:</span>
                <span class="n">children</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges_in</span><span class="p">:</span>
                <span class="n">children</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">child</span><span class="p">)</span>
            <span class="c1"># Update the active edgesets</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">edges_out</span><span class="p">,</span> <span class="n">edges_in</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="ow">and</span> <span class="n">edge</span><span class="o">.</span><span class="n">parent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">active_edgesets</span>
                <span class="p">):</span>
                    <span class="n">active_edgesets</span><span class="p">[</span><span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">Edgeset</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="p">[])</span>

        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">active_edgesets</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">edgeset</span> <span class="o">=</span> <span class="n">active_edgesets</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span>
            <span class="n">edgeset</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span>
            <span class="n">edgeset</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">children</span><span class="p">[</span><span class="n">edgeset</span><span class="o">.</span><span class="n">parent</span><span class="p">])</span>
            <span class="k">yield</span> <span class="n">edgeset</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_edge_diffs_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_terminal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">metadata_decoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">decode_row</span>
        <span class="n">edge_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_left</span>
        <span class="n">edge_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_right</span>
        <span class="n">sequence_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="n">in_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes_edge_insertion_order</span>
        <span class="n">out_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes_edge_removal_order</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">left</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="ow">or</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">sequence_length</span><span class="p">:</span>
            <span class="n">edges_out</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">edges_in</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="ow">and</span> <span class="n">edge_right</span><span class="p">[</span><span class="n">out_order</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">==</span> <span class="n">left</span><span class="p">:</span>
                <span class="n">edges_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Edge</span><span class="p">(</span>
                        <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_edge</span><span class="p">(</span><span class="n">out_order</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
                        <span class="nb">id</span><span class="o">=</span><span class="n">out_order</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                        <span class="n">metadata_decoder</span><span class="o">=</span><span class="n">metadata_decoder</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="ow">and</span> <span class="n">edge_left</span><span class="p">[</span><span class="n">in_order</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">==</span> <span class="n">left</span><span class="p">:</span>
                <span class="n">edges_in</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Edge</span><span class="p">(</span>
                        <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_edge</span><span class="p">(</span><span class="n">in_order</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span>
                        <span class="nb">id</span><span class="o">=</span><span class="n">in_order</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                        <span class="n">metadata_decoder</span><span class="o">=</span><span class="n">metadata_decoder</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">sequence_length</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">edge_left</span><span class="p">[</span><span class="n">in_order</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">:</span>
                <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">edge_right</span><span class="p">[</span><span class="n">out_order</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
            <span class="k">yield</span> <span class="n">EdgeDiff</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">edges_out</span><span class="p">,</span> <span class="n">edges_in</span><span class="p">)</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">right</span>

        <span class="k">if</span> <span class="n">include_terminal</span><span class="p">:</span>
            <span class="n">edges_out</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">:</span>
                <span class="n">edges_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Edge</span><span class="p">(</span>
                        <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_edge</span><span class="p">(</span><span class="n">out_order</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
                        <span class="nb">id</span><span class="o">=</span><span class="n">out_order</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                        <span class="n">metadata_decoder</span><span class="o">=</span><span class="n">metadata_decoder</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">yield</span> <span class="n">EdgeDiff</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">edges_out</span><span class="p">,</span> <span class="p">[])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_edge_diffs_reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_terminal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">metadata_decoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">decode_row</span>
        <span class="n">edge_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_left</span>
        <span class="n">edge_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_right</span>
        <span class="n">sequence_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="n">in_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes_edge_removal_order</span>
        <span class="n">out_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes_edge_insertion_order</span>
        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">sequence_length</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">right</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edges_out</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">edges_in</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">edge_left</span><span class="p">[</span><span class="n">out_order</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">edges_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Edge</span><span class="p">(</span>
                        <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_edge</span><span class="p">(</span><span class="n">out_order</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
                        <span class="nb">id</span><span class="o">=</span><span class="n">out_order</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                        <span class="n">metadata_decoder</span><span class="o">=</span><span class="n">metadata_decoder</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">edge_right</span><span class="p">[</span><span class="n">in_order</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">edges_in</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Edge</span><span class="p">(</span>
                        <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_edge</span><span class="p">(</span><span class="n">in_order</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span>
                        <span class="nb">id</span><span class="o">=</span><span class="n">in_order</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                        <span class="n">metadata_decoder</span><span class="o">=</span><span class="n">metadata_decoder</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">edge_right</span><span class="p">[</span><span class="n">in_order</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">edge_left</span><span class="p">[</span><span class="n">out_order</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
            <span class="k">yield</span> <span class="n">EdgeDiff</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">edges_out</span><span class="p">,</span> <span class="n">edges_in</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">left</span>

        <span class="k">if</span> <span class="n">include_terminal</span><span class="p">:</span>
            <span class="n">edges_out</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">edges_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">Edge</span><span class="p">(</span>
                        <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_edge</span><span class="p">(</span><span class="n">out_order</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
                        <span class="nb">id</span><span class="o">=</span><span class="n">out_order</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                        <span class="n">metadata_decoder</span><span class="o">=</span><span class="n">metadata_decoder</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">yield</span> <span class="n">EdgeDiff</span><span class="p">(</span><span class="n">Interval</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">edges_out</span><span class="p">,</span> <span class="p">[])</span>

<div class="viewcode-block" id="TreeSequence.edge_diffs">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.edge_diffs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edge_diffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_terminal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">tskit</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all the :ref:`edges &lt;sec_edge_table_definition&gt;` that</span>
<span class="sd">        are inserted and removed to build the trees as we move from left-to-right along</span>
<span class="sd">        the tree sequence. Each iteration yields a named tuple consisting of 3 values,</span>
<span class="sd">        ``(interval, edges_out, edges_in)``. The first value, ``interval``, is the</span>
<span class="sd">        genomic interval ``(left, right)`` covered by the incoming tree</span>
<span class="sd">        (see :attr:`Tree.interval`). The second, ``edges_out`` is a list of the edges</span>
<span class="sd">        that were just-removed to create the tree covering the interval</span>
<span class="sd">        (hence ``edges_out`` will always be empty for the first tree). The last value,</span>
<span class="sd">        ``edges_in``, is a list of edges that were just</span>
<span class="sd">        inserted to construct the tree covering the current interval.</span>

<span class="sd">        The edges returned within each ``edges_in`` list are ordered by ascending</span>
<span class="sd">        time of the parent node, then ascending parent id, then ascending child id.</span>
<span class="sd">        The edges within each ``edges_out`` list are the reverse order (e.g.</span>
<span class="sd">        descending parent time, parent id, then child_id). This means that within</span>
<span class="sd">        each list, edges with the same parent appear consecutively.</span>

<span class="sd">        The ``direction`` argument can be used to control whether diffs are produced</span>
<span class="sd">        in the forward (left-to-right, increasing genome coordinate value)</span>
<span class="sd">        or reverse (right-to-left, decreasing genome coordinate value) direction.</span>

<span class="sd">        :param bool include_terminal: If False (default), the iterator terminates</span>
<span class="sd">            after the final interval in the tree sequence (i.e., it does not</span>
<span class="sd">            report a final removal of all remaining edges), and the number</span>
<span class="sd">            of iterations will be equal to the number of trees in the tree</span>
<span class="sd">            sequence. If True, an additional iteration takes place, with the last</span>
<span class="sd">            ``edges_out`` value reporting all the edges contained in the final</span>
<span class="sd">            tree (with both ``left`` and ``right`` equal to the sequence length).</span>
<span class="sd">        :param int direction: The direction of travel along the sequence for</span>
<span class="sd">            diffs. Must be one of :data:`.FORWARD` or :data:`.REVERSE`.</span>
<span class="sd">            (Default: :data:`.FORWARD`).</span>
<span class="sd">        :return: An iterator over the (interval, edges_out, edges_in) tuples. This</span>
<span class="sd">            is a named tuple, so the 3 values can be accessed by position</span>
<span class="sd">            (e.g. ``returned_tuple[0]``) or name (e.g. ``returned_tuple.interval``).</span>
<span class="sd">        :rtype: :class:`collections.abc.Iterable`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_diffs_forward</span><span class="p">(</span><span class="n">include_terminal</span><span class="o">=</span><span class="n">include_terminal</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">REVERSE</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_diffs_reverse</span><span class="p">(</span><span class="n">include_terminal</span><span class="o">=</span><span class="n">include_terminal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;direction must be either tskit.FORWARD or tskit.REVERSE&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.sites">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.sites">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the :ref:`sites &lt;sec_site_table_definition&gt;`</span>
<span class="sd">        in this tree sequence. Sites are returned in order of increasing ID</span>
<span class="sd">        (and also position). See the :class:`Site` class for details on</span>
<span class="sd">        the available fields for each site.</span>

<span class="sd">        :return: An iterable sequence of all sites.</span>
<span class="sd">        :rtype: Sequence(:class:`.Site`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">site</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.mutations">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.mutations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all the</span>
<span class="sd">        :ref:`mutations &lt;sec_mutation_table_definition&gt;` in this tree sequence.</span>
<span class="sd">        Mutations are returned in order of nondecreasing site ID.</span>
<span class="sd">        See the :class:`Mutation` class for details on the available fields for</span>
<span class="sd">        each mutation.</span>

<span class="sd">        The returned iterator is equivalent to iterating over all sites</span>
<span class="sd">        and all mutations in each site, i.e.::</span>

<span class="sd">            for site in tree_sequence.sites():</span>
<span class="sd">                for mutation in site.mutations:</span>
<span class="sd">                    yield mutation</span>

<span class="sd">        :return: An iterator over all mutations in this tree sequence.</span>
<span class="sd">        :rtype: iter(:class:`Mutation`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites</span><span class="p">():</span>
            <span class="k">yield from</span> <span class="n">site</span><span class="o">.</span><span class="n">mutations</span></div>


<div class="viewcode-block" id="TreeSequence.populations">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.populations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">populations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the</span>
<span class="sd">        :ref:`populations &lt;sec_population_table_definition&gt;` in this tree sequence.</span>

<span class="sd">        :return: An iterable sequence of all populations.</span>
<span class="sd">        :rtype: Sequence(:class:`.Population`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">population</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.provenances">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.provenances">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">provenances</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterable sequence of all the</span>
<span class="sd">        :ref:`provenances &lt;sec_provenance_table_definition&gt;` in this tree sequence.</span>

<span class="sd">        :return: An iterable sequence of all provenances.</span>
<span class="sd">        :rtype: Sequence(:class:`.Provenance`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SimpleContainerSequence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">provenance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_provenances</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.breakpoints">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.breakpoints">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">breakpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">as_array</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the breakpoints that separate trees along the chromosome, including the</span>
<span class="sd">        two extreme points 0 and L. This is equivalent to::</span>

<span class="sd">            iter([0] + [t.interval.right for t in self.trees()])</span>

<span class="sd">        By default we return an iterator over the breakpoints as Python float objects;</span>
<span class="sd">        if ``as_array`` is True we return them as a numpy array.</span>

<span class="sd">        Note that the ``as_array`` form will be more efficient and convenient in most</span>
<span class="sd">        cases; the default iterator behaviour is mainly kept to ensure compatibility</span>
<span class="sd">        with existing code.</span>

<span class="sd">        :param bool as_array: If True, return the breakpoints as a numpy array.</span>
<span class="sd">        :return: The breakpoints defined by the tree intervals along the sequence.</span>
<span class="sd">        :rtype: collections.abc.Iterable or numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">breakpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="o">.</span><span class="n">get_breakpoints</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">as_array</span><span class="p">:</span>
            <span class="c1"># Convert to Python floats for backward compatibility.</span>
            <span class="n">breakpoints</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">breakpoints</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">breakpoints</span></div>


<div class="viewcode-block" id="TreeSequence.at">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.at">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tree covering the specified genomic location. The returned tree</span>
<span class="sd">        will have ``tree.interval.left`` &lt;= ``position`` &lt; ``tree.interval.right``.</span>
<span class="sd">        See also :meth:`Tree.seek`.</span>

<span class="sd">        .. include:: substitutions/linear_traversal_warning.rst</span>

<span class="sd">        :param float position: A genomic location.</span>
<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned :class:`Tree`. For example ``ts.at(2.5, sample_lists=True)`` will</span>
<span class="sd">            result in a :class:`Tree` created with ``sample_lists=True``.</span>
<span class="sd">        :return: A new instance of :class:`Tree` positioned to cover the specified</span>
<span class="sd">            genomic location.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tree</span></div>


<div class="viewcode-block" id="TreeSequence.at_index">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.at_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">at_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tree at the specified index. See also :meth:`Tree.seek_index`.</span>

<span class="sd">        .. include:: substitutions/linear_traversal_warning.rst</span>

<span class="sd">        :param int index: The index of the required tree.</span>
<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned :class:`Tree`. For example ``ts.at_index(4, sample_lists=True)``</span>
<span class="sd">            will result in a :class:`Tree` created with ``sample_lists=True``.</span>
<span class="sd">        :return: A new instance of :class:`Tree` positioned at the specified index.</span>
<span class="sd">        :rtype: Tree</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">seek_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tree</span></div>


<div class="viewcode-block" id="TreeSequence.first">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.first">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first tree in this :class:`TreeSequence`. To iterate over all</span>
<span class="sd">        trees in the sequence, use the :meth:`.trees` method.</span>

<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned :class:`Tree`. For example ``ts.first(sample_lists=True)`` will</span>
<span class="sd">            result in a :class:`Tree` created with ``sample_lists=True``.</span>
<span class="sd">        :return: The first tree in this tree sequence.</span>
<span class="sd">        :rtype: :class:`Tree`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tree</span></div>


<div class="viewcode-block" id="TreeSequence.last">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.last">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the last tree in this :class:`TreeSequence`. To iterate over all</span>
<span class="sd">        trees in the sequence, use the :meth:`.trees` method.</span>

<span class="sd">        :param \\**kwargs: Further arguments used as parameters when constructing the</span>
<span class="sd">            returned :class:`Tree`. For example ``ts.first(sample_lists=True)`` will</span>
<span class="sd">            result in a :class:`Tree` created with ``sample_lists=True``.</span>
<span class="sd">        :return: The last tree in this tree sequence.</span>
<span class="sd">        :rtype: :class:`Tree`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">last</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tree</span></div>


<div class="viewcode-block" id="TreeSequence.trees">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.trees">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trees</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tracked_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">sample_lists</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">root_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">sample_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tracked_leaves</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">leaf_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">leaf_lists</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the trees in this tree sequence. Each value</span>
<span class="sd">        returned in this iterator is an instance of :class:`Tree`. Upon</span>
<span class="sd">        successful termination of the iterator, the tree will be in the</span>
<span class="sd">        &quot;cleared&quot; null state.</span>

<span class="sd">        The ``sample_lists`` and ``tracked_samples`` parameters are passed</span>
<span class="sd">        to the :class:`Tree` constructor, and control</span>
<span class="sd">        the options that are set in the returned tree instance.</span>

<span class="sd">        .. warning:: Do not store the results of this iterator in a list!</span>
<span class="sd">           For performance reasons, the same underlying object is used</span>
<span class="sd">           for every tree returned which will most likely lead to unexpected</span>
<span class="sd">           behaviour. If you wish to obtain a list of trees in a tree sequence</span>
<span class="sd">           please use ``ts.aslist()`` instead.</span>

<span class="sd">        :param list tracked_samples: The list of samples to be tracked and</span>
<span class="sd">            counted using the :meth:`Tree.num_tracked_samples` method.</span>
<span class="sd">        :param bool sample_lists: If True, provide more efficient access</span>
<span class="sd">            to the samples beneath a given node using the</span>
<span class="sd">            :meth:`Tree.samples` method.</span>
<span class="sd">        :param int root_threshold: The minimum number of samples that a node</span>
<span class="sd">            must be ancestral to for it to be in the list of roots. By default</span>
<span class="sd">            this is 1, so that isolated samples (representing missing data)</span>
<span class="sd">            are roots. To efficiently restrict the roots of the tree to</span>
<span class="sd">            those subtending meaningful topology, set this to 2. This value</span>
<span class="sd">            is only relevant when trees have multiple roots.</span>
<span class="sd">        :param bool sample_counts: Deprecated since 0.2.4.</span>
<span class="sd">        :return: An iterator over the Trees in this tree sequence.</span>
<span class="sd">        :rtype: collections.abc.Iterable, :class:`Tree`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># tracked_leaves, leaf_counts and leaf_lists are deprecated aliases</span>
        <span class="c1"># for tracked_samples, sample_counts and sample_lists respectively.</span>
        <span class="c1"># These are left over from an older version of the API when leaves</span>
        <span class="c1"># and samples were synonymous.</span>
        <span class="k">if</span> <span class="n">tracked_leaves</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tracked_samples</span> <span class="o">=</span> <span class="n">tracked_leaves</span>
        <span class="k">if</span> <span class="n">leaf_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_counts</span> <span class="o">=</span> <span class="n">leaf_counts</span>
        <span class="k">if</span> <span class="n">leaf_lists</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_lists</span> <span class="o">=</span> <span class="n">leaf_lists</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">tracked_samples</span><span class="o">=</span><span class="n">tracked_samples</span><span class="p">,</span>
            <span class="n">sample_lists</span><span class="o">=</span><span class="n">sample_lists</span><span class="p">,</span>
            <span class="n">root_threshold</span><span class="o">=</span><span class="n">root_threshold</span><span class="p">,</span>
            <span class="n">sample_counts</span><span class="o">=</span><span class="n">sample_counts</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">TreeIterator</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.coiterate">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.coiterate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">coiterate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the pairs of trees for each distinct</span>
<span class="sd">        interval in the specified pair of tree sequences.</span>

<span class="sd">        :param TreeSequence other: The other tree sequence from which to take trees. The</span>
<span class="sd">            sequence length must be the same as the current tree sequence.</span>
<span class="sd">        :param \\**kwargs: Further named arguments that will be passed to the</span>
<span class="sd">            :meth:`.trees` method when constructing the returned trees.</span>

<span class="sd">        :return: An iterator returning successive tuples of the form</span>
<span class="sd">            ``(interval, tree_self, tree_other)``. For example, the first item returned</span>
<span class="sd">            will consist of an tuple of the initial interval, the first tree of the</span>
<span class="sd">            current tree sequence, and the first tree of the ``other`` tree sequence;</span>
<span class="sd">            the ``.left`` attribute of the initial interval will be 0 and the ``.right``</span>
<span class="sd">            attribute will be the smallest non-zero breakpoint of the 2 tree sequences.</span>
<span class="sd">        :rtype: iter(:class:`Interval`, :class:`Tree`, :class:`Tree`)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Tree sequences must be of equal sequence length.&quot;</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="n">trees1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">trees2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">trees</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">tree1</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees1</span><span class="p">)</span>
        <span class="n">tree2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees2</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">right</span> <span class="o">!=</span> <span class="n">L</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">right</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tree1</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">tree2</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">Interval</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">tree1</span><span class="p">,</span> <span class="n">tree2</span>
            <span class="c1"># Advance</span>
            <span class="k">if</span> <span class="n">tree1</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">tree1</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tree2</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">right</span><span class="p">:</span>
                <span class="n">tree2</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">trees2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_check_genomic_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ensure_integer</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">or</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`left` not between zero (inclusive) and sequence length (exclusive)&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="ow">or</span> <span class="n">right</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">right</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;`right` not between zero (exclusive) and sequence length (inclusive)&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`left` must be less than `right`&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ensure_integer</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">left</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="ow">or</span> <span class="n">right</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`left` and `right` must be integers&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Interval</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">Interval</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_haplotypes_array</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">interval</span><span class="p">,</span>
        <span class="n">isolated_as_missing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">missing_data_character</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># return an array of haplotypes and the first and last site positions</span>
        <span class="k">if</span> <span class="n">missing_data_character</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">missing_data_character</span> <span class="o">=</span> <span class="s2">&quot;N&quot;</span>

        <span class="n">start_site</span><span class="p">,</span> <span class="n">stop_site</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span>
                <span class="n">stop_site</span> <span class="o">-</span> <span class="n">start_site</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">missing_int8</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">missing_data_character</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">(</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
            <span class="n">isolated_as_missing</span><span class="o">=</span><span class="n">isolated_as_missing</span><span class="p">,</span>
            <span class="n">left</span><span class="o">=</span><span class="n">interval</span><span class="o">.</span><span class="n">left</span><span class="p">,</span>
            <span class="n">right</span><span class="o">=</span><span class="n">interval</span><span class="o">.</span><span class="n">right</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">alleles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">alleles</span><span class="p">),</span> <span class="n">missing_int8</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">allele</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">alleles</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">allele</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">allele</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s2">&quot;Multi-letter allele or deletion detected at site </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">var</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ascii_allele</span> <span class="o">=</span> <span class="n">allele</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">UnicodeEncodeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s2">&quot;Non-ascii character in allele at site </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">var</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">allele_int8</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">ascii_allele</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">allele_int8</span> <span class="o">==</span> <span class="n">missing_int8</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;The missing data character &#39;</span><span class="si">{}</span><span class="s2">&#39; clashes with an &quot;</span>
                            <span class="s2">&quot;existing allele at site </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">missing_data_character</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                    <span class="n">alleles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">allele_int8</span>
            <span class="n">H</span><span class="p">[:,</span> <span class="n">var</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">id</span> <span class="o">-</span> <span class="n">start_site</span><span class="p">]</span> <span class="o">=</span> <span class="n">alleles</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">genotypes</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="p">(</span><span class="n">start_site</span><span class="p">,</span> <span class="n">stop_site</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="TreeSequence.haplotypes">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.haplotypes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">haplotypes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">isolated_as_missing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">missing_data_character</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">impute_missing_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the strings of haplotypes that result from</span>
<span class="sd">        the trees and mutations in this tree sequence. Each haplotype string</span>
<span class="sd">        is guaranteed to be of the same length. A tree sequence with</span>
<span class="sd">        :math:`n` requested nodes (default: the number of sample nodes) and with</span>
<span class="sd">        :math:`s` sites lying between ``left`` and ``right`` will return a total</span>
<span class="sd">        of :math:`n` strings of :math:`s` alleles concatenated together, where an allele</span>
<span class="sd">        consists of a single ascii character (tree sequences that include alleles</span>
<span class="sd">        which are not a single character in length, or where the character is</span>
<span class="sd">        non-ascii, will raise an error). The first string returned is the</span>
<span class="sd">        haplotype for the first requested node, and so on.</span>

<span class="sd">        The alleles at each site must be represented by single byte characters,</span>
<span class="sd">        (i.e., variants must be single nucleotide polymorphisms, or SNPs), hence</span>
<span class="sd">        the strings returned will all be of length :math:`s`. If the ``left``</span>
<span class="sd">        position is less than or equal to the position of the first site, for a</span>
<span class="sd">        haplotype ``h``, the value of ``h[j]`` will therefore be the observed</span>
<span class="sd">        allelic state at site ``j``.</span>

<span class="sd">        If ``isolated_as_missing`` is True (the default), isolated nodes without</span>
<span class="sd">        mutations directly above them (whether samples or non-samples) will be treated as</span>
<span class="sd">        :ref:`missing data&lt;sec_data_model_missing_data&gt;` and will be</span>
<span class="sd">        represented in the string by the ``missing_data_character``. If</span>
<span class="sd">        instead it is set to False, missing data will be assigned the ancestral state</span>
<span class="sd">        (unless they have mutations directly above them, in which case they will take</span>
<span class="sd">        the most recent derived mutational state for that node). This was the default</span>
<span class="sd">        behaviour in versions prior to 0.2.0. Prior to 0.3.0 the `impute_missing_data`</span>
<span class="sd">        argument controlled this behaviour.</span>

<span class="sd">        It is also possible to provide **non-sample** nodes via the ``samples``</span>
<span class="sd">        argument if you wish to output haplotypes for (e.g.) internal nodes.</span>
<span class="sd">        See also the :meth:`.variants` iterator for site-centric access</span>
<span class="sd">        to genotypes for the requested nodes.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            For large datasets, this method can consume a **very large** amount of</span>
<span class="sd">            memory! To output all the sample data, it is more efficient to iterate</span>
<span class="sd">            over sites rather than over samples.</span>

<span class="sd">        :return: An iterator over the haplotype strings for the samples in</span>
<span class="sd">            this tree sequence.</span>
<span class="sd">        :param bool isolated_as_missing: If True, the allele assigned to</span>
<span class="sd">            missing samples (i.e., isolated samples without mutations) is</span>
<span class="sd">            the ``missing_data_character``. If False,</span>
<span class="sd">            missing samples will be assigned the ancestral state.</span>
<span class="sd">            Default: True.</span>
<span class="sd">        :param str missing_data_character: A single ascii character that will</span>
<span class="sd">            be used to represent missing data.</span>
<span class="sd">            If any normal allele contains this character, an error is raised.</span>
<span class="sd">            Default: &#39;N&#39;.</span>
<span class="sd">        :param list[int] samples: The node IDs for which to output haplotypes. If</span>
<span class="sd">            ``None`` (default), return haplotypes for all the sample nodes in the tree</span>
<span class="sd">            sequence, in the order given by the :meth:`.samples` method. Non-sample</span>
<span class="sd">            nodes may also be provided.</span>
<span class="sd">        :param int left: Haplotype strings will start with the first site at or after</span>
<span class="sd">            this genomic position. If ``None`` (default) start at the first site.</span>
<span class="sd">        :param int right: Haplotype strings will end with the last site before this</span>
<span class="sd">            position. If ``None`` (default) assume ``right`` is the sequence length</span>
<span class="sd">            (i.e. the last character in the string will be the last site in the tree</span>
<span class="sd">            sequence).</span>
<span class="sd">        :param bool impute_missing_data:</span>
<span class="sd">            *Deprecated in 0.3.0. Use ``isolated_as_missing``, but inverting value.</span>
<span class="sd">            Will be removed in a future version*</span>
<span class="sd">        :rtype: collections.abc.Iterable</span>
<span class="sd">        :raises TypeError: if the ``missing_data_character`` or any of the alleles</span>
<span class="sd">            at a site are not a single ascii character.</span>
<span class="sd">        :raises ValueError: if the ``missing_data_character`` exists in one of the</span>
<span class="sd">            alleles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">impute_missing_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The impute_missing_data parameter was deprecated in 0.3.0 and will&quot;</span>
                <span class="s2">&quot; be removed. Use ``isolated_as_missing=False`` instead of&quot;</span>
                <span class="s2">&quot;``impute_missing_data=True``.&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># Only use impute_missing_data if isolated_as_missing has the default value</span>
        <span class="k">if</span> <span class="n">isolated_as_missing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isolated_as_missing</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">impute_missing_data</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_genomic_range</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_haplotypes_array</span><span class="p">(</span>
            <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span>
            <span class="n">isolated_as_missing</span><span class="o">=</span><span class="n">isolated_as_missing</span><span class="p">,</span>
            <span class="n">missing_data_character</span><span class="o">=</span><span class="n">missing_data_character</span><span class="p">,</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">H</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">h</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.variants">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.variants">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">variants</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">isolated_as_missing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alleles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">impute_missing_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the variants between the ``left`` (inclusive)</span>
<span class="sd">        and ``right`` (exclusive) genomic positions in this tree sequence. Each</span>
<span class="sd">        returned :class:`Variant` object has a site, a list of possible allelic</span>
<span class="sd">        states and an array of genotypes for the specified ``samples``. The</span>
<span class="sd">        ``genotypes`` value is a numpy array containing indexes into the</span>
<span class="sd">        ``alleles`` list. By default, this list is generated automatically for</span>
<span class="sd">        each site such that the first entry, ``alleles[0]``, is the ancestral</span>
<span class="sd">        state and subsequent alleles are listed in no</span>
<span class="sd">        particular order. This means that the encoding of alleles in</span>
<span class="sd">        terms of genotype values can vary from site-to-site, which is</span>
<span class="sd">        sometimes inconvenient. It is possible to specify a fixed mapping</span>
<span class="sd">        from allele strings to genotype values using the ``alleles``</span>
<span class="sd">        parameter. For example, if we set ``alleles=(&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;T&quot;)``,</span>
<span class="sd">        this will map allele &quot;A&quot; to 0, &quot;C&quot; to 1 and so on (the</span>
<span class="sd">        :data:`ALLELES_ACGT` constant provides a shortcut for this</span>
<span class="sd">        common mapping).</span>

<span class="sd">        By default, genotypes are generated for all samples. The ``samples``</span>
<span class="sd">        parameter allows us to specify the nodes for which genotypes are</span>
<span class="sd">        generated; output order of genotypes in the returned variants</span>
<span class="sd">        corresponds to the order of the samples in this list. It is also</span>
<span class="sd">        possible to provide **non-sample** nodes as an argument here, if you</span>
<span class="sd">        wish to generate genotypes for (e.g.) internal nodes. Missingness is</span>
<span class="sd">        detected for any requested node (sample or non-sample) when</span>
<span class="sd">        ``isolated_as_missing`` is True: if a node is isolated at a site (i.e.,</span>
<span class="sd">        has no parent and no children in the marginal tree) and has no mutation</span>
<span class="sd">        above it at that site, its genotype will be reported as</span>
<span class="sd">        :data:`MISSING_DATA` (-1). If ``isolated_as_missing`` is False, such</span>
<span class="sd">        nodes are assigned the site&#39;s ancestral allele index.</span>

<span class="sd">        If isolated samples are present at a given site without mutations above them,</span>
<span class="sd">        they are interpreted by default as</span>
<span class="sd">        :ref:`missing data&lt;sec_data_model_missing_data&gt;`, and the genotypes array</span>
<span class="sd">        will contain a special value :data:`MISSING_DATA` (-1) to identify them</span>
<span class="sd">        while the ``alleles`` tuple will end with the value ``None`` (note that this</span>
<span class="sd">        will be the case whether or not we specify a fixed mapping using the</span>
<span class="sd">        ``alleles`` parameter; see the :class:`Variant` class for more details).</span>
<span class="sd">        Alternatively, if ``isolated_as_missing`` is set to to False, such isolated</span>
<span class="sd">        samples will not be treated as missing, and instead assigned the ancestral</span>
<span class="sd">        state (this was the default behaviour in versions prior to 0.2.0). Prior to</span>
<span class="sd">        0.3.0 the `impute_missing_data` argument controlled this behaviour.</span>

<span class="sd">        :param array_like samples: An array of node IDs for which to generate</span>
<span class="sd">            genotypes, or None for all sample nodes. Default: None.</span>
<span class="sd">        :param bool isolated_as_missing: If True, the genotype value assigned to</span>
<span class="sd">            missing samples (i.e., isolated samples without mutations) is</span>
<span class="sd">            :data:`.MISSING_DATA` (-1). If False, missing samples will be</span>
<span class="sd">            assigned the allele index for the ancestral state.</span>
<span class="sd">            Default: True.</span>
<span class="sd">        :param tuple alleles: A tuple of strings defining the encoding of</span>
<span class="sd">            alleles as integer genotype values. At least one allele must be provided.</span>
<span class="sd">            If duplicate alleles are provided, output genotypes will always be</span>
<span class="sd">            encoded as the first occurrence of the allele. If None (the default),</span>
<span class="sd">            the alleles are encoded as they are encountered during genotype</span>
<span class="sd">            generation.</span>
<span class="sd">        :param bool impute_missing_data:</span>
<span class="sd">            *Deprecated in 0.3.0. Use ``isolated_as_missing``, but inverting value.</span>
<span class="sd">            Will be removed in a future version*</span>
<span class="sd">        :param bool copy:</span>
<span class="sd">            If False re-use the same Variant object for each site such that any</span>
<span class="sd">            references held to it are overwritten when the next site is visited.</span>
<span class="sd">            If True return a fresh :class:`Variant` for each site. Default: True.</span>
<span class="sd">        :param int left: Start with the first site at or after</span>
<span class="sd">            this genomic position. If ``None`` (default) start at the first site.</span>
<span class="sd">        :param int right: End with the last site before this position. If ``None``</span>
<span class="sd">            (default) assume ``right`` is the sequence length, so that the last</span>
<span class="sd">            variant corresponds to the last site in the tree sequence.</span>
<span class="sd">        :return: An iterator over all variants in this tree sequence.</span>
<span class="sd">        :rtype: iter(:class:`Variant`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_genomic_range</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">impute_missing_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The impute_missing_data parameter was deprecated in 0.3.0 and will&quot;</span>
                <span class="s2">&quot; be removed. Use ``isolated_as_missing=False`` instead of&quot;</span>
                <span class="s2">&quot;``impute_missing_data=True``.&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># Only use impute_missing_data if isolated_as_missing has the default value</span>
        <span class="k">if</span> <span class="n">isolated_as_missing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isolated_as_missing</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">impute_missing_data</span>
        <span class="k">if</span> <span class="n">copy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># See comments for the Variant type for discussion on why the</span>
        <span class="c1"># present form was chosen.</span>
        <span class="n">variant</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
            <span class="n">isolated_as_missing</span><span class="o">=</span><span class="n">isolated_as_missing</span><span class="p">,</span>
            <span class="n">alleles</span><span class="o">=</span><span class="n">alleles</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">right</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">site_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
                <span class="n">variant</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">site_id</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">variant</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">site_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
                <span class="n">variant</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">site_id</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">variant</span></div>


<div class="viewcode-block" id="TreeSequence.genotype_matrix">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.genotype_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">genotype_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">isolated_as_missing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">alleles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">impute_missing_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an :math:`m \\times n` numpy array of the genotypes in this</span>
<span class="sd">        tree sequence, where :math:`m` is the number of sites and :math:`n`</span>
<span class="sd">        is the number of requested nodes (default: the number of sample nodes).</span>
<span class="sd">        The genotypes are the indexes into the array of ``alleles``, as</span>
<span class="sd">        described for the :class:`Variant` class.</span>

<span class="sd">        It is possible to provide **non-sample** nodes via the ``samples``</span>
<span class="sd">        argument if you wish to generate genotypes for (e.g.) internal nodes.</span>
<span class="sd">        Missingness is detected for any requested node (sample or non-sample)</span>
<span class="sd">        when ``isolated_as_missing`` is True: if a node is isolated at a site</span>
<span class="sd">        (i.e., has no parent and no children in the marginal tree) and has no</span>
<span class="sd">        mutation above it at that site, its genotype will be reported as</span>
<span class="sd">        :data:`MISSING_DATA` (-1).</span>

<span class="sd">        Such nodes are treated as missing data by default. If</span>
<span class="sd">        ``isolated_as_missing`` is set to False, they will not be treated as</span>
<span class="sd">        missing, and will instead be assigned the ancestral state. This was the</span>
<span class="sd">        default behaviour in versions prior to 0.2.0. Prior to 0.3.0 the</span>
<span class="sd">        ``impute_missing_data`` argument controlled this behaviour.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            This method can consume a **very large** amount of memory! If</span>
<span class="sd">            all genotypes are not needed at once, it is usually better to</span>
<span class="sd">            access them sequentially using the :meth:`.variants` iterator.</span>

<span class="sd">        :param array_like samples: An array of node IDs for which to generate</span>
<span class="sd">            genotypes. If ``None`` (default), generate genotypes for all sample</span>
<span class="sd">            nodes. Non-sample nodes may also be provided, in which case genotypes</span>
<span class="sd">            will be generated for those nodes too.</span>
<span class="sd">        :param bool isolated_as_missing: If True, the genotype value assigned to</span>
<span class="sd">            isolated nodes without mutations (samples or non-samples) is</span>
<span class="sd">            :data:`.MISSING_DATA` (-1). If False, such nodes will be</span>
<span class="sd">            assigned the allele index for the ancestral state.</span>
<span class="sd">            Default: True.</span>
<span class="sd">        :param tuple alleles: A tuple of strings describing the encoding of</span>
<span class="sd">            alleles to genotype values. At least one allele must be provided.</span>
<span class="sd">            If duplicate alleles are provided, output genotypes will always be</span>
<span class="sd">            encoded as the first occurrence of the allele. If None (the default),</span>
<span class="sd">            the alleles are encoded as they are encountered during genotype</span>
<span class="sd">            generation.</span>
<span class="sd">        :param bool impute_missing_data:</span>
<span class="sd">            *Deprecated in 0.3.0. Use ``isolated_as_missing``, but inverting value.</span>
<span class="sd">            Will be removed in a future version*</span>

<span class="sd">        :return: The full matrix of genotypes.</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">impute_missing_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;The impute_missing_data parameter was deprecated in 0.3.0 and will&quot;</span>
                <span class="s2">&quot; be removed. Use ``isolated_as_missing=False`` instead of&quot;</span>
                <span class="s2">&quot;``impute_missing_data=True``.&quot;</span><span class="p">,</span>
                <span class="ne">FutureWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># Only use impute_missing_data if isolated_as_missing has the default value</span>
        <span class="k">if</span> <span class="n">isolated_as_missing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isolated_as_missing</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">impute_missing_data</span>

        <span class="n">variant</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">Variant</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
            <span class="n">isolated_as_missing</span><span class="o">=</span><span class="n">isolated_as_missing</span><span class="p">,</span>
            <span class="n">alleles</span><span class="o">=</span><span class="n">alleles</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">num_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span> <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">site_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">):</span>
            <span class="n">variant</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">site_id</span><span class="p">)</span>
            <span class="n">ret</span><span class="p">[</span><span class="n">site_id</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">variant</span><span class="o">.</span><span class="n">genotypes</span>

        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="TreeSequence.alignments">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.alignments">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">alignments</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">reference_sequence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">missing_data_character</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">isolated_as_missing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">left</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">right</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over the full sequence alignments for the defined samples</span>
<span class="sd">        in this tree sequence. Each yielded alignment ``a`` is a string of length</span>
<span class="sd">        ``L`` where the first character is the genomic sequence at the ``start``</span>
<span class="sd">        position in the genome (defaulting to 0) and the last character is the</span>
<span class="sd">        genomic sequence one position before the ``stop`` value (defaulting to the</span>
<span class="sd">        :attr:`.sequence_length` of this tree sequence, which must have</span>
<span class="sd">        :attr:`.discrete_genome` equal to True). By default ``L`` is therefore equal</span>
<span class="sd">        to the :attr:`.sequence_length`, and ``a[j]`` is the nucleotide value at</span>
<span class="sd">        genomic position ``j``.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This is inherently a **zero-based** representation of the sequence</span>
<span class="sd">            coordinate space. Care will be needed when interacting with other</span>
<span class="sd">            libraries and upstream coordinate spaces.</span>


<span class="sd">        The :ref:`sites&lt;sec_data_model_definitions_site&gt;` in a tree sequence will</span>
<span class="sd">        usually only define the variation for a subset of the ``L`` nucleotide</span>
<span class="sd">        positions along the genome, and the remaining positions are filled using</span>
<span class="sd">        a :ref:`reference sequence &lt;sec_data_model_reference_sequence&gt;`.</span>
<span class="sd">        The reference sequence data is defined either via the</span>
<span class="sd">        ``reference_sequence`` parameter to this method, or embedded within</span>
<span class="sd">        with the tree sequence itself via the :attr:`.TreeSequence.reference_sequence`.</span>

<span class="sd">        Site information from the tree sequence takes precedence over the reference</span>
<span class="sd">        sequence so that, for example, at a site with no mutations all samples</span>
<span class="sd">        will have the site&#39;s ancestral state.</span>

<span class="sd">        The reference sequence bases are determined in the following way:</span>

<span class="sd">        - If the ``reference_sequence`` parameter is supplied this will be</span>
<span class="sd">          used, regardless of whether the tree sequence has an embedded</span>
<span class="sd">          reference sequence.</span>
<span class="sd">        - Otherwise, if the tree sequence has an embedded reference sequence,</span>
<span class="sd">          this will be used.</span>
<span class="sd">        - If the ``reference_sequence`` parameter is not specified and</span>
<span class="sd">          there is no embedded reference sequence, ``L`` copies of the</span>
<span class="sd">          ``missing_data_character`` (which defaults to &#39;N&#39;) are used</span>
<span class="sd">          instead.</span>

<span class="sd">        .. warning:: The :class:`.ReferenceSequence` API is preliminary and</span>
<span class="sd">           some behaviours may change in the future. In particular, a</span>
<span class="sd">           tree sequence is currently regarded as having an embedded reference</span>
<span class="sd">           sequence even if it only has some metadata defined. In this case</span>
<span class="sd">           the ``reference_sequence`` parameter will need to be explicitly set.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Two common options for setting a reference sequence are:</span>

<span class="sd">            - Mark them as missing data, by setting</span>
<span class="sd">              ``reference_sequence=&quot;N&quot; * int(ts.sequence_length)``</span>
<span class="sd">            - Fill the gaps with random nucleotides, by setting</span>
<span class="sd">              ``reference_sequence=tskit.random_nucleotides(ts.sequence_length)``.</span>
<span class="sd">              See the :func:`.random_nucleotides` function for more information.</span>

<span class="sd">        .. warning:: Insertions and deletions are not currently supported and</span>
<span class="sd">           the alleles at each site must be represented by</span>
<span class="sd">           single byte characters, (i.e., variants must be single nucleotide</span>
<span class="sd">           polymorphisms, or SNPs).</span>

<span class="sd">        Missing data handling</span>

<span class="sd">        - If ``isolated_as_missing=True`` (default), nodes that are isolated</span>
<span class="sd">          (no parent and no children) are rendered as the missing character across</span>
<span class="sd">          each tree interval. At site positions, the per-site allele overrides the</span>
<span class="sd">          missing character; if a genotype is missing (``-1``), the missing</span>
<span class="sd">          character is retained.</span>
<span class="sd">        - If ``isolated_as_missing=False``, no missing overlay is applied. At sites,</span>
<span class="sd">          genotypes are decoded as usual; at non-sites, bases come from the</span>
<span class="sd">          reference sequence.</span>

<span class="sd">        See also the :meth:`.variants` iterator for site-centric access</span>
<span class="sd">        to sample genotypes and :meth:`.haplotypes` for access to sample sequences</span>
<span class="sd">        at just the sites in the tree sequence.</span>

<span class="sd">        :param str reference_sequence: The reference sequence to fill in</span>
<span class="sd">            gaps between sites in the alignments. If provided, it must be a</span>
<span class="sd">            string of length equal to :attr:`.sequence_length`; the sequence is</span>
<span class="sd">            sliced internally to the requested ``[left, right)`` interval.</span>
<span class="sd">        :param str missing_data_character: A single ascii character that will</span>
<span class="sd">            be used to represent missing data.</span>
<span class="sd">            If any normal allele contains this character, an error is raised.</span>
<span class="sd">            Default: &#39;N&#39;.</span>
<span class="sd">        :param bool isolated_as_missing: If True, treat isolated nodes as missing</span>
<span class="sd">            across the covered tree intervals (see above). If None (default), this</span>
<span class="sd">            is treated as True.</span>
<span class="sd">        :param list[int] samples: The nodes for which to output alignments. If</span>
<span class="sd">            ``None`` (default), return alignments for all sample nodes in the order</span>
<span class="sd">            given by the :meth:`.samples` method. Non-sample nodes are also supported</span>
<span class="sd">            and will be decoded at sites in the same way as samples.</span>
<span class="sd">        :param int left: Alignments will start at this genomic position. If ``None``</span>
<span class="sd">            (default) alignments start at 0.</span>
<span class="sd">        :param int right: Alignments will stop before this genomic position.</span>
<span class="sd">            If ``None`` (default) alignments will continue until the end of the</span>
<span class="sd">            tree sequence.</span>
<span class="sd">        :return: An iterator over the alignment strings for specified samples in</span>
<span class="sd">            this tree sequence, in the order given in ``samples``. Each string has</span>
<span class="sd">            length ``L = right - left``.</span>
<span class="sd">        :rtype: collections.abc.Iterable</span>
<span class="sd">        :raises ValueError: if any genome coordinate in this tree sequence is not</span>
<span class="sd">            discrete, or if the ``reference_sequence`` is not of the correct length.</span>
<span class="sd">        :raises TypeError: if any of the alleles at a site are not a</span>
<span class="sd">            single ascii character.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete_genome</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;sequence alignments only defined for discrete genomes&quot;</span><span class="p">)</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_genomic_range</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">ensure_integer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">missing_data_character</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;N&quot;</span> <span class="k">if</span> <span class="n">missing_data_character</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">missing_data_character</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">isolated_as_missing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isolated_as_missing</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">missing_data_character</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;missing_data_character must be a single character&quot;</span><span class="p">)</span>

        <span class="c1"># Determine the reference sequence for the whole tree sequence</span>
        <span class="n">full_ref</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">reference_sequence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">full_ref</span> <span class="o">=</span> <span class="n">reference_sequence</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_reference_sequence</span><span class="p">():</span>
            <span class="c1"># This may be inefficient - see #1989. However, since we&#39;re</span>
            <span class="c1"># n copies of the reference sequence anyway, this is a relatively</span>
            <span class="c1"># minor tweak. We may also want to recode the below not to use direct</span>
            <span class="c1"># access to the .data attribute, e.g. if we allow reference sequences</span>
            <span class="c1"># to start at non-zero positions</span>
            <span class="n">full_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_sequence</span><span class="o">.</span><span class="n">data</span>

        <span class="k">if</span> <span class="n">full_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">full_ref</span> <span class="o">=</span> <span class="n">missing_data_character</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">full_ref</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The reference sequence must be equal to the tree sequence length&quot;</span>
                <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">ref_bytes</span> <span class="o">=</span> <span class="n">full_ref</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span>
            <span class="n">missing_data_character</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UnicodeEncodeError</span><span class="p">:</span>
            <span class="k">raise</span>

        <span class="n">sample_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span> <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

        <span class="n">flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">decode_alignments</span><span class="p">(</span>
            <span class="n">ref_bytes</span><span class="p">,</span>
            <span class="n">sample_ids</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">left</span><span class="p">),</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">right</span><span class="p">),</span>
            <span class="n">missing_data_character</span><span class="p">,</span>
            <span class="nb">bool</span><span class="p">(</span><span class="n">isolated_as_missing</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="n">span</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">span</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_ids</span><span class="p">)):</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">j</span> <span class="o">*</span> <span class="n">span</span>
            <span class="k">yield</span> <span class="n">flat</span><span class="p">[</span><span class="n">offset</span> <span class="p">:</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">span</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_population</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the length-``num_individuals`` array containing, for each</span>
<span class="sd">        individual, the ``population`` attribute of their nodes, or</span>
<span class="sd">        ``tskit.NULL`` for individuals with no nodes. Errors if any individual</span>
<span class="sd">        has nodes with inconsistent non-NULL populations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_population</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_population</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_individuals_population</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_population</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individual_populations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Undocumented alias for individuals_population to avoid breaking</span>
        <span class="c1"># pre-1.0 pyslim code</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_population</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the length-``num_individuals`` array containing, for each</span>
<span class="sd">        individual, the ``time`` attribute of their nodes or ``np.nan`` for</span>
<span class="sd">        individuals with no nodes. Errors if any individual has nodes with</span>
<span class="sd">        inconsistent times.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_individuals_time</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individual_times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Undocumented alias for individuals_time to avoid breaking</span>
        <span class="c1"># pre-1.0 pyslim code</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_location</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method returning the ``num_individuals x n`` array</span>
<span class="sd">        whose row k-th row contains the ``location`` property of the k-th</span>
<span class="sd">        individual. The method only works if all individuals&#39; locations</span>
<span class="sd">        have the same length (which is ``n``), and errors otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_location</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">individuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">individuals</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">individuals</span><span class="o">.</span><span class="n">location_offset</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Individual locations are not all the same length.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">lens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_location</span> <span class="o">=</span> <span class="n">individuals</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_location</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individual_locations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Undocumented alias for individuals_time to avoid breaking</span>
        <span class="c1"># pre-1.0 pyslim code</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_location</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the bitwise ``flags`` column in the</span>
<span class="sd">        :ref:`sec_individual_table_definition` as a numpy array (dtype=np.uint32).</span>
<span class="sd">        Equivalent to ``ts.tables.individuals.flags`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_flags</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``metadata`` column in the</span>
<span class="sd">        :ref:`sec_individual_table_definition` as a structured numpy array.</span>
<span class="sd">        The returned dtype will depend on the metadata schema used. Only a subset</span>
<span class="sd">        of `struct` metadata schemas are supported.</span>
<span class="sd">        See :ref:`sec_structured_array_metadata` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">individual</span><span class="o">.</span><span class="n">structured_array_from_buffer</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_metadata</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">individuals_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array of node IDs for each individual in the tree sequence.</span>

<span class="sd">        :return: Array of shape (num_individuals, max_ploidy) containing node IDs.</span>
<span class="sd">            Values of -1 indicate unused slots for individuals with ploidy</span>
<span class="sd">            less than the maximum.</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_individuals_nodes</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_individuals_nodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nodes_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``metadata`` column in the</span>
<span class="sd">        :ref:`sec_node_table_definition` as a structured numpy array.</span>
<span class="sd">        The returned dtype will depend on the metadata schema used. Only a subset</span>
<span class="sd">        of `struct` metadata schemas are supported.</span>
<span class="sd">        See :ref:`sec_structured_array_metadata` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">structured_array_from_buffer</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_metadata</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nodes_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``time`` column in the</span>
<span class="sd">        :ref:`sec_node_table_definition` as a numpy array (dtype=np.float64).</span>
<span class="sd">        Equivalent to ``ts.tables.nodes.time`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nodes_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the bitwise ``flags`` column in the</span>
<span class="sd">        :ref:`sec_node_table_definition` as a numpy array (dtype=np.uint32).</span>
<span class="sd">        Equivalent to ``ts.tables.nodes.flags`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_flags</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nodes_population</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``population`` column in the</span>
<span class="sd">        :ref:`sec_node_table_definition` as a numpy array (dtype=np.int32).</span>
<span class="sd">        Equivalent to ``ts.tables.nodes.population`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_population</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nodes_individual</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``individual`` column in the</span>
<span class="sd">        :ref:`sec_node_table_definition` as a numpy array (dtype=np.int32).</span>
<span class="sd">        Equivalent to ``ts.tables.nodes.individual`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes_individual</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges_left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``left`` column in the</span>
<span class="sd">        :ref:`sec_edge_table_definition` as a numpy array (dtype=np.float64).</span>
<span class="sd">        Equivalent to ``ts.tables.edges.left`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_left</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``right`` column in the</span>
<span class="sd">        :ref:`sec_edge_table_definition` as a numpy array (dtype=np.float64).</span>
<span class="sd">        Equivalent to ``ts.tables.edges.right`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_right</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``parent`` column in the</span>
<span class="sd">        :ref:`sec_edge_table_definition` as a numpy array (dtype=np.int32).</span>
<span class="sd">        Equivalent to ``ts.tables.edges.parent`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_parent</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges_child</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``child`` column in the</span>
<span class="sd">        :ref:`sec_edge_table_definition` as a numpy array (dtype=np.int32).</span>
<span class="sd">        Equivalent to ``ts.tables.edges.child`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_child</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``metadata`` column in the</span>
<span class="sd">        :ref:`sec_edge_table_definition` as a structured numpy array.</span>
<span class="sd">        The returned dtype will depend on the metadata schema used. Only a subset</span>
<span class="sd">        of `struct` metadata schemas are supported.</span>
<span class="sd">        See :ref:`sec_structured_array_metadata` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">structured_array_from_buffer</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edges_metadata</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_position</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``position`` column in the</span>
<span class="sd">        :ref:`sec_site_table_definition` as a numpy array (dtype=np.float64).</span>
<span class="sd">        Equivalent to ``ts.tables.sites.position`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sites_position</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_ancestral_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The ``ancestral_state`` column in the</span>
<span class="sd">        :ref:`sec_site_table_definition` as a numpy array (dtype=StringDtype).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">HAS_NUMPY_2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;The sites_ancestral_state property requires numpy 2.0 or later.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sites_ancestral_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sites_ancestral_state</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">sites_ancestral_state_string</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sites_ancestral_state</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sites_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``metadata`` column in the</span>
<span class="sd">        :ref:`sec_site_table_definition` as a structured numpy array.</span>
<span class="sd">        The returned dtype will depend on the metadata schema used. Only a subset</span>
<span class="sd">        of `struct` metadata schemas are supported.</span>
<span class="sd">        See :ref:`sec_structured_array_metadata` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">structured_array_from_buffer</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sites_metadata</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutations_site</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``site`` column in the</span>
<span class="sd">        :ref:`sec_mutation_table_definition` as a numpy array (dtype=np.int32).</span>
<span class="sd">        Equivalent to ``ts.tables.mutations.site`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>

<span class="sd">        .. note::</span>
<span class="sd">            To efficently get an array of the number of mutations per site, you</span>
<span class="sd">            can use ``np.bincount(ts.mutations_site, minlength=ts.num_sites)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_site</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutations_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``node`` column in the</span>
<span class="sd">        :ref:`sec_mutation_table_definition` as a numpy array (dtype=np.int32).</span>
<span class="sd">        Equivalent to ``ts.tables.mutations.node`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_node</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutations_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``parent`` column in the</span>
<span class="sd">        :ref:`sec_mutation_table_definition` as a numpy array (dtype=np.int32).</span>
<span class="sd">        Equivalent to ``ts.tables.mutations.parent`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_parent</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutations_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``time`` column in the</span>
<span class="sd">        :ref:`sec_mutation_table_definition` as a numpy array (dtype=np.float64).</span>
<span class="sd">        Equivalent to ``ts.tables.mutations.time`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutations_derived_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Access to the ``derived_state`` column in the</span>
<span class="sd">        :ref:`sec_mutation_table_definition` as a numpy array (dtype=StringDtype).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">HAS_NUMPY_2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;The mutations_derived_state property requires numpy 2.0 or later.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_derived_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_derived_state</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">mutations_derived_state_string</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_derived_state</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutations_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``metadata`` column in the</span>
<span class="sd">        :ref:`sec_mutation_table_definition` as a structured numpy array.</span>
<span class="sd">        The returned dtype will depend on the metadata schema used. Only a subset</span>
<span class="sd">        of `struct` metadata schemas are supported.</span>
<span class="sd">        See :ref:`sec_structured_array_metadata` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">mutation</span><span class="o">.</span><span class="n">structured_array_from_buffer</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_metadata</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutations_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array of the ID of the edge each mutation sits on in the tree sequence.</span>

<span class="sd">        :return: Array of shape (num_mutations,) containing edge IDs.</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_mutations_edge</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_edge</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutations_inherited_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array of the inherited state for each mutation in the tree sequence.</span>

<span class="sd">        The inherited state for a mutation is the state that existed at the site</span>
<span class="sd">        before the mutation occurred. This is either the ancestral state of the site</span>
<span class="sd">        (if the mutation has no parent) or the derived state of the mutation&#39;s</span>
<span class="sd">        parent mutation (if it has a parent).</span>

<span class="sd">        :return: Array of shape (num_mutations,) containing inherited states.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_tskit</span><span class="o">.</span><span class="n">HAS_NUMPY_2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;The mutations_inherited_state property requires numpy 2.0 or later.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_inherited_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_inherited_state</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">mutations_inherited_state_string</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mutations_inherited_state</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">migrations_left</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``left`` column in the</span>
<span class="sd">        :ref:`sec_migration_table_definition` as a numpy array (dtype=np.float64).</span>
<span class="sd">        Equivalent to ``ts.tables.migrations.left`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_left</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">migrations_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``right`` column in the</span>
<span class="sd">        :ref:`sec_migration_table_definition` as a numpy array (dtype=np.float64).</span>
<span class="sd">        Equivalent to ``ts.tables.migrations.right`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_right</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">migrations_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``node`` column in the</span>
<span class="sd">        :ref:`sec_migration_table_definition` as a numpy array (dtype=np.int32).</span>
<span class="sd">        Equivalent to ``ts.tables.migrations.node`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_node</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">migrations_source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``source`` column in the</span>
<span class="sd">        :ref:`sec_migration_table_definition` as a numpy array (dtype=np.int32).</span>
<span class="sd">        Equivalent to ``ts.tables.migrations.source`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_source</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">migrations_dest</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``dest`` column in the</span>
<span class="sd">        :ref:`sec_migration_table_definition` as a numpy array (dtype=np.int32).</span>
<span class="sd">        Equivalent to ``ts.tables.migrations.dest`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_dest</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">migrations_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``time`` column in the</span>
<span class="sd">        :ref:`sec_migration_table_definition` as a numpy array (dtype=np.float64).</span>
<span class="sd">        Equivalent to ``ts.tables.migrations.time`` (but avoiding the full copy</span>
<span class="sd">        of the table data that accessing ``ts.tables`` currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">migrations_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``metadata`` column in the</span>
<span class="sd">        :ref:`sec_migration_table_definition` as a structured numpy array.</span>
<span class="sd">        The returned dtype will depend on the metadata schema used. Only a subset</span>
<span class="sd">        of `struct` metadata schemas are supported.</span>
<span class="sd">        See :ref:`sec_structured_array_metadata` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">migration</span><span class="o">.</span><span class="n">structured_array_from_buffer</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_migrations_metadata</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">populations_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``metadata`` column in the</span>
<span class="sd">        :ref:`sec_population_table_definition` as a structured numpy array.</span>
<span class="sd">        The returned dtype will depend on the metadata schema used. Only a subset</span>
<span class="sd">        of `struct` metadata schemas are supported.</span>
<span class="sd">        See :ref:`sec_structured_array_metadata` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">structured_array_from_buffer</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_populations_metadata</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">indexes_edge_insertion_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``edge_insertion_order`` column in the</span>
<span class="sd">        :ref:`sec_table_indexes` as a numpy array (dtype=np.int32).</span>
<span class="sd">        Equivalent to ``ts.tables.indexes.edge_insertion_order`` (but avoiding</span>
<span class="sd">        the full copy of the table data that accessing ``ts.tables``</span>
<span class="sd">        currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes_edge_insertion_order</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">indexes_edge_removal_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Efficient access to the ``edge_removal_order`` column in the</span>
<span class="sd">        :ref:`sec_table_indexes` as a numpy array (dtype=np.int32).</span>
<span class="sd">        Equivalent to ``ts.tables.indexes.edge_removal_order`` (but avoiding</span>
<span class="sd">        the full copy of the table data that accessing ``ts.tables``</span>
<span class="sd">        currently entails).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indexes_edge_removal_order</span>

<div class="viewcode-block" id="TreeSequence.individual">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.individual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">individual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`individual &lt;sec_individual_table_definition&gt;`</span>
<span class="sd">        in this tree sequence with the specified ID.  As with python lists, negative</span>
<span class="sd">        IDs can be used to index backwards from the last individual.</span>

<span class="sd">        :rtype: :class:`Individual`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">id_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_index</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">)</span>
        <span class="p">(</span>
            <span class="n">flags</span><span class="p">,</span>
            <span class="n">location</span><span class="p">,</span>
            <span class="n">parents</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">,</span>
            <span class="n">nodes</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_individual</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">Individual</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
            <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">individual</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
            <span class="n">tree_sequence</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ind</span></div>


<div class="viewcode-block" id="TreeSequence.node">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.node">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`node &lt;sec_node_table_definition&gt;` in this tree sequence</span>
<span class="sd">        with the specified ID. As with python lists, negative IDs can be used to</span>
<span class="sd">        index backwards from the last node.</span>

<span class="sd">        :rtype: :class:`Node`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">id_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_index</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">)</span>
        <span class="p">(</span>
            <span class="n">flags</span><span class="p">,</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">population</span><span class="p">,</span>
            <span class="n">individual</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Node</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
            <span class="n">individual</span><span class="o">=</span><span class="n">individual</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Index must be of integer type, not &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="n">length</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">length</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Index out of bounds&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">index</span>

<div class="viewcode-block" id="TreeSequence.edge">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.edge">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`edge &lt;sec_edge_table_definition&gt;` in this tree sequence</span>
<span class="sd">        with the specified ID. As with python lists, negative IDs can be used to</span>
<span class="sd">        index backwards from the last edge.</span>

<span class="sd">        :rtype: :class:`Edge`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">id_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_index</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_edges</span><span class="p">)</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_edge</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Edge</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span>
            <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
            <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">edge</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.migration">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.migration">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">migration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`migration &lt;sec_migration_table_definition&gt;` in this tree</span>
<span class="sd">        sequence with the specified ID. As with python lists, negative IDs can be</span>
<span class="sd">        used to index backwards from the last migration.</span>

<span class="sd">        :rtype: :class:`.Migration`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">id_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_index</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_migrations</span><span class="p">)</span>
        <span class="p">(</span>
            <span class="n">left</span><span class="p">,</span>
            <span class="n">right</span><span class="p">,</span>
            <span class="n">node</span><span class="p">,</span>
            <span class="n">source</span><span class="p">,</span>
            <span class="n">dest</span><span class="p">,</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_migration</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Migration</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span>
            <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span>
            <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
            <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
            <span class="n">dest</span><span class="o">=</span><span class="n">dest</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">migration</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.mutation">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.mutation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mutation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`mutation &lt;sec_mutation_table_definition&gt;` in this tree sequence</span>
<span class="sd">        with the specified ID. As with python lists, negative IDs can be used to</span>
<span class="sd">        index backwards from the last mutation.</span>

<span class="sd">        :rtype: :class:`Mutation`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">id_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_index</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_mutations</span><span class="p">)</span>
        <span class="p">(</span>
            <span class="n">site</span><span class="p">,</span>
            <span class="n">node</span><span class="p">,</span>
            <span class="n">derived_state</span><span class="p">,</span>
            <span class="n">parent</span><span class="p">,</span>
            <span class="n">metadata</span><span class="p">,</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">edge</span><span class="p">,</span>
            <span class="n">inherited_state</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_mutation</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Mutation</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">site</span><span class="o">=</span><span class="n">site</span><span class="p">,</span>
            <span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
            <span class="n">derived_state</span><span class="o">=</span><span class="n">derived_state</span><span class="p">,</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">edge</span><span class="o">=</span><span class="n">edge</span><span class="p">,</span>
            <span class="n">inherited_state</span><span class="o">=</span><span class="n">inherited_state</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">mutation</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.site">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.site">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">site</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`site &lt;sec_site_table_definition&gt;` in this tree sequence</span>
<span class="sd">        with either the specified ID or position. As with python lists, negative IDs</span>
<span class="sd">        can be used to index backwards from the last site.</span>

<span class="sd">        When position is specified instead of site ID, a binary search is done</span>
<span class="sd">        on the list of positions of the sites to try to find a site</span>
<span class="sd">        with the user-specified position.</span>

<span class="sd">        :rtype: :class:`Site`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">id_</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">position</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Site id or position must be provided.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">id_</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">position</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only one of site id or position needs to be provided.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">id_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">position</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Position must be provided as a scalar value.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">position</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">position</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Position is beyond the coordinates defined by sequence length.&quot;</span>
                <span class="p">)</span>
            <span class="n">site_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span>
            <span class="n">id_</span> <span class="o">=</span> <span class="n">site_pos</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">id_</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">site_pos</span><span class="p">)</span> <span class="ow">or</span> <span class="n">site_pos</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">!=</span> <span class="n">position</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There is no site at position </span><span class="si">{</span><span class="n">position</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">id_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_index</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">)</span>
        <span class="n">ll_site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_site</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="n">pos</span><span class="p">,</span> <span class="n">ancestral_state</span><span class="p">,</span> <span class="n">ll_mutations</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">ll_site</span>
        <span class="n">mutations</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mutation</span><span class="p">(</span><span class="n">mut_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">mut_id</span> <span class="ow">in</span> <span class="n">ll_mutations</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Site</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">position</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">ancestral_state</span><span class="o">=</span><span class="n">ancestral_state</span><span class="p">,</span>
            <span class="n">mutations</span><span class="o">=</span><span class="n">mutations</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">site</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.population">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.population">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`population &lt;sec_population_table_definition&gt;`</span>
<span class="sd">        in this tree sequence with the specified ID.  As with python lists, negative</span>
<span class="sd">        IDs can be used to index backwards from the last population.</span>

<span class="sd">        :rtype: :class:`Population`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">id_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_index</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_populations</span><span class="p">)</span>
        <span class="p">(</span><span class="n">metadata</span><span class="p">,)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_population</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Population</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">metadata_decoder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">population</span><span class="o">.</span><span class="n">decode_row</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.provenance">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.provenance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">provenance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the :ref:`provenance &lt;sec_provenance_table_definition&gt;`</span>
<span class="sd">        in this tree sequence with the specified ID.  As with python lists,</span>
<span class="sd">        negative IDs can be used to index backwards from the last provenance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">id_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_index</span><span class="p">(</span><span class="n">id_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_provenances</span><span class="p">)</span>
        <span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_provenance</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Provenance</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span> <span class="n">timestamp</span><span class="o">=</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">record</span><span class="o">=</span><span class="n">record</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">population_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for samples()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="n">population_id</span><span class="p">)</span>

<div class="viewcode-block" id="TreeSequence.samples">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.samples">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">population</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">population_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an array of the sample node IDs in this tree sequence. If</span>
<span class="sd">        `population` is specified, only return sample IDs from that population.</span>
<span class="sd">        It is also possible to restrict samples by time using the parameter</span>
<span class="sd">        `time`. If `time` is a numeric value, only return sample IDs whose node</span>
<span class="sd">        time is approximately equal to the specified time. If `time` is a pair</span>
<span class="sd">        of values of the form `(min_time, max_time)`, only return sample IDs</span>
<span class="sd">        whose node time `t` is in this interval such that `min_time &lt;= t &lt; max_time`.</span>

<span class="sd">        :param int population: The population of interest. If None, do not</span>
<span class="sd">            filter samples by population.</span>
<span class="sd">        :param int population_id: Deprecated alias for ``population``.</span>
<span class="sd">        :param float,tuple time: The time or time interval of interest. If</span>
<span class="sd">            None, do not filter samples by time.</span>
<span class="sd">        :return: A numpy array of the node IDs for the samples of interest,</span>
<span class="sd">            listed in numerical order.</span>
<span class="sd">        :rtype: numpy.ndarray (dtype=np.int32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">population</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">population_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;population_id and population are aliases. Cannot specify both&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">population_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">population</span> <span class="o">=</span> <span class="n">population_id</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_samples</span><span class="p">()</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">population</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`population` must be an integer ID&quot;</span><span class="p">)</span>
            <span class="n">population</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">population</span><span class="p">)</span>
            <span class="n">sample_population</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_population</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">sample_population</span> <span class="o">==</span> <span class="n">population</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># ndmin is set so that scalars are converted into 1d arrays</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">sample_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_time</span><span class="p">[</span><span class="n">samples</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">sample_times</span><span class="p">,</span> <span class="n">time</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">time</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
                <span class="k">if</span> <span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;time_interval max is less than or equal to min.&quot;</span><span class="p">)</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">sample_times</span> <span class="o">&gt;=</span> <span class="n">time</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="n">sample_times</span> <span class="o">&lt;</span> <span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;time must be either a single value or a pair of values &quot;</span>
                    <span class="s2">&quot;(min_time, max_time).&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">samples</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span></div>


<div class="viewcode-block" id="TreeSequence.as_vcf">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.as_vcf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_vcf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the result of :meth:`.write_vcf` as a string.</span>
<span class="sd">        Keyword parameters are as defined in :meth:`.write_vcf`.</span>

<span class="sd">        :return: A VCF encoding of the variants in this tree sequence as a string.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buff</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_vcf</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">buff</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeSequence.write_vcf">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.write_vcf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_vcf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">output</span><span class="p">,</span>
        <span class="n">ploidy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">contig_id</span><span class="o">=</span><span class="s2">&quot;1&quot;</span><span class="p">,</span>
        <span class="n">individuals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">individual_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">position_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">site_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sample_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">isolated_as_missing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">allow_position_zero</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">include_non_sample_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the genetic variation data in this tree sequence to Variant</span>
<span class="sd">        Call Format and write to the specified file-like object.</span>

<span class="sd">        .. seealso: See the :ref:`sec_export_vcf` section for examples</span>
<span class="sd">            and explanations of how we map VCF to the tskit data model.</span>

<span class="sd">        Multiploid samples in the output VCF are generated either using</span>
<span class="sd">        individual information in the data model (see</span>
<span class="sd">        :ref:`sec_individual_table_definition`), or by combining genotypes for</span>
<span class="sd">        adjacent sample nodes using the ``ploidy`` argument. See the</span>
<span class="sd">        :ref:`sec_export_vcf_constructing_gt` section for more details</span>
<span class="sd">        and examples.</span>

<span class="sd">        If individuals are defined in the</span>
<span class="sd">        data model (see :ref:`sec_individual_table_definition`), the genotypes</span>
<span class="sd">        for each of the individual&#39;s nodes are combined into a phased</span>
<span class="sd">        multiploid values at each site. By default, all individuals are</span>
<span class="sd">        included with their sample nodes, individuals with no nodes are</span>
<span class="sd">        omitted. The ``include_non_sample_nodes`` argument can be used to</span>
<span class="sd">        included non-sample nodes in the output VCF.</span>

<span class="sd">        Subsets or permutations of the sample individuals may be specified</span>
<span class="sd">        using the ``individuals`` argument.</span>

<span class="sd">        Mixed-sample individuals (e.g., those associated with one node</span>
<span class="sd">        that is a sample and another that is not) in the data model will</span>
<span class="sd">        only have the sample nodes output by default. However, non-sample</span>
<span class="sd">        nodes can be included using the ``include_non_sample_nodes`` argument.</span>

<span class="sd">        If there are no individuals in the tree sequence,</span>
<span class="sd">        synthetic individuals are created by combining adjacent samples, and</span>
<span class="sd">        the number of samples combined is equal to the ``ploidy`` value (1 by</span>
<span class="sd">        default). For example, if we have a ``ploidy`` of 2 and 6 sample nodes,</span>
<span class="sd">        then we will have 3 diploid samples in the VCF, consisting of the</span>
<span class="sd">        combined genotypes for samples [0, 1], [2, 3] and [4, 5]. If we had</span>
<span class="sd">        genotypes 011110 at a particular variant, then we would output the</span>
<span class="sd">        diploid genotypes 0|1, 1|1 and 1|0 in VCF.</span>

<span class="sd">        Each individual in the output is identified by a string; these are the</span>
<span class="sd">        VCF &quot;sample&quot; names. By default, these are of the form ``tsk_0``,</span>
<span class="sd">        ``tsk_1`` etc, up to the number of individuals, but can be manually</span>
<span class="sd">        specified using the ``individual_names`` argument. We do not check</span>
<span class="sd">        for duplicates in this array, or perform any checks to ensure that</span>
<span class="sd">        the output VCF is well-formed.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The default individual names (VCF sample IDs) are always of</span>
<span class="sd">            the form ``tsk_0``, ``tsk_1``, ..., ``tsk_{N - 1}``, where</span>
<span class="sd">            N is the number of individuals we output. These numbers</span>
<span class="sd">            are **not** necessarily the individual IDs.</span>

<span class="sd">        The REF value in the output VCF is the ancestral allele for a site</span>
<span class="sd">        and ALT values are the remaining alleles. It is important to note,</span>
<span class="sd">        therefore, that for real data this means that the REF value for a given</span>
<span class="sd">        site **may not** be equal to the reference allele. We also do not</span>
<span class="sd">        check that the alleles result in a valid VCF---for example, it is possible</span>
<span class="sd">        to use the tab character as an allele, leading to a broken VCF.</span>

<span class="sd">        The ID value in the output VCF file is the integer ID of the</span>
<span class="sd">        corresponding :ref:`site &lt;sec_site_table_definition&gt;` (``site.id``).</span>
<span class="sd">        These ID values can be utilized to match the contents of the VCF file</span>
<span class="sd">        to the sites in the tree sequence object.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Older code often uses the ``ploidy=2`` argument, because old</span>
<span class="sd">            versions of msprime did not output individual data. Specifying</span>
<span class="sd">            individuals in the tree sequence is more robust, and since tree</span>
<span class="sd">            sequences now  typically contain individuals (e.g., as produced by</span>
<span class="sd">            ``msprime.sim_ancestry( )``), this is not necessary, and the</span>
<span class="sd">            ``ploidy`` argument can safely be removed as part of the process</span>
<span class="sd">            of updating from the msprime 0.x legacy API.</span>

<span class="sd">        :param io.IOBase output: The file-like object to write the VCF output.</span>
<span class="sd">        :param int ploidy: The ploidy of the individuals to be written to</span>
<span class="sd">            VCF. This sample size must be evenly divisible by ploidy. Cannot be</span>
<span class="sd">            used if there is individual data in the tree sequence.</span>
<span class="sd">        :param str contig_id: The value of the CHROM column in the output VCF.</span>
<span class="sd">        :param list(int) individuals: A list containing the individual IDs to</span>
<span class="sd">            corresponding to the VCF samples. Defaults to all individuals</span>
<span class="sd">            associated with sample nodes in the tree sequence.</span>
<span class="sd">            See the {ref}`sec_export_vcf_constructing_gt` section for more</span>
<span class="sd">            details and examples.</span>
<span class="sd">        :param list(str) individual_names: A list of string names to identify</span>
<span class="sd">            individual columns in the VCF. In VCF nomenclature, these are the</span>
<span class="sd">            sample IDs. If specified, this must be a list of strings of</span>
<span class="sd">            length equal to the number of individuals to be output. Note that</span>
<span class="sd">            we do not check the form of these strings in any way, so that is</span>
<span class="sd">            is possible to output malformed VCF (for example, by embedding a</span>
<span class="sd">            tab character within on of the names). The default is to output</span>
<span class="sd">            ``tsk_j`` for the jth individual.</span>
<span class="sd">            See the :ref:`sec_export_vcf_individual_names` for examples</span>
<span class="sd">            and more information.</span>
<span class="sd">        :param position_transform: A callable that transforms the</span>
<span class="sd">            site position values into integer valued coordinates suitable for</span>
<span class="sd">            VCF. The function takes a single positional parameter x and must</span>
<span class="sd">            return an integer numpy array the same dimension as x. By default,</span>
<span class="sd">            this is set to ``numpy.round()`` which will round values to the</span>
<span class="sd">            nearest integer. If the string &quot;legacy&quot; is provided here, the</span>
<span class="sd">            pre 0.2.0 legacy behaviour of rounding values to the nearest integer</span>
<span class="sd">            (starting from 1) and avoiding the output of identical positions</span>
<span class="sd">            by incrementing is used.</span>
<span class="sd">            See the :ref:`sec_export_vcf_modifying_coordinates` for examples</span>
<span class="sd">            and more information.</span>
<span class="sd">        :param site_mask: A numpy boolean array (or something convertable to</span>
<span class="sd">            a numpy boolean array) with num_sites elements, used to mask out</span>
<span class="sd">            sites in the output. If  ``site_mask[j]`` is True, then this</span>
<span class="sd">            site (i.e., the line in the VCF file) will be omitted.</span>
<span class="sd">            See the :ref:`sec_export_vcf_masking_output` for examples</span>
<span class="sd">            and more information.</span>
<span class="sd">        :param sample_mask: A numpy boolean array (or something convertable to</span>
<span class="sd">            a numpy boolean array) with num_samples elements, or a callable</span>
<span class="sd">            that returns such an array, such that if</span>
<span class="sd">            ``sample_mask[j]`` is True, then the genotype for sample ``j``</span>
<span class="sd">            will be marked as missing using a &quot;.&quot;. If ``sample_mask`` is a</span>
<span class="sd">            callable, it must take a single argument and return a boolean</span>
<span class="sd">            numpy array. This function will be called for each (unmasked) site</span>
<span class="sd">            with the corresponding :class:`.Variant` object, allowing</span>
<span class="sd">            for dynamic masks to be generated.</span>
<span class="sd">            See the :ref:`sec_export_vcf_masking_output` for examples</span>
<span class="sd">            and more information.</span>
<span class="sd">        :param bool isolated_as_missing: If True, the genotype value assigned to</span>
<span class="sd">            missing samples (i.e., isolated samples without mutations) is &quot;.&quot;</span>
<span class="sd">            If False, missing samples will be assigned the ancestral allele.</span>
<span class="sd">            See :meth:`.variants` for more information. Default: True.</span>
<span class="sd">        :param bool allow_position_zero: If True allow sites with position zero to be</span>
<span class="sd">            output to the VCF, otherwise if one is present an error will be raised.</span>
<span class="sd">            The VCF spec does not allow for sites at position 0. However, in practise</span>
<span class="sd">            many tools will be fine with this. Default: False.</span>
<span class="sd">        :param bool include_non_sample_nodes: If True, include non-sample nodes</span>
<span class="sd">            in the output VCF. By default, only sample nodes are included.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">allow_position_zero</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">allow_position_zero</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">writer</span> <span class="o">=</span> <span class="n">vcf</span><span class="o">.</span><span class="n">VcfWriter</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">ploidy</span><span class="o">=</span><span class="n">ploidy</span><span class="p">,</span>
            <span class="n">contig_id</span><span class="o">=</span><span class="n">contig_id</span><span class="p">,</span>
            <span class="n">individuals</span><span class="o">=</span><span class="n">individuals</span><span class="p">,</span>
            <span class="n">individual_names</span><span class="o">=</span><span class="n">individual_names</span><span class="p">,</span>
            <span class="n">position_transform</span><span class="o">=</span><span class="n">position_transform</span><span class="p">,</span>
            <span class="n">site_mask</span><span class="o">=</span><span class="n">site_mask</span><span class="p">,</span>
            <span class="n">sample_mask</span><span class="o">=</span><span class="n">sample_mask</span><span class="p">,</span>
            <span class="n">isolated_as_missing</span><span class="o">=</span><span class="n">isolated_as_missing</span><span class="p">,</span>
            <span class="n">allow_position_zero</span><span class="o">=</span><span class="n">allow_position_zero</span><span class="p">,</span>
            <span class="n">include_non_sample_nodes</span><span class="o">=</span><span class="n">include_non_sample_nodes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.write_fasta">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.write_fasta">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_fasta</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">file_or_path</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">wrap_width</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span>
        <span class="n">reference_sequence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">missing_data_character</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">isolated_as_missing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the :meth:`.alignments` for this tree sequence to file in</span>
<span class="sd">        `FASTA &lt;https://en.wikipedia.org/wiki/FASTA_format&gt;`__ format.</span>
<span class="sd">        Please see the :meth:`.alignments` method for details on how</span>
<span class="sd">        reference sequences are handled.</span>

<span class="sd">        Alignments are returned for the</span>
<span class="sd">        :ref:`sample nodes&lt;sec_data_model_definitions&gt;` in this tree</span>
<span class="sd">        sequence, and a sample with node id ``u`` is given the label</span>
<span class="sd">        ``f&quot;n{u}&quot;``, following the same convention as the</span>
<span class="sd">        :meth:`.write_nexus` and :meth:`Tree.as_newick` methods.</span>

<span class="sd">        The ``wrap_width`` parameter controls the maximum width of lines</span>
<span class="sd">        of sequence data in the output. By default this is 60</span>
<span class="sd">        characters in accordance with fasta standard outputs. To turn off</span>
<span class="sd">        line-wrapping of sequences, set ``wrap_width`` = 0.</span>

<span class="sd">        Example usage:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            ts.write_fasta(&quot;output.fa&quot;)</span>

<span class="sd">        :param file_or_path: The file object or path to write the output.</span>
<span class="sd">            Paths can be either strings or :class:`python:pathlib.Path` objects.</span>
<span class="sd">        :param int wrap_width: The number of sequence</span>
<span class="sd">            characters to include on each line in the fasta file, before wrapping</span>
<span class="sd">            to the next line for each sequence, or 0 to turn off line wrapping.</span>
<span class="sd">            (Default=60).</span>
<span class="sd">        :param str reference_sequence: As for the :meth:`.alignments` method.</span>
<span class="sd">        :param str missing_data_character: As for the :meth:`.alignments` method.</span>
<span class="sd">        :param bool isolated_as_missing: As for the :meth:`.alignments` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">text_formats</span><span class="o">.</span><span class="n">write_fasta</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">file_or_path</span><span class="p">,</span>
            <span class="n">wrap_width</span><span class="o">=</span><span class="n">wrap_width</span><span class="p">,</span>
            <span class="n">reference_sequence</span><span class="o">=</span><span class="n">reference_sequence</span><span class="p">,</span>
            <span class="n">missing_data_character</span><span class="o">=</span><span class="n">missing_data_character</span><span class="p">,</span>
            <span class="n">isolated_as_missing</span><span class="o">=</span><span class="n">isolated_as_missing</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.as_fasta">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.as_fasta">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_fasta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the result of :meth:`.write_fasta` as a string.</span>
<span class="sd">        Keyword parameters are as defined in :meth:`.write_fasta`.</span>

<span class="sd">        :return: A FASTA encoding of the alignments in this tree sequence as a string.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buff</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_fasta</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">buff</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeSequence.write_nexus">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.write_nexus">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_nexus</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">file_or_path</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">precision</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">include_trees</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">include_alignments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">reference_sequence</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">missing_data_character</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">isolated_as_missing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a `nexus encoding &lt;https://en.wikipedia.org/wiki/Nexus_file&gt;`_</span>
<span class="sd">        of this tree sequence. By default, tree topologies are included</span>
<span class="sd">        in the output, and sequence data alignments are included by default</span>
<span class="sd">        if this tree sequence has discrete genome coordinates and one or</span>
<span class="sd">        more sites. Inclusion of these sections can be controlled manually</span>
<span class="sd">        using the ``include_trees`` and ``include_alignments`` parameters.</span>

<span class="sd">        Tree topologies and branch lengths are listed</span>
<span class="sd">        sequentially in the TREES block and the spatial location of each tree</span>
<span class="sd">        encoded within the tree name labels. Specifically, a tree spanning</span>
<span class="sd">        the interval :math:`[x, y)`` is given the name ``f&quot;t{x}^{y}&quot;``</span>
<span class="sd">        (See below for a description of the precision at which these spatial</span>
<span class="sd">        coordinates are printed out).</span>

<span class="sd">        The :ref:`sample nodes&lt;sec_data_model_definitions&gt;` in this tree</span>
<span class="sd">        sequence are regarded as taxa, and a sample with node id ``u``</span>
<span class="sd">        is given the label ``f&quot;n{u}&quot;``, following the same convention</span>
<span class="sd">        as the :meth:`Tree.as_newick` method.</span>

<span class="sd">        By default, genome positions are printed out with with sufficient</span>
<span class="sd">        precision for them to be recovered exactly in double precision.</span>
<span class="sd">        If the tree sequence is defined on a :attr:`.discrete_genome`,</span>
<span class="sd">        then positions are written out as integers. Otherwise, 17 digits</span>
<span class="sd">        of precision is used. Branch length precision defaults are handled</span>
<span class="sd">        in the same way as :meth:`.Tree.as_newick`.</span>

<span class="sd">        If the ``precision`` argument is provided, genome positions and</span>
<span class="sd">        branch lengths are printed out with this many digits of precision.</span>

<span class="sd">        For example, here is the nexus encoding of a simple tree sequence</span>
<span class="sd">        with integer times and genome coordinates with three samples</span>
<span class="sd">        and two trees::</span>

<span class="sd">            #NEXUS</span>
<span class="sd">            BEGIN TAXA;</span>
<span class="sd">              DIMENSIONS NTAX=3;</span>
<span class="sd">              TAXLABELS n0 n1 n2;</span>
<span class="sd">            END;</span>
<span class="sd">            BEGIN TREES;</span>
<span class="sd">              TREE t0^2 = [&amp;R] (n0:3,(n1:2,n2:2):1);</span>
<span class="sd">              TREE t2^10 = [&amp;R] (n1:2,(n0:1,n2:1):1);</span>
<span class="sd">            END;</span>

<span class="sd">        If sequence data :meth:`.alignments` are defined for this tree sequence</span>
<span class="sd">        and there is at least one site present, sequence alignment data will also</span>
<span class="sd">        be included by default (this can be suppressed by setting</span>
<span class="sd">        ``include_alignments=False``). For example, this tree sequence has</span>
<span class="sd">        a sequence length of 10, two variable sites and no</span>
<span class="sd">        :ref:`reference sequence&lt;sec_data_model_reference_sequence&gt;`::</span>

<span class="sd">            #NEXUS</span>
<span class="sd">            BEGIN TAXA;</span>
<span class="sd">              DIMENSIONS NTAX=3;</span>
<span class="sd">              TAXLABELS n0 n1 n2;</span>
<span class="sd">            END;</span>
<span class="sd">            BEGIN DATA;</span>
<span class="sd">              DIMENSIONS NCHAR=10;</span>
<span class="sd">              FORMAT DATATYPE=DNA MISSING=?;</span>
<span class="sd">              MATRIX</span>
<span class="sd">                n0 ??G??????T</span>
<span class="sd">                n1 ??A??????C</span>
<span class="sd">                n2 ??A??????C</span>
<span class="sd">              ;</span>
<span class="sd">            END;</span>
<span class="sd">            BEGIN TREES;</span>
<span class="sd">              TREE t0^10 = [&amp;R] (n0:2,(n1:1,n2:1):1);</span>
<span class="sd">            END;</span>

<span class="sd">        Please see the :meth:`.alignments` method for details on how</span>
<span class="sd">        reference sequences are handled.</span>

<span class="sd">        .. note:: Note the default ``missing_data_character`` for this method</span>
<span class="sd">            is &quot;?&quot; rather then &quot;N&quot;, in keeping with common conventions for</span>
<span class="sd">            nexus data. This can be changed using the ``missing_data_character``</span>
<span class="sd">            parameter.</span>

<span class="sd">        .. warning:: :ref:`Missing data&lt;sec_data_model_missing_data&gt;`</span>
<span class="sd">            is not supported for encoding tree topology information</span>
<span class="sd">            as our convention of using trees with multiple roots</span>
<span class="sd">            is not often supported by newick parsers. Thus, the method</span>
<span class="sd">            will raise a ValueError if we try to output trees with</span>
<span class="sd">            multiple roots.</span>

<span class="sd">        .. seealso: See also the :meth:`.as_nexus` method which will</span>
<span class="sd">            return this nexus representation as a string.</span>

<span class="sd">        :param int precision: The numerical precision with which branch lengths</span>
<span class="sd">            and tree positions are printed.</span>
<span class="sd">        :param bool include_trees: True if the tree topology information should</span>
<span class="sd">            be included; False otherwise (default=True).</span>
<span class="sd">        :param bool include_alignments: True if the sequence data alignment information</span>
<span class="sd">            should be included; False otherwise (default=True if sequence alignments</span>
<span class="sd">            are well-defined and the tree sequence contains at least one site).</span>
<span class="sd">        :param str reference_sequence: As for the :meth:`.alignments` method.</span>
<span class="sd">        :param str missing_data_character: As for the :meth:`.alignments` method,</span>
<span class="sd">            but defaults to &quot;?&quot;.</span>
<span class="sd">        :param bool isolated_as_missing: As for the :meth:`.alignments` method.</span>
<span class="sd">        :return: A nexus representation of this :class:`TreeSequence`</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">text_formats</span><span class="o">.</span><span class="n">write_nexus</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">file_or_path</span><span class="p">,</span>
            <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
            <span class="n">include_trees</span><span class="o">=</span><span class="n">include_trees</span><span class="p">,</span>
            <span class="n">include_alignments</span><span class="o">=</span><span class="n">include_alignments</span><span class="p">,</span>
            <span class="n">reference_sequence</span><span class="o">=</span><span class="n">reference_sequence</span><span class="p">,</span>
            <span class="n">missing_data_character</span><span class="o">=</span><span class="n">missing_data_character</span><span class="p">,</span>
            <span class="n">isolated_as_missing</span><span class="o">=</span><span class="n">isolated_as_missing</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.as_nexus">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.as_nexus">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_nexus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the result of :meth:`.write_nexus` as a string.</span>
<span class="sd">        Keyword parameters are as defined in :meth:`.write_nexus`.</span>

<span class="sd">        :return: A nexus encoding of the alignments in this tree sequence as a string.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">buff</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_nexus</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">buff</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span></div>


    <span class="c1"># TODO</span>
    <span class="c1"># (1) Move the definition to text_formats.py</span>
    <span class="c1"># (2) Rename to as_macs and keep to_macs as a deprecated synonym</span>
<div class="viewcode-block" id="TreeSequence.to_macs">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.to_macs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_macs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a `macs encoding &lt;https://github.com/gchen98/macs&gt;`_</span>
<span class="sd">        of this tree sequence.</span>

<span class="sd">        :return: The macs representation of this TreeSequence as a string.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sample_size</span><span class="p">()</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sequence_length</span><span class="p">()</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;COMMAND:</span><span class="se">\t</span><span class="s2">not_macs </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;SEED:</span><span class="se">\t</span><span class="s2">ASEED&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">variant</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variants</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">allele</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">allele</span> <span class="ow">in</span> <span class="n">variant</span><span class="o">.</span><span class="n">alleles</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;macs output only supports single letter alleles&quot;</span><span class="p">)</span>
            <span class="n">bytes_genotypes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">lookup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">ord</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">variant</span><span class="o">.</span><span class="n">alleles</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">bytes_genotypes</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">lookup</span><span class="p">[</span><span class="n">variant</span><span class="o">.</span><span class="n">genotypes</span><span class="p">]</span>
            <span class="n">genotypes</span> <span class="o">=</span> <span class="n">bytes_genotypes</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;SITE:</span><span class="se">\t</span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="se">\t</span><span class="si">{</span><span class="n">variant</span><span class="o">.</span><span class="n">position</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">m</span><span class="si">}</span><span class="se">\t</span><span class="s2">0.0</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">genotypes</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span></div>


<div class="viewcode-block" id="TreeSequence.simplify">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.simplify">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simplify</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">map_nodes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">reduce_to_site_topology</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_populations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">filter_individuals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">filter_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">filter_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">update_sample_flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_unary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_unary_in_individuals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keep_input_roots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">filter_zero_mutation_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Deprecated alias for filter_sites</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a simplified tree sequence that retains only the history of</span>
<span class="sd">        the nodes given in the list ``samples``. If ``map_nodes`` is true,</span>
<span class="sd">        also return a numpy array whose ``u``-th element is the ID of the node</span>
<span class="sd">        in the simplified tree sequence that corresponds to node ``u`` in the</span>
<span class="sd">        original tree sequence, or :data:`tskit.NULL` (-1) if ``u`` is no longer</span>
<span class="sd">        present in the simplified tree sequence.</span>

<span class="sd">        .. note::</span>
<span class="sd">            If you wish to simplify a set of tables that do not satisfy all</span>
<span class="sd">            requirements for building a TreeSequence, then use</span>
<span class="sd">            :meth:`TableCollection.simplify`.</span>

<span class="sd">        If the ``reduce_to_site_topology`` parameter is True, the returned tree</span>
<span class="sd">        sequence will contain only topological information that is necessary to</span>
<span class="sd">        represent the trees that contain sites. If there are zero sites in this</span>
<span class="sd">        tree sequence, this will result in an output tree sequence with zero edges.</span>
<span class="sd">        When the number of sites is greater than zero, every tree in the output</span>
<span class="sd">        tree sequence will contain at least one site. For a given site, the</span>
<span class="sd">        topology of the tree containing that site will be identical</span>
<span class="sd">        (up to node ID remapping) to the topology of the corresponding tree</span>
<span class="sd">        in the input tree sequence.</span>

<span class="sd">        If ``filter_populations``, ``filter_individuals``, ``filter_sites``, or</span>
<span class="sd">        ``filter_nodes`` is True, any of the corresponding objects that are not</span>
<span class="sd">        referenced elsewhere are filtered out. As this is the default behaviour,</span>
<span class="sd">        it is important to realise IDs for these objects may change through</span>
<span class="sd">        simplification. By setting these parameters to False, however, the</span>
<span class="sd">        corresponding tables can be preserved without changes.</span>

<span class="sd">        If ``filter_nodes`` is False, then the output node table will be</span>
<span class="sd">        unchanged except for updating the sample status of nodes and any ID</span>
<span class="sd">        remappings caused by filtering individuals and populations (if the</span>
<span class="sd">        ``filter_individuals`` and ``filter_populations`` options are enabled).</span>
<span class="sd">        Nodes that are in the specified list of ``samples`` will be marked as</span>
<span class="sd">        samples in the output, and nodes that are currently marked as samples</span>
<span class="sd">        in the node table but not in the specified list of ``samples`` will</span>
<span class="sd">        have their :data:`tskit.NODE_IS_SAMPLE` flag cleared. Note also that</span>
<span class="sd">        the order of the ``samples`` list is not meaningful when</span>
<span class="sd">        ``filter_nodes`` is False. In this case, the returned node mapping is</span>
<span class="sd">        always the identity mapping, such that ``a[u] == u`` for all nodes.</span>

<span class="sd">        Setting the ``update_sample_flags`` parameter to False disables the</span>
<span class="sd">        automatic sample status update of nodes (described above) from</span>
<span class="sd">        occuring, making it the responsibility of calling code to keep track of</span>
<span class="sd">        the ultimate sample status of nodes. This is an advanced option, mostly</span>
<span class="sd">        of use when combined with the ``filter_nodes=False``,</span>
<span class="sd">        ``filter_populations=False`` and ``filter_individuals=False`` options,</span>
<span class="sd">        which then guarantees that the node table will not be altered by</span>
<span class="sd">        simplification.</span>

<span class="sd">        :param list[int] samples: A list of node IDs to retain as samples. They</span>
<span class="sd">            need not be nodes marked as samples in the original tree sequence, but</span>
<span class="sd">            will constitute the entire set of samples in the returned tree sequence.</span>
<span class="sd">            If not specified or None, use all nodes marked with the IS_SAMPLE flag.</span>
<span class="sd">            The list may be provided as a numpy array (or array-like) object</span>
<span class="sd">            (dtype=np.int32).</span>
<span class="sd">        :param bool map_nodes: If True, return a tuple containing the resulting</span>
<span class="sd">            tree sequence and a numpy array mapping node IDs in the current tree</span>
<span class="sd">            sequence to their corresponding node IDs in the returned tree sequence.</span>
<span class="sd">            If False (the default), return only the tree sequence object itself.</span>
<span class="sd">        :param bool reduce_to_site_topology: Whether to reduce the topology down</span>
<span class="sd">            to the trees that are present at sites. (Default: False)</span>
<span class="sd">        :param bool filter_populations: If True, remove any populations that are</span>
<span class="sd">            not referenced by nodes after simplification; new population IDs are</span>
<span class="sd">            allocated sequentially from zero. If False, the population table will</span>
<span class="sd">            not be altered in any way. (Default: None, treated as True)</span>
<span class="sd">        :param bool filter_individuals: If True, remove any individuals that are</span>
<span class="sd">            not referenced by nodes after simplification; new individual IDs are</span>
<span class="sd">            allocated sequentially from zero. If False, the individual table will</span>
<span class="sd">            not be altered in any way. (Default: None, treated as True)</span>
<span class="sd">        :param bool filter_sites: If True, remove any sites that are</span>
<span class="sd">            not referenced by mutations after simplification; new site IDs are</span>
<span class="sd">            allocated sequentially from zero. If False, the site table will not</span>
<span class="sd">            be altered in any way. (Default: None, treated as True)</span>
<span class="sd">        :param bool filter_nodes: If True, remove any nodes that are</span>
<span class="sd">            not referenced by edges after simplification. If False, the only</span>
<span class="sd">            potential change to the node table may be to change the node flags</span>
<span class="sd">            (if ``samples`` is specified and different from the existing samples).</span>
<span class="sd">            (Default: None, treated as True)</span>
<span class="sd">        :param bool update_sample_flags: If True, update node flags to so that</span>
<span class="sd">            nodes in the specified list of samples have the NODE_IS_SAMPLE</span>
<span class="sd">            flag after simplification, and nodes that are not in this list</span>
<span class="sd">            do not. (Default: None, treated as True)</span>
<span class="sd">        :param bool keep_unary: If True, preserve unary nodes (i.e., nodes with</span>
<span class="sd">            exactly one child) that exist on the path from samples to root.</span>
<span class="sd">            (Default: False)</span>
<span class="sd">        :param bool keep_unary_in_individuals: If True, preserve unary nodes</span>
<span class="sd">            that exist on the path from samples to root, but only if they are</span>
<span class="sd">            associated with an individual in the individuals table. Cannot be</span>
<span class="sd">            specified at the same time as ``keep_unary``. (Default: ``None``,</span>
<span class="sd">            equivalent to False)</span>
<span class="sd">        :param bool keep_input_roots: Whether to retain history ancestral to the</span>
<span class="sd">            MRCA of the samples. If ``False``, no topology older than the MRCAs of the</span>
<span class="sd">            samples will be included. If ``True`` the roots of all trees in the returned</span>
<span class="sd">            tree sequence will be the same roots as in the original tree sequence.</span>
<span class="sd">            (Default: False)</span>
<span class="sd">        :param bool record_provenance: If True, record details of this call to</span>
<span class="sd">            simplify in the returned tree sequence&#39;s provenance information</span>
<span class="sd">            (Default: True).</span>
<span class="sd">        :param bool filter_zero_mutation_sites: Deprecated alias for ``filter_sites``.</span>
<span class="sd">        :return: The simplified tree sequence, or (if ``map_nodes`` is True)</span>
<span class="sd">            a tuple consisting of the simplified tree sequence and a numpy array</span>
<span class="sd">            mapping source node IDs to their corresponding IDs in the new tree</span>
<span class="sd">            sequence.</span>
<span class="sd">        :rtype: tskit.TreeSequence or (tskit.TreeSequence, numpy.ndarray)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="n">node_map</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span>
            <span class="n">samples</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
            <span class="n">reduce_to_site_topology</span><span class="o">=</span><span class="n">reduce_to_site_topology</span><span class="p">,</span>
            <span class="n">filter_populations</span><span class="o">=</span><span class="n">filter_populations</span><span class="p">,</span>
            <span class="n">filter_individuals</span><span class="o">=</span><span class="n">filter_individuals</span><span class="p">,</span>
            <span class="n">filter_sites</span><span class="o">=</span><span class="n">filter_sites</span><span class="p">,</span>
            <span class="n">filter_nodes</span><span class="o">=</span><span class="n">filter_nodes</span><span class="p">,</span>
            <span class="n">update_sample_flags</span><span class="o">=</span><span class="n">update_sample_flags</span><span class="p">,</span>
            <span class="n">keep_unary</span><span class="o">=</span><span class="n">keep_unary</span><span class="p">,</span>
            <span class="n">keep_unary_in_individuals</span><span class="o">=</span><span class="n">keep_unary_in_individuals</span><span class="p">,</span>
            <span class="n">keep_input_roots</span><span class="o">=</span><span class="n">keep_input_roots</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
            <span class="n">filter_zero_mutation_sites</span><span class="o">=</span><span class="n">filter_zero_mutation_sites</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">new_ts</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">new_ts</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="k">if</span> <span class="n">map_nodes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_ts</span><span class="p">,</span> <span class="n">node_map</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_ts</span></div>


<div class="viewcode-block" id="TreeSequence.delete_sites">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.delete_sites">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">site_ids</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree sequence with the specified sites (and their</span>
<span class="sd">        associated mutations) entirely removed. The site IDs do not need to be in any</span>
<span class="sd">        particular order, and specifying the same ID multiple times does not have any</span>
<span class="sd">        effect (i.e., calling ``tree_sequence.delete_sites([0, 1, 1])`` has the same</span>
<span class="sd">        effect as calling ``tree_sequence.delete_sites([0, 1])``.</span>

<span class="sd">        .. note::</span>
<span class="sd">            To remove only the mutations associated with a site, but keep the site</span>
<span class="sd">            itself, use the :meth:`MutationTable.keep_rows` method.</span>

<span class="sd">        :param list[int] site_ids: A list of site IDs specifying the sites to remove.</span>
<span class="sd">        :param bool record_provenance: If ``True``, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: ``True``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">delete_sites</span><span class="p">(</span><span class="n">site_ids</span><span class="p">,</span> <span class="n">record_provenance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeSequence.delete_intervals">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.delete_intervals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">delete_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree sequence for which information in the</span>
<span class="sd">        specified list of genomic intervals has been deleted. Edges spanning these</span>
<span class="sd">        intervals are truncated or deleted, and sites and mutations falling within</span>
<span class="sd">        them are discarded. Note that it is the information in the intervals that</span>
<span class="sd">        is deleted, not the intervals themselves, so in particular, all samples</span>
<span class="sd">        will be isolated in the deleted intervals.</span>

<span class="sd">        Note that node IDs may change as a result of this operation,</span>
<span class="sd">        as by default :meth:`.simplify` is called on the returned tree sequence</span>
<span class="sd">        to remove redundant nodes. If you wish to map node IDs onto the same</span>
<span class="sd">        nodes before and after this method has been called, specify ``simplify=False``.</span>

<span class="sd">        See also :meth:`.keep_intervals`, :meth:`.ltrim`, :meth:`.rtrim`, and</span>
<span class="sd">        :ref:`missing data&lt;sec_data_model_missing_data&gt;`.</span>

<span class="sd">        :param array_like intervals: A list (start, end) pairs describing the</span>
<span class="sd">            genomic intervals to delete. Intervals must be non-overlapping and</span>
<span class="sd">            in increasing order. The list of intervals must be interpretable as a</span>
<span class="sd">            2D numpy array with shape (N, 2), where N is the number of intervals.</span>
<span class="sd">        :param bool simplify: If True, return a simplified tree sequence where nodes</span>
<span class="sd">            no longer used are discarded. (Default: True).</span>
<span class="sd">        :param bool record_provenance: If ``True``, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: ``True``).</span>
<span class="sd">        :rtype: tskit.TreeSequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">delete_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">simplify</span><span class="p">,</span> <span class="n">record_provenance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeSequence.keep_intervals">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.keep_intervals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">keep_intervals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree sequence which includes only information in</span>
<span class="sd">        the specified list of genomic intervals. Edges are truncated to lie within</span>
<span class="sd">        these intervals, and sites and mutations falling outside these intervals</span>
<span class="sd">        are discarded.  Note that it is the information outside the intervals that</span>
<span class="sd">        is deleted, not the intervals themselves, so in particular, all samples</span>
<span class="sd">        will be isolated outside of the retained intervals.</span>

<span class="sd">        Note that node IDs may change as a result of this operation,</span>
<span class="sd">        as by default :meth:`.simplify` is called on the returned tree sequence</span>
<span class="sd">        to remove redundant nodes. If you wish to map node IDs onto the same</span>
<span class="sd">        nodes before and after this method has been called, specify ``simplify=False``.</span>

<span class="sd">        See also :meth:`.keep_intervals`, :meth:`.ltrim`, :meth:`.rtrim`, and</span>
<span class="sd">        :ref:`missing data&lt;sec_data_model_missing_data&gt;`.</span>

<span class="sd">        :param array_like intervals: A list (start, end) pairs describing the</span>
<span class="sd">            genomic intervals to keep. Intervals must be non-overlapping and</span>
<span class="sd">            in increasing order. The list of intervals must be interpretable as a</span>
<span class="sd">            2D numpy array with shape (N, 2), where N is the number of intervals.</span>
<span class="sd">        :param bool simplify: If True, return a simplified tree sequence where nodes</span>
<span class="sd">            no longer used are discarded. (Default: True).</span>
<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence.</span>
<span class="sd">            (Default: True).</span>
<span class="sd">        :rtype: tskit.TreeSequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">keep_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">simplify</span><span class="p">,</span> <span class="n">record_provenance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeSequence.ltrim">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.ltrim">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ltrim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree sequence with a potentially changed coordinate</span>
<span class="sd">        system, such that empty regions (i.e., those not covered by any edge) at the</span>
<span class="sd">        start of the tree sequence are trimmed away, and the leftmost edge starts at</span>
<span class="sd">        position 0. This affects the reported position of sites and</span>
<span class="sd">        edges. Additionally, sites and their associated mutations to the left of</span>
<span class="sd">        the new zero point are thrown away.</span>

<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">ltrim</span><span class="p">(</span><span class="n">record_provenance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeSequence.rtrim">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.rtrim">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rtrim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree sequence with the ``sequence_length`` property reset</span>
<span class="sd">        so that the sequence ends at the end of the rightmost edge. Additionally, sites</span>
<span class="sd">        and their associated mutations at positions greater than the new</span>
<span class="sd">        ``sequence_length`` are thrown away.</span>

<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">rtrim</span><span class="p">(</span><span class="n">record_provenance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeSequence.trim">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.trim">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree sequence with any empty regions (i.e., those not</span>
<span class="sd">        covered by any edge) on the right and left trimmed away. This may reset both the</span>
<span class="sd">        coordinate system and the ``sequence_length`` property. It is functionally</span>
<span class="sd">        equivalent to :meth:`.rtrim` followed by :meth:`.ltrim`. Sites and their</span>
<span class="sd">        associated mutations in the empty regions are thrown away.</span>

<span class="sd">        :param bool record_provenance: If True, add details of this operation to the</span>
<span class="sd">            provenance information of the returned tree sequence. (Default: True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">record_provenance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeSequence.shift">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.shift">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">sequence_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift the coordinate system (used by edges and sites) of this TableCollection by</span>
<span class="sd">        a given value. Positive values shift the coordinate system to the right, negative</span>
<span class="sd">        values to the left. The sequence length of the tree sequence will be changed by</span>
<span class="sd">        ``value``, unless ``sequence_length`` is given, in which case this will be used</span>
<span class="sd">        for the new sequence length.</span>

<span class="sd">        .. note::</span>
<span class="sd">            By setting ``value=0``, this method will simply return a tree sequence</span>
<span class="sd">            with a new sequence length.</span>

<span class="sd">        :param value: The amount by which to shift the coordinate system.</span>
<span class="sd">        :param sequence_length: The new sequence length of the tree sequence. If</span>
<span class="sd">            ``None`` (default) add ``value`` to the sequence length.</span>
<span class="sd">        :raises ValueError: If the new coordinate system is invalid (e.g., if</span>
<span class="sd">            shifting the coordinate system results in negative coordinates).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span>
            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
            <span class="n">sequence_length</span><span class="o">=</span><span class="n">sequence_length</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeSequence.concatenate">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.concatenate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">concatenate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">node_mappings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">add_populations</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate a set of tree sequences to the right of this one, by shifting</span>
<span class="sd">        their coordinate systems and adding all edges, sites, mutations, and</span>
<span class="sd">        any additional nodes, individuals, or populations needed for these.</span>
<span class="sd">        Concretely, to concatenate an ``other`` tree sequence to ``self``, the value</span>
<span class="sd">        of ``self.sequence_length`` is added to all genomic coordinates in ``other``,</span>
<span class="sd">        and then the concatenated tree sequence  will contain all edges, sites, and</span>
<span class="sd">        mutations in both. Which nodes in ``other`` are treated as &quot;new&quot;, and hence</span>
<span class="sd">        added as well, is controlled by ``node_mappings``. Any individuals to which</span>
<span class="sd">        new nodes belong are added as well.</span>

<span class="sd">        The method uses :meth:`.shift` followed by :meth:`.union`, with</span>
<span class="sd">        ``all_mutations=True``, ``all_edges=True``, and ``check_shared_equality=False``.</span>

<span class="sd">        By default, the samples in current and input tree sequences are assumed to</span>
<span class="sd">        refer to the same nodes, and are matched based on the numerical order of</span>
<span class="sd">        sample node IDs; all other nodes are assumed to be new. This can be</span>
<span class="sd">        changed by providing explicit ``node_mappings`` for each input tree sequence</span>
<span class="sd">        (see below).</span>

<span class="sd">        .. note::</span>
<span class="sd">            To add gaps between the concatenated tree sequences, use :meth:`shift`</span>
<span class="sd">            or to remove gaps, use :meth:`trim` before concatenating.</span>

<span class="sd">        :param TreeSequence \*args: A list of other tree sequences to append to</span>
<span class="sd">            the right of this one.</span>
<span class="sd">        :param Union[list, None] node_mappings: A list of node mappings for each</span>
<span class="sd">            input tree sequence in ``args``. Each should either be an array of</span>
<span class="sd">            integers of the same length as the number of nodes in the equivalent</span>
<span class="sd">            input tree sequence (see :meth:`~TreeSequence.union` for details), or</span>
<span class="sd">            ``None``. If ``None``, only sample nodes are mapped to each other.</span>
<span class="sd">            Default: ``None``, treated as ``[None] * len(args)``.</span>
<span class="sd">        :param bool record_provenance: If True (default), record details of this</span>
<span class="sd">            call to ``concatenate`` in the returned tree sequence&#39;s provenance</span>
<span class="sd">            information (Default: True).</span>
<span class="sd">        :param bool add_populations: If True (default), nodes new to ``self`` will</span>
<span class="sd">            be assigned new population IDs (see :meth:`~TreeSequence.union`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node_mappings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node_mappings</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">add_populations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">add_populations</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node_mappings</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;You must provide the same number of node_mappings as args&quot;</span>
            <span class="p">)</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">drop_index</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">node_mapping</span><span class="p">,</span> <span class="n">other</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_mappings</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node_mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">other_samples</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_samples</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;each `other` must have the same number of samples as `self`&quot;</span>
                    <span class="p">)</span>
                <span class="n">node_mapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">num_nodes</span><span class="p">,</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">node_mapping</span><span class="p">[</span><span class="n">other_samples</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span>
            <span class="n">other_tables</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
            <span class="n">other_tables</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">,</span> <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">sequence_length</span> <span class="o">=</span> <span class="n">other_tables</span><span class="o">.</span><span class="n">sequence_length</span>
            <span class="c1"># NB: should we use a different default for add_populations?</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
                <span class="n">other_tables</span><span class="p">,</span>
                <span class="n">node_mapping</span><span class="o">=</span><span class="n">node_mapping</span><span class="p">,</span>
                <span class="n">check_shared_equality</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># Else checks fail with internal samples</span>
                <span class="n">all_mutations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">all_edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">record_provenance</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">add_populations</span><span class="o">=</span><span class="n">add_populations</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">record_provenance</span><span class="p">:</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="s2">&quot;concatenate&quot;</span><span class="p">,</span>
                <span class="s2">&quot;TODO&quot;</span><span class="p">:</span> <span class="s2">&quot;add concatenate parameters&quot;</span><span class="p">,</span>  <span class="c1"># tricky as both have provenances</span>
            <span class="p">}</span>
            <span class="n">tables</span><span class="o">.</span><span class="n">provenances</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span>
                <span class="n">record</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">provenance</span><span class="o">.</span><span class="n">get_provenance_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeSequence.split_edges">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.split_edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">population</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of this tree sequence in which we replace any</span>
<span class="sd">        edge ``(left, right, parent, child)`` in which</span>
<span class="sd">        ``node_time[child] &lt; time &lt; node_time[parent]`` with two edges</span>
<span class="sd">        ``(left, right, parent, u)`` and ``(left, right, u, child)``,</span>
<span class="sd">        where ``u`` is a newly added node for each intersecting edge.</span>

<span class="sd">        If ``metadata``, ``flags``, or ``population`` are specified, newly</span>
<span class="sd">        added nodes will be assigned these values. Otherwise, default values</span>
<span class="sd">        will be used. The default metadata is an empty dictionary if a metadata</span>
<span class="sd">        schema is defined for the node table, and is an empty byte string</span>
<span class="sd">        otherwise. The default population for the new node is</span>
<span class="sd">        :data:`tskit.NULL`. Newly added have a default ``flags`` value of 0.</span>

<span class="sd">        Any metadata associated with a split edge will be copied to the new edge.</span>

<span class="sd">        .. warning:: This method currently does not support migrations</span>
<span class="sd">            and a error will be raised if the migration table is not</span>
<span class="sd">            empty. Future versions may take migrations that intersect with the</span>
<span class="sd">            edge into account when determining the default population</span>
<span class="sd">            assignments for new nodes.</span>

<span class="sd">        Any mutations lying on the edge whose time is &gt;= ``time`` will have</span>
<span class="sd">        their node value set to ``u``. Note that the time of the mutation is</span>
<span class="sd">        defined as the time of the child node if the mutation&#39;s time is</span>
<span class="sd">        unknown.</span>

<span class="sd">        :param float time: The cutoff time.</span>
<span class="sd">        :param int flags: The flags value for newly-inserted nodes. (Default = 0)</span>
<span class="sd">        :param int population: The population value for newly inserted nodes.</span>
<span class="sd">            Defaults to ``tskit.NULL`` if not specified.</span>
<span class="sd">        :param metadata: The metadata for any newly inserted nodes. See</span>
<span class="sd">            :meth:`.NodeTable.add_row` for details on how default metadata</span>
<span class="sd">            is produced for a given schema (or none).</span>
<span class="sd">        :return: A copy of this tree sequence with edges split at the specified time.</span>
<span class="sd">        :rtype: tskit.TreeSequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">population</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span> <span class="k">if</span> <span class="n">population</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">population</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">flags</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">flags</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_metadata_schemas</span><span class="o">.</span><span class="n">node</span>
        <span class="k">if</span> <span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">empty_value</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">validate_and_encode_row</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
        <span class="n">ll_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">split_edges</span><span class="p">(</span>
            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
            <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
            <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">TreeSequence</span><span class="p">(</span><span class="n">ll_ts</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.decapitate">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.decapitate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">decapitate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">population</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete all edge topology and mutational information at least as old</span>
<span class="sd">        as the specified time from this tree sequence.</span>

<span class="sd">        Removes all edges in which the time of the child is &gt;= the specified</span>
<span class="sd">        time ``t``, and breaks edges that intersect with ``t``. For each edge</span>
<span class="sd">        intersecting with ``t`` we create a new node with time equal to ``t``,</span>
<span class="sd">        and set the parent of the edge to this new node. The node table</span>
<span class="sd">        is not altered in any other way. Newly added nodes have values</span>
<span class="sd">        for ``flags``, ``population`` and ``metadata`` controlled by parameters</span>
<span class="sd">        to this function in the same way as :meth:`.split_edges`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            Note that each edge is treated independently, so that even if two</span>
<span class="sd">            edges that are broken by this operation share the same parent and</span>
<span class="sd">            child nodes, there will be two different new parent nodes inserted.</span>

<span class="sd">        Any mutation whose time is &gt;= ``t`` will be removed. A mutation&#39;s time</span>
<span class="sd">        is its associated ``time`` value, or the time of its node if the</span>
<span class="sd">        mutation&#39;s time was marked as unknown (:data:`UNKNOWN_TIME`).</span>

<span class="sd">        Migrations are not supported, and a LibraryError will be raised if</span>
<span class="sd">        called on a tree sequence containing migration information.</span>

<span class="sd">        .. seealso:: This method is implemented using the :meth:`.split_edges`</span>
<span class="sd">            and :meth:`TableCollection.delete_older` functions.</span>

<span class="sd">        :param float time: The cutoff time.</span>
<span class="sd">        :param int flags: The flags value for newly-inserted nodes. (Default = 0)</span>
<span class="sd">        :param int population: The population value for newly inserted nodes.</span>
<span class="sd">            Defaults to ``tskit.NULL`` if not specified.</span>
<span class="sd">        :param metadata: The metadata for any newly inserted nodes. See</span>
<span class="sd">            :meth:`.NodeTable.add_row` for details on how default metadata</span>
<span class="sd">            is produced for a given schema (or none).</span>
<span class="sd">        :return: A copy of this tree sequence with edges split at the specified time.</span>
<span class="sd">        :rtype: tskit.TreeSequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">split_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_edges</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">population</span><span class="o">=</span><span class="n">population</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span>
        <span class="p">)</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="n">split_ts</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">split_ts</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">delete_older</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeSequence.extend_haplotypes">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.extend_haplotypes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extend_haplotypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new tree sequence in which the span covered by ancestral nodes</span>
<span class="sd">        is &quot;extended&quot; to regions of the genome according to the following rule:</span>
<span class="sd">        If an ancestral segment corresponding to node `n` has ancestor `p` and</span>
<span class="sd">        descendant `c` on some portion of the genome, and on an adjacent segment of</span>
<span class="sd">        genome `p` is still an ancestor of `c`, then `n` is inserted into the</span>
<span class="sd">        path from `p` to `c`. For instance, if `p` is the parent of `n` and `n`</span>
<span class="sd">        is the parent of `c`, then the span of the edges from `p` to `n` and</span>
<span class="sd">        `n` to `c` are extended, and the span of the edge from `p` to `c` is</span>
<span class="sd">        reduced. Thus, the ancestral haplotype represented by `n` is extended</span>
<span class="sd">        to a longer span of the genome. However, any edges whose child node is</span>
<span class="sd">        a sample are not modified. See</span>
<span class="sd">        `Fritze et al. (2025) &lt;https://doi.org/10.1093/genetics/iyaf198&gt;`_</span>
<span class="sd">        for more details.</span>

<span class="sd">        Since some edges may be removed entirely, this process usually reduces</span>
<span class="sd">        the number of edges in the tree sequence.</span>

<span class="sd">        The method works by iterating over the genome to look for paths that can</span>
<span class="sd">        be extended in this way; the maximum number of such iterations is</span>
<span class="sd">        controlled by ``max_iter``.</span>

<span class="sd">        The rationale is that we know that `n` carries a portion of the segment</span>
<span class="sd">        of ancestral genome inherited by `c` from `p`, and so likely carries</span>
<span class="sd">        the *entire* inherited segment (since the implication otherwise would</span>
<span class="sd">        be that distinct recombined segments were passed down separately from</span>
<span class="sd">        `p` to `c`).</span>

<span class="sd">        In the example above, if there was a mutation on the node above `c`</span>
<span class="sd">        older than the time of `n` in the span into which `n` was extended,</span>
<span class="sd">        then the mutation will now occur above `n`. So, this operation may change</span>
<span class="sd">        mutations&#39; nodes (but will not affect genotypes).  This is only</span>
<span class="sd">        unambiguous if the mutation&#39;s time is known, so the method requires</span>
<span class="sd">        known mutation times.  See :meth:`.impute_unknown_mutations_time` if</span>
<span class="sd">        mutation times are not known.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The method will not affect the marginal trees (so, if the original tree</span>
<span class="sd">            sequence was simplified, then following up with `simplify` will recover</span>
<span class="sd">            the original tree sequence, possibly with edges in a different order).</span>
<span class="sd">            It will also not affect the genotype matrix, or any of the tables other</span>
<span class="sd">            than the edge table or the node column in the mutation table.</span>

<span class="sd">        :param int max_iter: The maximum number of iterations over the tree</span>
<span class="sd">            sequence. Defaults to 10.</span>
<span class="sd">        :return: A new tree sequence with unary nodes extended.</span>
<span class="sd">        :rtype: tskit.TreeSequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)</span>
        <span class="n">ll_ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">extend_haplotypes</span><span class="p">(</span><span class="n">max_iter</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TreeSequence</span><span class="p">(</span><span class="n">ll_ts</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.subset">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.subset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">subset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nodes</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">reorder_populations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">remove_unreferenced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a tree sequence containing only information directly</span>
<span class="sd">        referencing the provided list of nodes to retain.  The result will</span>
<span class="sd">        retain only the nodes whose IDs are listed in ``nodes``, only edges for</span>
<span class="sd">        which both parent and child are in ``nodes```, only mutations whose</span>
<span class="sd">        node is in ``nodes``, and only individuals that are referred to by one</span>
<span class="sd">        of the retained nodes.  Note that this does *not* retain</span>
<span class="sd">        the ancestry of these nodes - for that, see :meth:`.simplify`.</span>

<span class="sd">        This has the side effect that it may change the order of the nodes,</span>
<span class="sd">        populations, individuals, and migrations in the tree sequence. Nodes</span>
<span class="sd">        in the new tree sequence will be in the order provided in ``nodes``.</span>
<span class="sd">        Populations will be ordered in ascending order of the lowest ID of</span>
<span class="sd">        the nodes that refer to them. Individuals will be not only ordered</span>
<span class="sd">        so that :attr:`~Individual.parents` come before children (see</span>
<span class="sd">        :meth:`~TableCollection.sort_individuals`) but in addition</span>
<span class="sd">        will be secondarily sorted in ascending order of the lowest ID of</span>
<span class="sd">        their referring nodes. (However, ``reorder_populations`` may be set</span>
<span class="sd">        to ``False`` to keep the population table unchanged.)</span>

<span class="sd">        By default, the method removes all individuals and populations not</span>
<span class="sd">        referenced by any nodes, and all sites not referenced by any mutations.</span>
<span class="sd">        To retain these unreferenced individuals, populations, and sites, pass</span>
<span class="sd">        ``remove_unreferenced=False``. If this is done, the site table will</span>
<span class="sd">        remain unchanged, unreferenced individuals will appear at the end of</span>
<span class="sd">        the individuals table (and in their original order), and unreferenced</span>
<span class="sd">        populations will appear at the end of the population table (unless</span>
<span class="sd">        ``reorder_populations=False``).</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.keep_intervals` for subsetting a given portion of the genome;</span>
<span class="sd">            :meth:`.simplify` for retaining the ancestry of a subset of nodes.</span>

<span class="sd">        :param list nodes: The list of nodes for which to retain information. This</span>
<span class="sd">            may be a numpy array (or array-like) object (dtype=np.int32).</span>
<span class="sd">        :param bool record_provenance: Whether to record a provenance entry</span>
<span class="sd">            in the provenance table for this operation.</span>
<span class="sd">        :param bool reorder_populations: Whether to reorder populations</span>
<span class="sd">            (default: True).  If False, the population table will not be altered in</span>
<span class="sd">            any way.</span>
<span class="sd">        :param bool remove_unreferenced: Whether sites, individuals, and populations</span>
<span class="sd">            that are not referred to by any retained entries in the tables should</span>
<span class="sd">            be removed (default: True). See the description for details.</span>
<span class="sd">        :rtype: tskit.TreeSequence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">subset</span><span class="p">(</span>
            <span class="n">nodes</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
            <span class="n">reorder_populations</span><span class="o">=</span><span class="n">reorder_populations</span><span class="p">,</span>
            <span class="n">remove_unreferenced</span><span class="o">=</span><span class="n">remove_unreferenced</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeSequence.union">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.union">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">union</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">node_mapping</span><span class="p">,</span>
        <span class="n">check_shared_equality</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">add_populations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">record_provenance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">all_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">all_mutations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an expanded tree sequence which contains the node-wise union of</span>
<span class="sd">        ``self`` and ``other``, obtained by adding the non-shared portions of</span>
<span class="sd">        ``other`` onto ``self``. The &quot;shared&quot; portions are specified using a</span>
<span class="sd">        map that specifies which nodes in ``other`` are equivalent to those in</span>
<span class="sd">        ``self``: the ``node_mapping`` argument should be an array of length</span>
<span class="sd">        equal to the number of nodes in ``other`` and whose entries are the ID</span>
<span class="sd">        of the matching node in ``self``, or ``tskit.NULL`` if there is no</span>
<span class="sd">        matching node. Those nodes in ``other`` that map to ``tskit.NULL`` will</span>
<span class="sd">        be added to ``self``, along with:</span>

<span class="sd">        1. Individuals whose nodes are new to ``self``.</span>
<span class="sd">        2. Edges whose parent or child are new to ``self``.</span>
<span class="sd">        3. Mutations whose nodes are new to ``self``.</span>
<span class="sd">        4. Sites whose positions are not present in the site positions in</span>
<span class="sd">           ``self``, if the site contains a newly added mutation.</span>

<span class="sd">        This can be thought of as a &quot;node-wise&quot; union: for instance, it can not</span>
<span class="sd">        be used to add new edges between two nodes already in ``self`` or new</span>
<span class="sd">        mutations above nodes already in ``self``.</span>

<span class="sd">        By default, with ``add_populations=True``, populations of all newly added</span>
<span class="sd">        nodes are assumed to be new populations, and added to the end of the</span>
<span class="sd">        population table as well. This is appropriate if all nodes to be added</span>
<span class="sd">        are from distinct populations not already in ``self`` and ordering of</span>
<span class="sd">        populations is not important. On the other hand, if</span>
<span class="sd">        ``add_populations=False`` then no new populations are added, so any</span>
<span class="sd">        populations referred to in ``other`` must already exist in ``self``.</span>
<span class="sd">        If some new nodes are in populations already in ``self`` but other new</span>
<span class="sd">        nodes are in entirely new populations, then you must set up the</span>
<span class="sd">        population table first, and then union with ``add_populations=False``.</span>

<span class="sd">        This method makes sense if the &quot;shared&quot; portions of the tree sequences</span>
<span class="sd">        are equal; the option ``check_shared_equality`` performs a consistency</span>
<span class="sd">        check that this is true. If this check is disabled, it is very easy to</span>
<span class="sd">        produce nonsensical results via subtle inconsistencies.</span>

<span class="sd">        The behavior above can be changed by ``all_edges`` and ``all_mutations``.</span>
<span class="sd">        If ``all_edges`` is True, then all edges in ``other`` are added to</span>
<span class="sd">        ``self``, instead of only edges adjacent to added nodes. If</span>
<span class="sd">        ``all_mutations`` is True, then similarly all mutations in ``other``</span>
<span class="sd">        are added (not just those on added nodes); furthermore, all sites</span>
<span class="sd">        at positions without a site already present are added to ``self``.</span>
<span class="sd">        The intended use case for these options is a &quot;disjoint&quot; union,</span>
<span class="sd">        where for instance the two tree sequences contain information about</span>
<span class="sd">        disjoint segments of the genome (see :meth:`.concatenate`).</span>
<span class="sd">        For some such applications it may be necessary to set</span>
<span class="sd">        ``check_shared_equality=False``: for instance, if ``other`` has</span>
<span class="sd">        an identical copy of the node table but no edges, then</span>
<span class="sd">        ``all_mutations=True, check_shared_equality=False`` can be used</span>
<span class="sd">        to add mutations to ``self``.</span>

<span class="sd">        .. warning::</span>
<span class="sd">            If an equivalent node is specified in ``other``, the</span>
<span class="sd">            version in ``self`` is used without checking the node</span>
<span class="sd">            properties are the same. Similarly, if the same site position</span>
<span class="sd">            is present in both ``self`` and ``other``, the version in</span>
<span class="sd">            ``self`` is used without checking that site properties are</span>
<span class="sd">            the same. In these cases metadata and e.g. node times or ancestral</span>
<span class="sd">            states in ``other`` are simply ignored.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This operation also sorts the resulting tables, so the resulting</span>
<span class="sd">            tree sequence may not be equal to ``self`` even if nothing new</span>
<span class="sd">            was added (although it would differ only in ordering of the tables).</span>

<span class="sd">        :param TreeSequence other: Another tree sequence.</span>
<span class="sd">        :param list node_mapping: An array of node IDs that relate nodes in</span>
<span class="sd">            ``other`` to nodes in ``self``.</span>
<span class="sd">        :param bool all_edges: If True, then all edges in ``other`` are added</span>
<span class="sd">            to ``self``.</span>
<span class="sd">        :param bool all_mutations: If True, then all mutations and sites in</span>
<span class="sd">            ``other`` are added to ``self``.</span>
<span class="sd">        :param bool check_shared_equality: If True, the shared portions of the</span>
<span class="sd">            tree sequences will be checked for equality. It does so by</span>
<span class="sd">            running :meth:`TreeSequence.subset` on both ``self`` and ``other``</span>
<span class="sd">            for the equivalent nodes specified in ``node_mapping``, and then</span>
<span class="sd">            checking for equality of the subsets.</span>
<span class="sd">        :param bool add_populations: If True, nodes new to ``self`` will be</span>
<span class="sd">            assigned new population IDs.</span>
<span class="sd">        :param bool record_provenance: Whether to record a provenance entry</span>
<span class="sd">            in the provenance table for this operation.</span>
<span class="sd">        :return: The union of the two tree sequences.</span>
<span class="sd">        :rtype: tskit.TreeSequence</span>
<span class="sd">        :raises: **tskit.LibraryError** -- If the resulting tree sequence is invalid</span>
<span class="sd">            (for instance, a node is specified to have two distinct</span>
<span class="sd">            parents on the same interval)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">other_tables</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span>
        <span class="n">tables</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="n">other_tables</span><span class="p">,</span>
            <span class="n">node_mapping</span><span class="p">,</span>
            <span class="n">check_shared_equality</span><span class="o">=</span><span class="n">check_shared_equality</span><span class="p">,</span>
            <span class="n">add_populations</span><span class="o">=</span><span class="n">add_populations</span><span class="p">,</span>
            <span class="n">record_provenance</span><span class="o">=</span><span class="n">record_provenance</span><span class="p">,</span>
            <span class="n">all_edges</span><span class="o">=</span><span class="n">all_edges</span><span class="p">,</span>
            <span class="n">all_mutations</span><span class="o">=</span><span class="n">all_mutations</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">tables</span><span class="o">.</span><span class="n">tree_sequence</span><span class="p">()</span></div>


<div class="viewcode-block" id="TreeSequence.draw_svg">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.draw_svg">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw_svg</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tree_height_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mutation_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_titles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mutation_titles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">root_svg_attributes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">style</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">force_root_branch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">symbol_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_lim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">x_regions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">y_axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">y_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">y_ticks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">y_gridlines</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">omit_sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">canvas_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_num_trees</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">preamble</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an SVG representation of a tree sequence. See the</span>
<span class="sd">        :ref:`visualization tutorial&lt;tutorials:sec_tskit_viz&gt;` for more details.</span>

<span class="sd">        :param str path: The path to the file to write the output. If None, do not write</span>
<span class="sd">            to file.</span>
<span class="sd">        :param tuple(int, int) size: A tuple of (width, height) specifying a target</span>
<span class="sd">            drawing size in abstract user units (usually interpreted as pixels on</span>
<span class="sd">            initial display). Components of the drawing will be scaled so that the total</span>
<span class="sd">            plot including labels etc. normally fits onto a canvas of this size (see</span>
<span class="sd">            ``canvas_size`` below). If ``None``, chose values such that each tree is</span>
<span class="sd">            drawn at a size appropriate for a reasonably small set of samples (this will</span>
<span class="sd">            nevertheless result in a very wide drawing if there are many trees to</span>
<span class="sd">            display). Default: ``None``</span>
<span class="sd">        :param str x_scale: Control how the X axis is drawn. If &quot;physical&quot; (the default)</span>
<span class="sd">            the axis scales linearly with physical distance along the sequence,</span>
<span class="sd">            background shading is used to indicate the position of the trees along the</span>
<span class="sd">            X axis, and sites (with associated mutations) are marked at the</span>
<span class="sd">            appropriate physical position on axis line. If &quot;treewise&quot;, each axis tick</span>
<span class="sd">            corresponds to a tree boundary, which are positioned evenly along the axis,</span>
<span class="sd">            so that the X axis is of variable scale, no background scaling is required,</span>
<span class="sd">            and site positions are not marked on the axis.</span>
<span class="sd">        :param str time_scale: Control how height values for nodes are computed.</span>
<span class="sd">            If this is equal to ``&quot;time&quot;``, node heights are proportional to their time</span>
<span class="sd">            values (this is the default). If this is equal to ``&quot;log_time&quot;``, node</span>
<span class="sd">            heights are proportional to their log(time) values. If it is equal to</span>
<span class="sd">            ``&quot;rank&quot;``, node heights are spaced equally according to their ranked times.</span>
<span class="sd">        :param str tree_height_scale: Deprecated alias for time_scale. (Deprecated in</span>
<span class="sd">            0.3.6)</span>
<span class="sd">        :param str title: A title string to be included in the SVG output. If ``None``</span>
<span class="sd">            (default) no title is shown, which gives more vertical space for the tree.</span>
<span class="sd">        :param node_labels: If specified, show custom labels for the nodes</span>
<span class="sd">            (specified by ID) that are present in this map; any nodes not present will</span>
<span class="sd">            not have a label.</span>
<span class="sd">        :type node_labels: dict(int, str)</span>
<span class="sd">        :param mutation_labels: If specified, show custom labels for the</span>
<span class="sd">            mutations (specified by ID) that are present in the map; any mutations</span>
<span class="sd">            not present will not have a label.</span>
<span class="sd">        :param dict(int, str) node_titles: If specified, add a ``&lt;title&gt;`` string to</span>
<span class="sd">            symbols for each node (specified by ID) present in this map. SVG visualizers</span>
<span class="sd">            such as web browsers will commonly display this string on mousing over</span>
<span class="sd">            node symbol.</span>
<span class="sd">        :param dict(int, str) mutation_titles: If specified, add a ``&lt;title&gt;`` string to</span>
<span class="sd">            symbols for each mutation (specified by ID) present in this map. SVG</span>
<span class="sd">            visualizers such as web browsers will commonly display this string on</span>
<span class="sd">            mousing over the mutation symbol in the tree and (if show) on the x axis.</span>
<span class="sd">        :param dict root_svg_attributes: Additional attributes, such as an id, that will</span>
<span class="sd">            be embedded in the root ``&lt;svg&gt;`` tag of the generated drawing.</span>
<span class="sd">        :param str style: A `css string &lt;https://www.w3.org/TR/CSS21/syndata.htm&gt;`_</span>
<span class="sd">            that will be included in the ``&lt;style&gt;`` tag of the generated svg.</span>
<span class="sd">        :param str order: The left-to-right ordering of child nodes in each drawn tree.</span>
<span class="sd">            This can be either: ``&quot;minlex&quot;``, which minimises the differences</span>
<span class="sd">            between adjacent trees (see also the ``&quot;minlex_postorder&quot;`` traversal</span>
<span class="sd">            order for the :meth:`.Tree.nodes` method); or ``&quot;tree&quot;`` which draws trees</span>
<span class="sd">            in the left-to-right order defined by the</span>
<span class="sd">            :ref:`quintuply linked tree structure &lt;sec_data_model_tree_structure&gt;`.</span>
<span class="sd">            If not specified or None, this defaults to ``&quot;minlex&quot;``.</span>
<span class="sd">        :param bool force_root_branch: If ``True`` plot a branch (edge) above every tree</span>
<span class="sd">            root in the tree sequence. If ``None`` (default) then only plot such</span>
<span class="sd">            root branches if any root in the tree sequence has a mutation above it.</span>
<span class="sd">        :param float symbol_size: Change the default size of the node and mutation</span>
<span class="sd">            plotting symbols. If ``None`` (default) use a standard size.</span>
<span class="sd">        :param bool x_axis: Should the plot have an X axis line, showing the positions</span>
<span class="sd">            of trees along the genome. The scale used is determined by the ``x_scale``</span>
<span class="sd">            parameter. If ``None`` (default) plot an X axis.</span>
<span class="sd">        :param str x_label: Place a label under the plot. If ``None`` (default) and</span>
<span class="sd">            there is an X axis, create and place an appropriate label.</span>
<span class="sd">        :param list x_lim: A list of size two giving the genomic positions between which</span>
<span class="sd">            trees should be plotted. If the first is ``None``, then plot from the first</span>
<span class="sd">            non-empty region of the tree sequence. If the second is ``None``, then plot</span>
<span class="sd">            up to the end of the last non-empty region of the tree sequence. The default</span>
<span class="sd">            value ``x_lim=None`` is shorthand for the list [``None``, ``None``]. If</span>
<span class="sd">            numerical values are given, then regions outside the interval have all</span>
<span class="sd">            information discarded: this means that mutations outside the interval will</span>
<span class="sd">            not be shown. To force display of the entire tree sequence, including empty</span>
<span class="sd">            flanking regions, specify ``x_lim=[0, ts.sequence_length]``.</span>
<span class="sd">        :param dict x_regions: A dictionary mapping (left, right) tuples to names. This</span>
<span class="sd">            draws a box, labelled with the name, on the X axis between the left and</span>
<span class="sd">            right positions, and can be used for annotating genomic regions (e.g.</span>
<span class="sd">            genes) on the X axis. If ``None`` (default) do not plot any regions.</span>
<span class="sd">        :param Union[bool, str] y_axis: Should the plot have an Y axis line, showing</span>
<span class="sd">            time. If ``False`` do not plot a Y axis. If ``True``, plot the Y axis on</span>
<span class="sd">            left hand side of the plot. Can also take the strings ``&quot;left&quot;`` or</span>
<span class="sd">            ``&quot;right&quot;``, specifying the side of the plot on which to plot the Y axis.</span>
<span class="sd">            Default: ``None``, treated as ``False``.</span>
<span class="sd">        :param str y_label: Place a label to the left of the plot. If ``None`` (default)</span>
<span class="sd">            and there is a Y axis, create and place an appropriate label.</span>
<span class="sd">        :param Union[list, dict] y_ticks: A list of Y values at which to plot</span>
<span class="sd">            tickmarks, or a dictionary mapping Y values to labels (``[]`` gives no</span>
<span class="sd">            tickmarks). If ``None`` (default), plot one tickmark for each unique node</span>
<span class="sd">            value. Note that if ``time_scale=&quot;rank&quot;``, the Y values refer to the</span>
<span class="sd">            zero-based rank of the plotted nodes, rather than the node time itself.</span>
<span class="sd">        :param bool y_gridlines: Whether to plot horizontal lines behind the tree</span>
<span class="sd">            at each y tickmark.</span>
<span class="sd">        :param bool omit_sites: If True, omit sites and mutations from the drawing.</span>
<span class="sd">            Default: False</span>
<span class="sd">        :param tuple(int, int) canvas_size: The (width, height) of the SVG canvas.</span>
<span class="sd">            This will change the SVG width and height without rescaling graphical</span>
<span class="sd">            elements, allowing extra room e.g. for unusually long labels. If ``None``</span>
<span class="sd">            take the canvas size to be the same as the target drawing size (see</span>
<span class="sd">            ``size``, above). Default: None</span>
<span class="sd">        :param int max_num_trees: The maximum number of trees to plot. If there are</span>
<span class="sd">            more trees than this in the tree sequence, the middle trees will be skipped</span>
<span class="sd">            from the plot and a message &quot;XX trees skipped&quot; displayed in their place.</span>
<span class="sd">            If ``None``, all the trees will be plotted: this can produce a very wide</span>
<span class="sd">            plot if there are many trees in the tree sequence. Default: None</span>
<span class="sd">        :param str preamble: SVG commands to be included at the start of the returned</span>
<span class="sd">            object, immediately after the opening tag. These can include custom svg</span>
<span class="sd">            elements such as legends or annotations or even entire ``&lt;svg&gt;`` elements.</span>
<span class="sd">            The preamble is not checked for validity, so it is up to the user to</span>
<span class="sd">            ensure that it is valid SVG. Default: None</span>

<span class="sd">        :return: An SVG representation of a tree sequence.</span>
<span class="sd">        :rtype: SVGString</span>

<span class="sd">        .. note::</span>
<span class="sd">            Technically, x_lim[0] specifies a *minimum* value for the start of the X</span>
<span class="sd">            axis, and x_lim[1] specifies a *maximum* value for the end. This is only</span>
<span class="sd">            relevant if the tree sequence contains &quot;empty&quot; regions with no edges or</span>
<span class="sd">            mutations. In this case if x_lim[0] lies strictly within an empty region</span>
<span class="sd">            (i.e., ``empty_tree.interval.left &lt; x_lim[0] &lt; empty_tree.interval.right``)</span>
<span class="sd">            then that tree will not be plotted on the left hand side, and the X axis</span>
<span class="sd">            will start at ``empty_tree.interval.right``. Similarly, if x_lim[1] lies</span>
<span class="sd">            strictly within an empty region then that tree will not be plotted on the</span>
<span class="sd">            right hand side, and the X axis will end at ``empty_tree.interval.left``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">svgtreesequence</span> <span class="o">=</span> <span class="n">drawing</span><span class="o">.</span><span class="n">SvgTreeSequence</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">size</span><span class="p">,</span>
            <span class="n">x_scale</span><span class="o">=</span><span class="n">x_scale</span><span class="p">,</span>
            <span class="n">time_scale</span><span class="o">=</span><span class="n">time_scale</span><span class="p">,</span>
            <span class="n">tree_height_scale</span><span class="o">=</span><span class="n">tree_height_scale</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
            <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span>
            <span class="n">mutation_labels</span><span class="o">=</span><span class="n">mutation_labels</span><span class="p">,</span>
            <span class="n">node_titles</span><span class="o">=</span><span class="n">node_titles</span><span class="p">,</span>
            <span class="n">mutation_titles</span><span class="o">=</span><span class="n">mutation_titles</span><span class="p">,</span>
            <span class="n">root_svg_attributes</span><span class="o">=</span><span class="n">root_svg_attributes</span><span class="p">,</span>
            <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">force_root_branch</span><span class="o">=</span><span class="n">force_root_branch</span><span class="p">,</span>
            <span class="n">symbol_size</span><span class="o">=</span><span class="n">symbol_size</span><span class="p">,</span>
            <span class="n">x_axis</span><span class="o">=</span><span class="n">x_axis</span><span class="p">,</span>
            <span class="n">x_label</span><span class="o">=</span><span class="n">x_label</span><span class="p">,</span>
            <span class="n">x_lim</span><span class="o">=</span><span class="n">x_lim</span><span class="p">,</span>
            <span class="n">x_regions</span><span class="o">=</span><span class="n">x_regions</span><span class="p">,</span>
            <span class="n">y_axis</span><span class="o">=</span><span class="n">y_axis</span><span class="p">,</span>
            <span class="n">y_label</span><span class="o">=</span><span class="n">y_label</span><span class="p">,</span>
            <span class="n">y_ticks</span><span class="o">=</span><span class="n">y_ticks</span><span class="p">,</span>
            <span class="n">y_gridlines</span><span class="o">=</span><span class="n">y_gridlines</span><span class="p">,</span>
            <span class="n">omit_sites</span><span class="o">=</span><span class="n">omit_sites</span><span class="p">,</span>
            <span class="n">canvas_size</span><span class="o">=</span><span class="n">canvas_size</span><span class="p">,</span>
            <span class="n">max_num_trees</span><span class="o">=</span><span class="n">max_num_trees</span><span class="p">,</span>
            <span class="n">preamble</span><span class="o">=</span><span class="n">preamble</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">svgtreesequence</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.draw_text">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.draw_text">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">draw_text</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">node_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">use_ascii</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">time_label_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">position_label_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a text representation of a tree sequence.</span>

<span class="sd">        :param dict node_labels: If specified, show custom labels for the nodes</span>
<span class="sd">            that are present in the map. Any nodes not specified in the map will</span>
<span class="sd">            not have a node label.</span>
<span class="sd">        :param bool use_ascii: If ``False`` (default) then use unicode</span>
<span class="sd">            `box drawing characters \</span>
<span class="sd">&lt;https://en.wikipedia.org/wiki/Box-drawing_character&gt;`_</span>
<span class="sd">            to render the tree. If ``True``, use plain ascii characters, which look</span>
<span class="sd">            cruder but are less susceptible to misalignment or font substitution.</span>
<span class="sd">            Alternatively, if you are having alignment problems with Unicode, you can try</span>
<span class="sd">            out the solution documented `here \</span>
<span class="sd">&lt;https://github.com/tskit-dev/tskit/issues/189#issuecomment-499114811&gt;`_.</span>
<span class="sd">        :param str time_label_format: A python format string specifying the format (e.g.</span>
<span class="sd">            number of decimal places or significant figures) used to print the numerical</span>
<span class="sd">            time values on the time axis. If ``None``, this defaults to ``&quot;{:.2f}&quot;``.</span>
<span class="sd">        :param str position_label_format: A python format string specifying the format</span>
<span class="sd">            (e.g. number of decimal places or significant figures) used to print genomic</span>
<span class="sd">            positions. If ``None``, this defaults to ``&quot;{:.2f}&quot;``.</span>
<span class="sd">        :param str order: The left-to-right ordering of child nodes in the drawn tree.</span>
<span class="sd">            This can be either: ``&quot;minlex&quot;``, which minimises the differences</span>
<span class="sd">            between adjacent trees (see also the ``&quot;minlex_postorder&quot;`` traversal</span>
<span class="sd">            order for the :meth:`.Tree.nodes` method); or ``&quot;tree&quot;`` which draws trees</span>
<span class="sd">            in the left-to-right order defined by the</span>
<span class="sd">            :ref:`quintuply linked tree structure &lt;sec_data_model_tree_structure&gt;`.</span>
<span class="sd">            If not specified or None, this defaults to ``&quot;minlex&quot;``.</span>

<span class="sd">        :return: A text representation of a tree sequence.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span>
            <span class="n">drawing</span><span class="o">.</span><span class="n">TextTreeSequence</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">node_labels</span><span class="o">=</span><span class="n">node_labels</span><span class="p">,</span>
                <span class="n">use_ascii</span><span class="o">=</span><span class="n">use_ascii</span><span class="p">,</span>
                <span class="n">time_label_format</span><span class="o">=</span><span class="n">time_label_format</span><span class="p">,</span>
                <span class="n">position_label_format</span><span class="o">=</span><span class="n">position_label_format</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>


    <span class="c1">############################################</span>
    <span class="c1">#</span>
    <span class="c1"># Statistics computation</span>
    <span class="c1">#</span>
    <span class="c1">############################################</span>

<div class="viewcode-block" id="TreeSequence.general_stat">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.general_stat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">general_stat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">W</span><span class="p">,</span>
        <span class="n">f</span><span class="p">,</span>
        <span class="n">output_dim</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a windowed statistic from weights and a summary function.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        On each tree, this</span>
<span class="sd">        propagates the weights ``W`` up the tree, so that the &quot;weight&quot; of each</span>
<span class="sd">        node is the sum of the weights of all samples at or below the node.</span>
<span class="sd">        Then the summary function ``f`` is applied to the weights, giving a</span>
<span class="sd">        summary for each node in each tree. How this is then aggregated depends</span>
<span class="sd">        on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            Adds together the total summary value across all alleles in each window.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            Adds together the summary value for each node, multiplied by the</span>
<span class="sd">            length of the branch above the node and the span of the tree.</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            Returns each node&#39;s summary value added across trees and multiplied</span>
<span class="sd">            by the span of the tree.</span>

<span class="sd">        Both the weights and the summary can be multidimensional: if ``W`` has ``k``</span>
<span class="sd">        columns, and ``f`` takes a ``k``-vector and returns an ``m``-vector,</span>
<span class="sd">        then the output will be ``m``-dimensional for each node or window (depending</span>
<span class="sd">        on &quot;mode&quot;).</span>

<span class="sd">        .. note::</span>
<span class="sd">            The summary function ``f`` should return zero when given both 0 and</span>
<span class="sd">            the total weight (i.e., ``f(0) = 0`` and ``f(np.sum(W, axis=0)) = 0``),</span>
<span class="sd">            unless ``strict=False``.  This is necessary for the statistic to be</span>
<span class="sd">            unaffected by parts of the tree sequence ancestral to none or all</span>
<span class="sd">            of the samples, respectively.</span>

<span class="sd">        :param numpy.ndarray W: An array of values with one row for each sample and one</span>
<span class="sd">            column for each weight.</span>
<span class="sd">        :param f: A function that takes a one-dimensional array of length</span>
<span class="sd">            equal to the number of columns of ``W`` and returns a one-dimensional</span>
<span class="sd">            array.</span>
<span class="sd">        :param int output_dim: The length of ``f``&#39;s return value.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param bool polarised: Whether to leave the ancestral state out of computations:</span>
<span class="sd">            see :ref:`sec_stats` for more details.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :param bool strict: Whether to check that f(0) and f(total weight) are zero.</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;site&quot;</span>
        <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
            <span class="n">total_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">total_weights</span><span class="p">,</span> <span class="n">total_weights</span> <span class="o">*</span> <span class="mf">0.0</span><span class="p">]:</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                    <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">fx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fx</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">fx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">output_dim</span><span class="p">,))):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Summary function does not return zero for both &quot;</span>
                        <span class="s2">&quot;zero weight and total weight.&quot;</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="o">.</span><span class="n">general_stat</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">f</span><span class="p">,</span>
            <span class="n">output_dim</span><span class="p">,</span>
            <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.sample_count_stat">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.sample_count_stat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sample_count_stat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="p">,</span>
        <span class="n">f</span><span class="p">,</span>
        <span class="n">output_dim</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a windowed statistic from sample counts and a summary function.</span>
<span class="sd">        This is a wrapper around :meth:`.general_stat` for the common case in</span>
<span class="sd">        which the weights are all either 1 or 0, i.e., functions of the joint</span>
<span class="sd">        allele frequency spectrum.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`sample sets &lt;sec_stats_sample_sets&gt;`,</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        If ``sample_sets`` is a list of ``k`` sets of samples, then</span>
<span class="sd">        ``f`` should be a function that takes an argument of length ``k`` and</span>
<span class="sd">        returns a one-dimensional array. The ``j``-th element of the argument</span>
<span class="sd">        to ``f`` will be the number of samples in ``sample_sets[j]`` that lie</span>
<span class="sd">        below the node that ``f`` is being evaluated for. See</span>
<span class="sd">        :meth:`.general_stat`  for more details.</span>

<span class="sd">        Here is a contrived example: suppose that ``A`` and ``B`` are two sets</span>
<span class="sd">        of samples with ``nA`` and ``nB`` elements, respectively. Passing these</span>
<span class="sd">        as sample sets will give ``f`` an argument of length two, giving the number</span>
<span class="sd">        of samples in ``A`` and ``B`` below the node in question. So, if we define</span>


<span class="sd">        .. code-block:: python</span>

<span class="sd">            def f(x):</span>
<span class="sd">                pA = x[0] / nA</span>
<span class="sd">                pB = x[1] / nB</span>
<span class="sd">                return np.array([pA * pB])</span>

<span class="sd">        then if all sites are biallelic,</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            ts.sample_count_stat([A, B], f, 1, windows=&quot;sites&quot;, polarised=False, mode=&quot;site&quot;)</span>

<span class="sd">        would compute, for each site, the product of the derived allele</span>
<span class="sd">        frequencies in the two sample sets, in a (num sites, 1) array.  If</span>
<span class="sd">        instead ``f`` returns ``np.array([pA, pB, pA * pB])``, then the</span>
<span class="sd">        output would be a (num sites, 3) array, with the first two columns</span>
<span class="sd">        giving the allele frequencies in ``A`` and ``B``, respectively.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The summary function ``f`` should return zero when given both 0 and</span>
<span class="sd">            the sample size (i.e., ``f(0) = 0`` and</span>
<span class="sd">            ``f(np.array([len(x) for x in sample_sets])) = 0``).  This is</span>
<span class="sd">            necessary for the statistic to be unaffected by parts of the tree</span>
<span class="sd">            sequence ancestral to none or all of the samples, respectively.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param f: A function that takes a one-dimensional array of length</span>
<span class="sd">            equal to the number of sample sets and returns a one-dimensional array.</span>
<span class="sd">        :param int output_dim: The length of ``f``&#39;s return value.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param bool polarised: Whether to leave the ancestral state out of computations:</span>
<span class="sd">            see :ref:`sec_stats` for more details.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :param bool strict: Whether to check that f(0) and f(total weight) are zero.</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: B950</span>
        <span class="c1"># helper function for common case where weights are indicators of sample sets</span>
        <span class="k">for</span> <span class="n">U</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">U</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Elements of sample_sets must be lists without repeated elements.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">U</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Elements of sample_sets cannot be empty.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">U</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">.</span><span class="n">is_sample</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not all elements of sample_sets are samples.&quot;</span><span class="p">)</span>

        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="nb">float</span><span class="p">(</span><span class="n">u</span> <span class="ow">in</span> <span class="n">A</span><span class="p">)</span> <span class="k">for</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">general_stat</span><span class="p">(</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">f</span><span class="p">,</span>
            <span class="n">output_dim</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">parse_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">windows</span><span class="p">):</span>
        <span class="c1"># Note: need to make sure windows is a string or we try to compare the</span>
        <span class="c1"># target with a numpy array elementwise.</span>
        <span class="k">if</span> <span class="n">windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">windows</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">windows</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">windows</span> <span class="o">==</span> <span class="s2">&quot;trees&quot;</span><span class="p">:</span>
                <span class="n">windows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoints</span><span class="p">(</span><span class="n">as_array</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">windows</span> <span class="o">==</span> <span class="s2">&quot;sites&quot;</span><span class="p">:</span>
                <span class="c1"># breakpoints are at 0.0 and at the sites and at the end</span>
                <span class="n">windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">[]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">,</span>
                        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">],</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="n">windows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Unrecognized window specification </span><span class="si">{</span><span class="n">windows</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;the only allowed strings are &#39;sites&#39; or &#39;trees&#39;&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_time_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">time_windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">time_windows</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">time_windows</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__run_windowed_stat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">windows</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">strip_win</span> <span class="o">=</span> <span class="n">windows</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_windows</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strip_win</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">stat</span>

    <span class="c1"># only for temporary tw version</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__run_windowed_stat_tw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">windows</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">strip_win</span> <span class="o">=</span> <span class="n">windows</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">strip_timewin</span> <span class="o">=</span> <span class="n">time_windows</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_windows</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span>
        <span class="n">time_windows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_time_windows</span><span class="p">(</span><span class="n">time_windows</span><span class="p">)</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span> <span class="n">time_windows</span><span class="o">=</span><span class="n">time_windows</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strip_win</span> <span class="ow">and</span> <span class="n">strip_timewin</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="n">strip_win</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="n">strip_timewin</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="n">stat</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__one_way_sample_set_stat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ll_method</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time_windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span>
        <span class="c1"># First try to convert to a 1D numpy array. If it is, then we strip off</span>
        <span class="c1"># the corresponding dimension from the output.</span>
        <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we&#39;ve successfully converted sample_sets to a 1D numpy array</span>
            <span class="c1"># of integers then drop the dimension</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sets</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">sample_sets</span><span class="p">]</span>
                <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">sample_set_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_set</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample_set</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sample_set_sizes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample sets must contain at least one element&quot;</span><span class="p">)</span>

        <span class="n">flattened</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="c1"># this next line is temporary, while time windows are implemented</span>
        <span class="c1"># in other methods</span>
        <span class="n">use_tw</span> <span class="o">=</span> <span class="n">ll_method</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;allele_frequency_spectrum&quot;</span>
        <span class="k">if</span> <span class="n">use_tw</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat_tw</span><span class="p">(</span>
                <span class="n">windows</span><span class="p">,</span>
                <span class="n">time_windows</span><span class="p">,</span>
                <span class="n">ll_method</span><span class="p">,</span>
                <span class="n">sample_set_sizes</span><span class="p">,</span>
                <span class="n">flattened</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
                <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
                <span class="n">windows</span><span class="p">,</span>
                <span class="n">ll_method</span><span class="p">,</span>
                <span class="n">sample_set_sizes</span><span class="p">,</span>
                <span class="n">flattened</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
                <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_dimension</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">stat</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">windows</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">time_windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">stat</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sites</span><span class="p">):</span>
        <span class="n">row_sites</span><span class="p">,</span> <span class="n">col_sites</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">sites</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sites must be a list of lists, tuples, or ndarrays&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">row_sites</span><span class="p">,</span> <span class="n">col_sites</span> <span class="o">=</span> <span class="n">sites</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">row_sites</span> <span class="o">=</span> <span class="n">col_sites</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Sites must be a length 1 or 2 list, got a length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span><span class="si">}</span><span class="s2"> list&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">row_sites</span><span class="p">,</span> <span class="n">col_sites</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_positions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">):</span>
        <span class="n">row_positions</span><span class="p">,</span> <span class="n">col_positions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
                <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">positions</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Positions must be a list of lists, tuples, or ndarrays&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">row_positions</span><span class="p">,</span> <span class="n">col_positions</span> <span class="o">=</span> <span class="n">positions</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">row_positions</span> <span class="o">=</span> <span class="n">col_positions</span> <span class="o">=</span> <span class="n">positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Positions must be a length 1 or 2 list, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;got a length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span><span class="si">}</span><span class="s2"> list&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">row_positions</span><span class="p">,</span> <span class="n">col_positions</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__two_locus_sample_set_stat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ll_method</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="p">,</span>
        <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span>
        <span class="n">row_sites</span><span class="p">,</span> <span class="n">col_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_sites</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="n">row_positions</span><span class="p">,</span> <span class="n">col_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_positions</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

        <span class="c1"># First try to convert to a 1D numpy array. If we succeed, then we strip off</span>
        <span class="c1"># the corresponding dimension from the output.</span>
        <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we&#39;ve successfully converted sample_sets to a 1D numpy array</span>
            <span class="c1"># of integers then drop the dimension</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sets</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">sample_sets</span><span class="p">]</span>
                <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">sample_set_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_set</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample_set</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sample_set_sizes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample sets must contain at least one element&quot;</span><span class="p">)</span>

        <span class="n">flattened</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">ll_method</span><span class="p">(</span>
            <span class="n">sample_set_sizes</span><span class="p">,</span>
            <span class="n">flattened</span><span class="p">,</span>
            <span class="n">row_sites</span><span class="p">,</span>
            <span class="n">col_sites</span><span class="p">,</span>
            <span class="n">row_positions</span><span class="p">,</span>
            <span class="n">col_positions</span><span class="p">,</span>
            <span class="n">mode</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">drop_dimension</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Orient the data so that the first dimension is the sample set.</span>
            <span class="c1"># With this orientation, we get one LD matrix per sample set.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__k_way_two_locus_sample_set_stat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ll_method</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">sample_set_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_set</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample_set</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sample_set_sizes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample sets must contain at least one element&quot;</span><span class="p">)</span>
        <span class="n">flattened</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">row_sites</span><span class="p">,</span> <span class="n">col_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_sites</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="n">row_positions</span><span class="p">,</span> <span class="n">col_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_positions</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">indexes</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Indexes must be convertable to a 2D numpy array with </span><span class="si">{}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;columns&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">ll_method</span><span class="p">(</span>
            <span class="n">sample_set_sizes</span><span class="p">,</span>
            <span class="n">flattened</span><span class="p">,</span>
            <span class="n">indexes</span><span class="p">,</span>
            <span class="n">row_sites</span><span class="p">,</span>
            <span class="n">col_sites</span><span class="p">,</span>
            <span class="n">row_positions</span><span class="p">,</span>
            <span class="n">col_positions</span><span class="p">,</span>
            <span class="n">mode</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_dimension</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Orient the data so that the first dimension is the sample set.</span>
            <span class="c1"># With this orientation, we get one LD matrix per sample set.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__k_way_sample_set_stat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ll_method</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">centre</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">sample_set_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_set</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample_set</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sample_set_sizes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Sample sets must contain at least one element&quot;</span><span class="p">)</span>
        <span class="n">flattened</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">drop_based_on_index</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">drop_based_on_index</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">)</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Must specify indexes if there are not exactly </span><span class="si">{}</span><span class="s2"> sample &quot;</span>
                    <span class="s2">&quot;sets.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">indexes</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Indexes must be convertable to a 2D numpy array with </span><span class="si">{}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;columns&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="n">ll_method</span><span class="p">,</span>
            <span class="n">sample_set_sizes</span><span class="p">,</span>
            <span class="n">flattened</span><span class="p">,</span>
            <span class="n">indexes</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
            <span class="n">centre</span><span class="o">=</span><span class="n">centre</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_dimension</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">stat</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">windows</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">drop_based_on_index</span><span class="p">:</span>
                <span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span><span class="p">[()]</span>
        <span class="k">return</span> <span class="n">stat</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__k_way_weighted_stat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ll_method</span><span class="p">,</span>
        <span class="n">k</span><span class="p">,</span>
        <span class="n">W</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">centre</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Must specify indexes if there are not exactly </span><span class="si">{}</span><span class="s2"> columns &quot;</span>
                    <span class="s2">&quot;in W.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">indexes</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">drop_dimension</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Indexes must be convertable to a 2D numpy array with </span><span class="si">{}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;columns&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="n">ll_method</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">indexes</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
            <span class="n">centre</span><span class="o">=</span><span class="n">centre</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_dimension</span><span class="p">:</span>
            <span class="n">stat</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">stat</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">stat</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__weighted_vector_stat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ll_method</span><span class="p">,</span>
        <span class="n">W</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">centre</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">W</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">centre</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If `nodes` is provided, must have centre=False.&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not interpret `nodes` as a list of node IDs.&quot;</span><span class="p">)</span>
        <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="n">ll_method</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">centre</span><span class="o">=</span><span class="n">centre</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">stat</span>

    <span class="c1">############################################</span>
    <span class="c1"># Statistics definitions</span>
    <span class="c1">############################################</span>

<div class="viewcode-block" id="TreeSequence.diversity">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.diversity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">diversity</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes mean genetic diversity (also known as &quot;pi&quot;) in each of the</span>
<span class="sd">        sets of nodes from ``sample_sets``.  The statistic is also known as</span>
<span class="sd">        &quot;sample heterozygosity&quot;; a common citation for the definition is</span>
<span class="sd">        `Nei and Li (1979) &lt;https://doi.org/10.1073/pnas.76.10.5269&gt;`_</span>
<span class="sd">        (equation 22), so it is sometimes called called &quot;Nei&#39;s pi&quot;</span>
<span class="sd">        (but also sometimes &quot;Tajima&#39;s pi&quot;).</span>

<span class="sd">        Please see the :ref:`one-way statistics &lt;sec_stats_sample_sets_one_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` argument is interpreted</span>
<span class="sd">        and how it interacts with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        Note that this quantity can also be computed by the</span>
<span class="sd">        :meth:`divergence &lt;.TreeSequence.divergence&gt;` method.</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            Mean pairwise genetic diversity: the average over all n choose 2 pairs of</span>
<span class="sd">            sample nodes, of the density of sites at</span>
<span class="sd">            which the two carry different alleles, per unit of chromosome length.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            Mean distance in the tree: the average across over all n choose 2 pairs of</span>
<span class="sd">            sample nodes and locations in the window, of the mean distance in</span>
<span class="sd">            the tree between the two samples (in units of time).</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the proportion of genome on which the node is an ancestor to</span>
<span class="sd">            only one of a pair of sample nodes from the sample set, averaged</span>
<span class="sd">            over over all n choose 2 pairs of sample nodes.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes for which the statistic is computed. If any of the</span>
<span class="sd">            sample sets contain only a single node, the returned diversity will be</span>
<span class="sd">            NaN. If ``None`` (default), average over all n choose 2 pairs of distinct</span>
<span class="sd">            sample nodes in the tree sequence.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A numpy array whose length is equal to the number of sample sets.</span>
<span class="sd">            If there is one sample set and windows=None, a numpy scalar is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__one_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">diversity</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.divergence">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.divergence">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">divergence</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes mean genetic divergence between (and within) pairs of</span>
<span class="sd">        sets of nodes from ``sample_sets``.</span>
<span class="sd">        This is the &quot;average number of differences&quot;, usually referred to as &quot;dxy&quot;;</span>
<span class="sd">        a common citation for this definition is Nei and Li (1979), who called it</span>
<span class="sd">        :math:`\pi_{XY}`. Note that the mean pairwise nucleotide diversity of a</span>
<span class="sd">        sample set to itself (computed by passing an index of the form (j,j))</span>
<span class="sd">        is its :meth:`diversity &lt;.TreeSequence.diversity&gt;` (see the note below).</span>

<span class="sd">        Operates on ``k = 2`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            To avoid unexpected results, sample sets should be nonoverlapping,</span>
<span class="sd">            since comparisons of individuals to themselves are not removed when computing</span>
<span class="sd">            divergence between distinct sample sets. (However, specifying an index</span>
<span class="sd">            ``(j, j)`` computes the :meth:`diversity &lt;.TreeSequence.diversity&gt;`</span>
<span class="sd">            of ``sample_set[j]``, which removes self comparisons to provide</span>
<span class="sd">            an unbiased estimate.)</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            Mean pairwise genetic divergence: the average across every possible pair of</span>
<span class="sd">            chromosomes (one from each sample set), of the density of sites at which</span>
<span class="sd">            the two carry different alleles, per unit of chromosome length.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            Mean distance in the tree: the average across every possible pair of</span>
<span class="sd">            chromosomes (one from each sample set) and locations in the window, of</span>
<span class="sd">            the mean distance in the tree between the two samples (in units of time).</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the proportion of genome on which the node is an ancestor to</span>
<span class="sd">            only one of a pair of chromosomes from the sample set, averaged</span>
<span class="sd">            over all possible pairs.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If there is one pair of sample sets and windows=None, a numpy scalar is</span>
<span class="sd">            returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">divergence</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="c1">############################################</span>
    <span class="c1"># Pairwise sample x sample statistics</span>
    <span class="c1">############################################</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_chunk_sequence_by_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_chunks</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return list of (left, right) genome interval tuples that contain</span>
<span class="sd">        approximately equal numbers of trees as a 2D numpy array. A</span>
<span class="sd">        maximum of self.num_trees single-tree intervals can be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num_chunks</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_chunks</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_chunks</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of chunks must be an integer &gt; 0&quot;</span><span class="p">)</span>
        <span class="n">num_chunks</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trees</span><span class="p">,</span> <span class="n">num_chunks</span><span class="p">)</span>
        <span class="n">breakpoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoints</span><span class="p">(</span><span class="n">as_array</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">splits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">,</span> <span class="n">num_chunks</span><span class="p">)</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_chunks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">splits</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">splits</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">splits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">chunks</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_chunk_windows</span><span class="p">(</span><span class="n">windows</span><span class="p">,</span> <span class="n">num_chunks</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of (at most) num_chunks windows, which represent splitting</span>
<span class="sd">        up the specified list of windows into roughly equal work.</span>

<span class="sd">        Currently this is implemented by just splitting up into roughly equal</span>
<span class="sd">        numbers of windows in each chunk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num_chunks</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_chunks</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_chunks</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Number of chunks must be an integer &gt; 0&quot;</span><span class="p">)</span>
        <span class="n">num_chunks</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_chunks</span><span class="p">)</span>
        <span class="n">splits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">windows</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_chunks</span><span class="p">)</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_chunks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">splits</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">splits</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">splits</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">windows</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chunks</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_parallelise_divmat_by_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">span_normalise</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        No windows were specified, so we can chunk up the whole genome by</span>
<span class="sd">        tree, and do a simple sum of the results. This means that we have to</span>
<span class="sd">        handle span_normalise specially, though.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">worker</span><span class="p">(</span><span class="n">interval</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">divergence_matrix</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">work</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_sequence_by_tree</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">work</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">span_normalise</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span>
        <span class="k">return</span> <span class="n">total</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_parallelise_divmat_by_window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">windows</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We assume we have a number of windows that&#39;s &gt;= to the number</span>
<span class="sd">        of threads available, and let each thread have a chunk of the</span>
<span class="sd">        windows. There will definitely cases where this leads to</span>
<span class="sd">        pathological behaviour, so we may need a more sophisticated</span>
<span class="sd">        strategy at some point.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">worker</span><span class="p">(</span><span class="n">sub_windows</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">divergence_matrix</span><span class="p">(</span><span class="n">sub_windows</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">work</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_windows</span><span class="p">(</span><span class="n">windows</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="n">futures</span> <span class="o">=</span> <span class="p">[</span><span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">sub_windows</span><span class="p">)</span> <span class="k">for</span> <span class="n">sub_windows</span> <span class="ow">in</span> <span class="n">work</span><span class="p">]</span>
            <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">futures</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_stat_matrix_sample_sets</span><span class="p">(</span><span class="n">ids</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a flattened list of sets of IDs. If ids is a 1D list,</span>
<span class="sd">        interpret as n one-element sets. Otherwise, it must be a sequence</span>
<span class="sd">        of ID lists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">id_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
        <span class="n">size_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span>
        <span class="c1"># Exclude some types that could be specified accidentally, and</span>
        <span class="c1"># we may want to reserve for future use.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ID specification cannot be a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">id_dtype</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">size_dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
            <span class="c1"># Interpret as a 1D array</span>
            <span class="n">flat</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">id_dtype</span><span class="p">)</span>
            <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flat</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">size_dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">set_lists</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">sizes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">id_list</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">id_list</span><span class="p">,</span> <span class="n">id_dtype</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ID sets must be 1D integer arrays&quot;</span><span class="p">)</span>
                <span class="n">set_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="n">flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">set_lists</span><span class="p">)</span>
            <span class="n">sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">size_dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flat</span><span class="p">,</span> <span class="n">sizes</span>

<div class="viewcode-block" id="TreeSequence.divergence_matrix">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.divergence_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">divergence_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the matrix of pairwise :meth:`.divergence` values between groups</span>
<span class="sd">        of sample nodes. Returns a numpy array indexed by (window,</span>
<span class="sd">        sample_set, sample_set): the [k,i,j]th value of the result gives the</span>
<span class="sd">        mean divergence between pairs of samples from the i-th and j-th</span>
<span class="sd">        sample sets in the k-th window. As for :meth:`.divergence`,</span>
<span class="sd">        diagonal entries are corrected so that the</span>
<span class="sd">        value gives the mean divergence for *distinct* samples,</span>
<span class="sd">        and so diagonal entries are given by the :meth:`.diversity` of that</span>
<span class="sd">        sample set.  For this reason, if an element of `sample_sets` has only</span>
<span class="sd">        one element, the corresponding :meth:`.diversity` will be NaN.</span>
<span class="sd">        However, this method will place a value of 0 in the diagonal instead of NaN</span>
<span class="sd">        in such cases; otherwise, this is equivalent to computing values with</span>
<span class="sd">        `meth`:.divergence`.</span>
<span class="sd">        However, this is (usually) more efficient than computing many</span>
<span class="sd">        pairwise values using the `indexes` argument to :meth:`.divergence`,</span>
<span class="sd">        so see :meth:`.divergence` for a description of what exactly is computed.</span>

<span class="sd">        :param list sample_sets: A list of sets of IDs of samples.</span>
<span class="sd">        :param list windows: The breakpoints of the windows (including start</span>
<span class="sd">            and end, so has one more entry than number of windows).</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;; the other option is &quot;branch&quot;).</span>
<span class="sd">        :return: An array indexed by (window, sample_set, sample_set), or if windows is</span>
<span class="sd">            `None`, an array indexed by (sample_set, sample_set).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NOTE for documentation of sample_sets. We *must* use samples currently because</span>
        <span class="c1"># the normalisation for non-sample nodes is tricky. Do we normalise by the</span>
        <span class="c1"># total span of the ts where the node is &#39;present&#39; in the tree? We avoid this</span>
        <span class="c1"># by insisting on sample nodes.</span>

        <span class="c1"># NOTE for documentation of num_threads. Need to explain that the</span>
        <span class="c1"># its best to think of as the number of background *worker* threads.</span>
        <span class="c1"># default is to run without any worker threads. If you want to run</span>
        <span class="c1"># with all the cores on the machine, use num_threads=os.cpu_count().</span>
        <span class="n">windows_specified</span> <span class="o">=</span> <span class="n">windows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_windows</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;site&quot;</span> <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mode</span>

        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span>
            <span class="n">flattened_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span>
            <span class="n">sample_set_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">flattened_samples</span><span class="p">,</span> <span class="n">sample_set_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_stat_matrix_sample_sets</span><span class="p">(</span>
                <span class="n">sample_sets</span>
            <span class="p">)</span>

        <span class="c1"># FIXME this logic should be merged into __run_windowed_stat if</span>
        <span class="c1"># we generalise the num_threads argument to all stats.</span>
        <span class="k">if</span> <span class="n">num_threads</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">divergence_matrix</span><span class="p">(</span>
                <span class="n">windows</span><span class="p">,</span>
                <span class="n">sample_sets</span><span class="o">=</span><span class="n">flattened_samples</span><span class="p">,</span>
                <span class="n">sample_set_sizes</span><span class="o">=</span><span class="n">sample_set_sizes</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">windows_specified</span><span class="p">:</span>
                <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallelise_divmat_by_window</span><span class="p">(</span>
                    <span class="n">windows</span><span class="p">,</span>
                    <span class="n">num_threads</span><span class="p">,</span>
                    <span class="n">sample_sets</span><span class="o">=</span><span class="n">flattened_samples</span><span class="p">,</span>
                    <span class="n">sample_set_sizes</span><span class="o">=</span><span class="n">sample_set_sizes</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                    <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallelise_divmat_by_tree</span><span class="p">(</span>
                    <span class="n">num_threads</span><span class="p">,</span>
                    <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
                    <span class="n">sample_sets</span><span class="o">=</span><span class="n">flattened_samples</span><span class="p">,</span>
                    <span class="n">sample_set_sizes</span><span class="o">=</span><span class="n">sample_set_sizes</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">windows_specified</span><span class="p">:</span>
            <span class="c1"># Drop the windows dimension</span>
            <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">D</span></div>


<div class="viewcode-block" id="TreeSequence.genetic_relatedness">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.genetic_relatedness">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">genetic_relatedness</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">proportion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">centre</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes genetic relatedness between (and within) pairs of</span>
<span class="sd">        sets of nodes from ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 2`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        :ref:`polarised &lt;sec_stats_polarisation&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            Frequency of pairwise allelic matches in the window between two</span>
<span class="sd">            sample sets relative to the rest of the sample sets. To be precise,</span>
<span class="sd">            let `m(u,v)` denote the total number of alleles shared between</span>
<span class="sd">            nodes `u` and `v`, and let `m(I,J)` be the average of `m(u,v)` over</span>
<span class="sd">            all nodes `u` in sample set `I` and `v` in sample set `J`. Let `S`</span>
<span class="sd">            and `T` be independently chosen sample sets. Then, for sample sets</span>
<span class="sd">            `I` and `J`, this computes `E[m(I,J) - m(I,S) - m(J,T) + m(S,T)]`</span>
<span class="sd">            if centre=True (the default), or `E[m(I,J)]` if centre=False.</span>
<span class="sd">            This can also be seen as the covariance of a quantitative trait</span>
<span class="sd">            determined by additive contributions from the genomes in each</span>
<span class="sd">            sample set. Let each derived allele be associated with an effect</span>
<span class="sd">            drawn from a `N(0,1)` distribution, and let the trait value of a</span>
<span class="sd">            sample be the sum of its allele effects. Then, this computes</span>
<span class="sd">            the covariance between the average trait values of two sample sets.</span>
<span class="sd">            For example, to compute covariance between the traits of diploid</span>
<span class="sd">            individuals, each sample set would be the pair of genomes of each</span>
<span class="sd">            individual, with the trait being the average of the two genomes.</span>
<span class="sd">            If ``proportion=True``, this then corresponds to :math:`K_{c0}` in</span>
<span class="sd">            `Speed &amp; Balding (2014) &lt;https://www.nature.com/articles/nrg3821&gt;`_,</span>
<span class="sd">            multiplied by four (see below).</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            Average area of branches in the window ancestral to pairs of samples</span>
<span class="sd">            in two sample sets relative to the rest of the sample sets. To be</span>
<span class="sd">            precise, let `B(u,v)` denote the total area of all branches</span>
<span class="sd">            ancestral to nodes `u` and `v`, and let `B(I,J)` be the average of</span>
<span class="sd">            `B(u,v)` over all nodes `u` in sample set `I` and `v` in sample set</span>
<span class="sd">            `J`. Let `S` and `T` be two independently chosen sample sets. Then</span>
<span class="sd">            for sample sets `I` and `J`, this computes</span>
<span class="sd">            `E[B(I,J) - B(I,S) - B(J,T) + B(S,T)]` if centre=True (the default),</span>
<span class="sd">            or `E[B(I,J)]` if centre=False.</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the proportion of the window over which pairs of</span>
<span class="sd">            samples in two sample sets are descendants, relative to the rest of</span>
<span class="sd">            the sample sets. To be precise, for each node `n`, let `N(u,v)`</span>
<span class="sd">            denote the proportion of the window over which samples `u` and `v`</span>
<span class="sd">            are descendants of `n`, and let and let `N(I,J)` be the average of</span>
<span class="sd">            `N(u,v)` over all nodes `u` in sample set `I` and `v` in sample set</span>
<span class="sd">            `J`. Let `S` and `T` be two independently chosen sample sets. Then</span>
<span class="sd">            for sample sets `I` and `J`, this computes</span>
<span class="sd">            `E[N(I,J) - N(I,S) - N(J,T) + N(S,T)]` if centre=True (the default),</span>
<span class="sd">            or `E[N(I,J)]` if centre=False.</span>

<span class="sd">        *Note:* The default for this statistic - unlike most other statistics - is</span>
<span class="sd">        ``polarised=True``. Using the default value ``centre=True``, setting</span>
<span class="sd">        ``polarised=False`` will only multiply the result by a factor of two</span>
<span class="sd">        for branch-mode, or site-mode if all sites are biallelic. (With</span>
<span class="sd">        multiallelic sites the difference is more complicated.) The uncentred</span>
<span class="sd">        and unpolarised value is probably not what you are looking for: for</span>
<span class="sd">        instance, the unpolarised, uncentred site statistic between two samples</span>
<span class="sd">        counts the number of alleles inherited by both *and* the number of</span>
<span class="sd">        alleles inherited by neither of the two samples.</span>

<span class="sd">        *Note:* Some authors</span>
<span class="sd">        (see `Speed &amp; Balding (2014) &lt;https://www.nature.com/articles/nrg3821&gt;`_)</span>
<span class="sd">        compute relatedness between `I` and `J` as the total number of all pairwise</span>
<span class="sd">        allelic matches between `I` and `J`, rather than the frequency,</span>
<span class="sd">        which would define `m(I,J)` as the sum of `m(u,v)` rather than the average</span>
<span class="sd">        in the definition of &quot;site&quot; relatedness above. If every sample set is the</span>
<span class="sd">        samples of a :math:`k`-ploid individual, this would simply multiply the</span>
<span class="sd">        result by :math:`k^2`. However, this definition would make the result not</span>
<span class="sd">        useful as a summary statistic of typical relatedness for larger sample</span>
<span class="sd">        sets.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True). Has no effect if ``proportion`` is True.</span>
<span class="sd">        :param bool proportion: Defaults to True.  Whether to divide the result by</span>
<span class="sd">            :meth:`.segregating_sites`, called with the same ``windows``,</span>
<span class="sd">            ``mode``, and ``span_normalise``. Note that this counts sites</span>
<span class="sd">            that are segregating between *any* of the samples of *any* of the</span>
<span class="sd">            sample sets (rather than segregating between all of the samples of</span>
<span class="sd">            the tree sequence).</span>
<span class="sd">        :param bool polarised: Whether to leave the ancestral state out of computations:</span>
<span class="sd">            see :ref:`sec_stats` for more details. Defaults to True.</span>
<span class="sd">        :param bool centre: Defaults to True. Whether to &#39;centre&#39; the result, as</span>
<span class="sd">            described above (the usual definition is centred).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If there is one pair of sample sets and windows=None, a numpy scalar is</span>
<span class="sd">            returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">genetic_relatedness</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
            <span class="n">centre</span><span class="o">=</span><span class="n">centre</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">proportion</span><span class="p">:</span>
            <span class="c1"># TODO this should be done in C also</span>
            <span class="n">all_samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">({</span><span class="n">u</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sample_sets</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">s</span><span class="p">}))</span>
            <span class="n">denominator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segregating_sites</span><span class="p">(</span>
                <span class="n">sample_sets</span><span class="o">=</span><span class="n">all_samples</span><span class="p">,</span>
                <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># the shapes of out and denominator should be the same except that</span>
            <span class="c1"># out may have an extra dimension if indexes is not None</span>
            <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">denominator</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">oshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">oshape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">denominator</span> <span class="o">=</span> <span class="n">denominator</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">oshape</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">/=</span> <span class="n">denominator</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="TreeSequence.genetic_relatedness_matrix">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.genetic_relatedness_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">genetic_relatedness_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the full matrix of pairwise genetic relatedness values</span>
<span class="sd">        between (and within) pairs of sets of nodes from ``sample_sets``.</span>
<span class="sd">        Returns a numpy array indexed by (window, sample_set, sample_set):</span>
<span class="sd">        the [k,i,j]th value of the result gives the</span>
<span class="sd">        genetic relatedness between pairs of samples from the i-th and j-th</span>
<span class="sd">        sample sets in the k-th window.</span>
<span class="sd">        This is (usually) more efficient than computing many pairwise</span>
<span class="sd">        values using the `indexes` argument to :meth:`.genetic_relatedness`.</span>
<span class="sd">        Specifically, this computes :meth:`.genetic_relatedness` with</span>
<span class="sd">        ``centre=True`` and ``proportion=False`` (with caveats, see below).</span>

<span class="sd">        *Warning:* in some cases, this does not compute exactly the same thing as</span>
<span class="sd">        :meth:`.genetic_relatedness`: see below for more details.</span>

<span class="sd">        If `mode=&quot;branch&quot;`, then the value obtained is the same as that from</span>
<span class="sd">        :meth:`.genetic_relatedness`, using the options `centre=True` and</span>
<span class="sd">        `proportion=False`. The same is true if `mode=&quot;site&quot;` and all sites have</span>
<span class="sd">        at most one mutation.</span>

<span class="sd">        However, if some sites have more than one mutation, the value may differ</span>
<span class="sd">        from that given by :meth:`.genetic_relatedness`:, although if the proportion</span>
<span class="sd">        of such sites is small, the difference will be small.</span>
<span class="sd">        The reason is that this function (for efficiency) computes relatedness</span>
<span class="sd">        using :meth:`.divergence_matrix` and the following relationship.</span>
<span class="sd">        &quot;Relatedness&quot; measures the number of *shared* alleles (or branches),</span>
<span class="sd">        while &quot;divergence&quot; measures the number of *non-shared* alleles (or branches).</span>
<span class="sd">        Let :math:`T_i` be the total distance from sample :math:`i` up to the root;</span>
<span class="sd">        then if :math:`D_{ij}` is the branch-mode divergence between :math:`i` and</span>
<span class="sd">        :math:`j` and :math:`R_{ij}` is the branch-mode relatedness between :math:`i`</span>
<span class="sd">        and :math:`j`, then :math:`T_i + T_j = D_{ij} + 2 R_{ij}.`</span>
<span class="sd">        So, for any samples :math:`I`, :math:`J`, :math:`S`, :math:`T`</span>
<span class="sd">        (that may now be random choices),</span>
<span class="sd">        :math:`R_{IJ}-R_{IS}-R_{JT}+R_{ST} = (D_{IJ}-D_{IS}-D_{JT}+D_{ST})/ (-2)`.</span>
<span class="sd">        This is exactly what we want for (centered) relatedness.</span>
<span class="sd">        However, this relationship does not necessarily hold for `mode=&quot;site&quot;`:</span>
<span class="sd">        it does hold if we can treat &quot;number of differing alleles&quot; as distances</span>
<span class="sd">        on the tree, but this is not necessarily the case in the presence of</span>
<span class="sd">        multiple mutations.</span>

<span class="sd">        Another note regarding the above relationship between :math:`R` and :math:`D`</span>
<span class="sd">        is that :meth:`.divergence` of a sample set to itself does not include</span>
<span class="sd">        the &quot;self&quot; comparisons (so as to provide an unbiased estimator of a</span>
<span class="sd">        population quantity), while the usual definition of genetic relatedness</span>
<span class="sd">        *does* include such comparisons (to provide, for instance, an appropriate</span>
<span class="sd">        value for prospective results beginning with only a given set of</span>
<span class="sd">        individuals). So, diagonal entries in the relatedness matrix returned here</span>
<span class="sd">        are obtained from :meth:`divergence_matrix` after first correcting</span>
<span class="sd">        diagonals to include these &quot;self&quot; comparisons.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: An array indexed by (window, sample_set, sample_set), or if windows is</span>
<span class="sd">            `None`, an array indexed by (sample_set, sample_set).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Further notes on the relationship between relatedness (R)</span>
        <span class="c1"># and divergence (D) in mode=&quot;site&quot;:</span>
        <span class="c1"># The summary function for divergence is &quot;p (1-q)&quot;,</span>
        <span class="c1"># where p and q are the allele frequencies in the two sample sets;</span>
        <span class="c1"># while for relatedness it is &quot;pq&quot;. Summing across *all* alleles,</span>
        <span class="c1"># we get that relatedness plus divergence is</span>
        <span class="c1"># p1 (1-q1) + p1 q1 + ... + pk (1-qk) + pk qk = p1 + ... + pk = 1 .</span>
        <span class="c1"># This implies that</span>
        <span class="c1"># ts.divergence(..., span_normalise=False)</span>
        <span class="c1"># + ts.genetic_relatedness(..., span_normalise=False, centre=False,</span>
        <span class="c1">#       proportion=False, polarised=False)</span>
        <span class="c1"># == ts.num_sites</span>
        <span class="c1"># This could be the basis for a similar relationship between R and D.</span>
        <span class="c1"># However, that relationship holds only with polarised=False, which is not</span>
        <span class="c1"># the default, or what this function does (for good reason).</span>
        <span class="c1"># So, without setting polarised=False, we have that that for samples i and j,</span>
        <span class="c1"># divergence plus relatedness is equal to (something like)</span>
        <span class="c1"># the total number of sites at which both i and j are ancestral;</span>
        <span class="c1"># this depends on the samples and so does not cancel out of the centred</span>
        <span class="c1"># version. We could work through these relationships to figure out what exactly</span>
        <span class="c1"># the difference between genetic_relatedness_matrix(mode=&quot;site&quot;) and</span>
        <span class="c1"># genetic_relatedness(mode=&quot;site&quot;) is, in the general case of multiple</span>
        <span class="c1"># mutations... but that would be confusing, probably not that useful,</span>
        <span class="c1"># and the short version of all this is that &quot;it&#39;s complicated&quot;.</span>

        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">divergence_matrix</span><span class="p">(</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">])</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_normalise</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">B</span>
            <span class="c1"># correct for lack of self comparisons in divergence</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">K</span> <span class="o">=</span> <span class="n">B</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">K</span> <span class="o">-=</span> <span class="n">X</span>
            <span class="k">return</span> <span class="n">K</span> <span class="o">/</span> <span class="o">-</span><span class="mi">2</span>

        <span class="k">if</span> <span class="n">windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_normalise</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">_normalise</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">D</span></div>


<div class="viewcode-block" id="TreeSequence.genetic_relatedness_weighted">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.genetic_relatedness_weighted">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">genetic_relatedness_weighted</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">W</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">centre</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes weighted genetic relatedness. If the :math:`k` th pair of indices</span>
<span class="sd">        is (i, j) then the :math:`k` th column of output will be</span>
<span class="sd">        :math:`\sum_{a,b} W_{ai} W_{bj} C_{ab}`,</span>
<span class="sd">        where :math:`W` is the matrix of weights, and :math:`C_{ab}` is the</span>
<span class="sd">        :meth:`genetic_relatedness &lt;.TreeSequence.genetic_relatedness&gt;` between sample</span>
<span class="sd">        a and sample b, summing over all pairs of samples in the tree sequence.</span>

<span class="sd">        *Note:* the genetic relatedness matrix :math:`C` here is as returned by</span>
<span class="sd">        :meth:`.genetic_relatedness`, rather than by :meth:`.genetic_relatedness_matrix`</span>
<span class="sd">        (see the latter&#39;s documentation for the difference).</span>

<span class="sd">        :param numpy.ndarray W: An array of values with one row for each sample node and</span>
<span class="sd">            one column for each set of weights.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None (default). Note that if</span>
<span class="sd">            indexes = None, then W must have exactly two columns and this is equivalent</span>
<span class="sd">            to indexes = [(0,1)].</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :param bool polarised: Whether to leave the ancestral state out of computations:</span>
<span class="sd">            see :ref:`sec_stats` for more details. Defaults to True.</span>
<span class="sd">        :param bool centre: Defaults to True. Whether to &#39;centre&#39; the result, as</span>
<span class="sd">            described above (the usual definition is centred).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;First trait dimension must be equal to number of samples.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_weighted_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">genetic_relatedness_weighted</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
            <span class="n">centre</span><span class="o">=</span><span class="n">centre</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.genetic_relatedness_vector">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.genetic_relatedness_vector">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">genetic_relatedness_vector</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">W</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">centre</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the product of the genetic relatedness matrix and a vector of weights</span>
<span class="sd">        (one per sample). The output is a (num windows) x (num samples) x (num weights)</span>
<span class="sd">        array whose :math:`(w,i,j)`-th element is :math:`\sum_{b} W_{bj} C_{ib}`,</span>
<span class="sd">        where :math:`W` is the matrix of weights, and :math:`C_{ab}` is the</span>
<span class="sd">        :meth:`genetic_relatedness &lt;.TreeSequence.genetic_relatedness&gt;` between sample</span>
<span class="sd">        `a` and sample `b` in window `w`, and the sum is over all samples in the tree</span>
<span class="sd">        sequence.  Like other statistics, if windows is None, the first dimension in</span>
<span class="sd">        the output is dropped.</span>

<span class="sd">        The relatedness used here corresponds to `polarised=True`; no unpolarised option</span>
<span class="sd">        is available for this method.</span>

<span class="sd">        Optionally, you may provide a list of focal nodes that modifies the behavior</span>
<span class="sd">        as follows. If `nodes` is a list of `n` node IDs (that do not need to be</span>
<span class="sd">        samples), then the output will have dimension (num windows) x n x (num weights),</span>
<span class="sd">        and the matrix :math:`C` used in the definition above is the rectangular matrix</span>
<span class="sd">        with :math:`C_{ij}` the relatedness between `nodes[i]` and `samples[j]`. This</span>
<span class="sd">        can only be used with `centre=False`; if relatedness between uncentred nodes</span>
<span class="sd">        and centred samples is desired, then simply subtract column means from `W` first.</span>
<span class="sd">        The default is `nodes=None`, which is equivalent to setting `nodes` equal to</span>
<span class="sd">        `ts.samples()`.</span>

<span class="sd">        :param numpy.ndarray W: An array of values with one row for each sample node and</span>
<span class="sd">            one column for each set of weights.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :param bool centre: Whether to use the *centred* relatedness matrix or not:</span>
<span class="sd">            see :meth:`genetic_relatedness &lt;.TreeSequence.genetic_relatedness&gt;`.</span>
<span class="sd">        :param list nodes: Optionally, a list of focal nodes as described above</span>
<span class="sd">            (default: None).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num samples, num weights),</span>
<span class="sd">            or (num samples, num weights) if windows is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="s2">&quot;__len__&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;First weight dimension must be equal to number of samples.&quot;</span>
            <span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__weighted_vector_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">genetic_relatedness_vector</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">centre</span><span class="o">=</span><span class="n">centre</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">nodes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_expand_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>

        <span class="k">return</span> <span class="n">y</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_genetic_relatedness_vector_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">centre</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">-</span> <span class="n">arr</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">centre</span> <span class="k">else</span> <span class="n">arr</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_indices</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genetic_relatedness_vector</span><span class="p">(</span>
            <span class="n">W</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">centre</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># &lt;- non-default!</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">centre</span> <span class="k">else</span> <span class="n">x</span>

        <span class="k">return</span> <span class="n">x</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_genetic_relatedness_vector_individual</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">centre</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individual</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">nodes</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">samples</span><span class="p">,</span> <span class="n">sample_individuals</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">ij</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">ij</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">ploidy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">sample_individuals</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">arr</span> <span class="o">-</span> <span class="n">arr</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">centre</span> <span class="k">else</span> <span class="n">arr</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">sample_individuals</span><span class="p">]</span> <span class="o">/</span> <span class="n">ploidy</span><span class="p">[</span><span class="n">sample_individuals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expand_indices</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">samples</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">genetic_relatedness_vector</span><span class="p">(</span>
            <span class="n">W</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">centre</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">nodes</span><span class="o">=</span><span class="n">samples</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># &lt;- non-default!</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">bincount_fn</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">sample_individuals</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">ploidy</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">bincount_fn</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">centre</span> <span class="k">else</span> <span class="n">x</span>  <span class="c1"># centering within index in cols</span>

        <span class="k">return</span> <span class="n">x</span>

<div class="viewcode-block" id="TreeSequence.pca">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.pca">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pca</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_components</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">windows</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">samples</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">individuals</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">time_windows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;branch&quot;</span><span class="p">,</span>
        <span class="n">centre</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">num_iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">num_oversamples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">range_sketch</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs principal component analysis (PCA) for a given set of samples or</span>
<span class="sd">        individuals (default: all samples). The principal components are the</span>
<span class="sd">        eigenvectors of the genetic relatedness matrix, which are obtained by a</span>
<span class="sd">        randomized singular value decomposition (rSVD) algorithm.</span>

<span class="sd">        Concretely, take :math:`M` as the matrix of non-span-normalised</span>
<span class="sd">        genetic relatedness values, for instance obtained by</span>
<span class="sd">        setting :math:`M_{ij}` to be the :meth:`~.TreeSequence.genetic_relatedness`</span>
<span class="sd">        between sample :math:`i` and sample :math:`j` with the specified ``mode``,</span>
<span class="sd">        ``proportion=False`` and ``span_normalise=False``. Then by default this</span>
<span class="sd">        returns the top ``num_components`` eigenvectors of :math:`M`, so that</span>
<span class="sd">        ``output.factors[i,k]`` is the position of sample `i` on the `k` th PC.</span>
<span class="sd">        If ``samples`` or ``individuals`` are provided, then this does the same</span>
<span class="sd">        thing, except with :math:`M_{ij}` either the relatedness between</span>
<span class="sd">        ``samples[i]`` and ``samples[j]`` or the average relatedness between the</span>
<span class="sd">        nodes of ``individuals[i]`` and ``individuals[j]``, respectively.</span>
<span class="sd">        Factors are normalized to have norm 1, i.e.,</span>
<span class="sd">        ``output.factors[:,k] ** 2).sum() == 1)`` for any ``k``.</span>

<span class="sd">        The parameters ``centre`` and ``mode`` are passed to</span>
<span class="sd">        :meth:`~.TreeSequence.genetic_relatedness`: the default ``centre=True`` results</span>
<span class="sd">        in factors whose elements sum to zero; ``mode`` currently only supports the</span>
<span class="sd">        ``&quot;branch&quot;`` setting. If ``windows`` are provided then PCA is carried out</span>
<span class="sd">        separately in each genomic window. If ``time_windows`` is provided, then genetic</span>
<span class="sd">        relatedness is measured using only ancestral material within the given time</span>
<span class="sd">        window (see :meth:`decapitate &lt;.TreeSequence.decapitate&gt;` for how this is</span>
<span class="sd">        defined).</span>

<span class="sd">        So that the method scales to large tree sequences, the underlying method</span>
<span class="sd">        relies on a randomized SVD algorithm, using</span>
<span class="sd">        :meth:`genetic_relatedness_vector &lt;.TreeSequence.genetic_relatedness_vector&gt;`).</span>
<span class="sd">        Larger values of ``num_iterations`` and</span>
<span class="sd">        ``num_oversamples`` should produce better approximations to the true eigenvalues,</span>
<span class="sd">        at the cost of greater compute times and/or memory usage. The method relies on</span>
<span class="sd">        constructing ``range_sketch``, a low-dimensional approximation to the range</span>
<span class="sd">        of :math:`M`, so that the result of a previous call to ``pca()`` may be passed</span>
<span class="sd">        in.</span>

<span class="sd">        To check for convergence, compare</span>
<span class="sd">        ``pc1 = ts.pca()`` and ``pc2 = ts.pca(range_sketch=pc1.range_sketch)``; the</span>
<span class="sd">        difference between ``pc1.factors`` and ``pc2.factors`` provides a</span>
<span class="sd">        diagnostic of the convergence of the algorithm (i.e., if they are close</span>
<span class="sd">        then it has likely converged). Alternatively, the output value of ``error_bound``</span>
<span class="sd">        gives an approximate upper bound for the spectral norm of the difference</span>
<span class="sd">        between :math:`M` and the projection of :math:`M` into the space spanned by</span>
<span class="sd">        the columns of ``range_sketch``.</span>
<span class="sd">        Algorithms are based on Algorithms 8</span>
<span class="sd">        and 9 in Martinsson and Tropp, https://arxiv.org/pdf/2002.01387 .</span>

<span class="sd">        :param int num_components: Number of principal components to return.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in (default: the entire genome).</span>
<span class="sd">        :param numpy.ndarray samples: Samples to perform PCA with (default: all samples).</span>
<span class="sd">        :param numpy.ndarray individuals: Individuals to perform PCA with. Cannot specify</span>
<span class="sd">            both ``samples`` and ``individuals``.</span>
<span class="sd">        :param numpy.ndarray time_windows: The time interval on which to apply PCA:</span>
<span class="sd">            currently, this must be either None (default, covers all time)</span>
<span class="sd">            or a single interval.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of relatedness to be computed</span>
<span class="sd">            (defaults to &quot;branch&quot;; see</span>
<span class="sd">            :meth:`genetic_relatedness_vector</span>
<span class="sd">            &lt;.TreeSequence.genetic_relatedness_vector&gt;`).</span>
<span class="sd">        :param bool centre: Whether to centre the genetic relatedness matrix.</span>
<span class="sd">        :param int num_iterations: Number of power iterations used in the range finding</span>
<span class="sd">            algorithm.</span>
<span class="sd">        :param int num_oversamples: Number of additional test vectors (default: 10).</span>
<span class="sd">            Cannot specify along with range_sketch.</span>
<span class="sd">        :param int random_seed: The random seed. If this is None, a random seed will</span>
<span class="sd">            be automatically generated. Valid random seeds are between 1 and</span>
<span class="sd">            :math:`2^32  1`. Only used if `range_sketch` is not provided.</span>
<span class="sd">        :param numpy.ndarray range_sketch: Sketch matrix for each window. Default is</span>
<span class="sd">            randomly generated; cannot specify along with num_oversamples.</span>
<span class="sd">        :return: A :class:`PCAResult` object, containing estimated principal components,</span>
<span class="sd">            eigenvalues, and other information:</span>
<span class="sd">            the principal component loadings are in PCAResult.factors</span>
<span class="sd">            and the principal values are in PCAResult.eigenvalues.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="ow">or</span> <span class="n">num_iterations</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_iterations should be a positive integer.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">individuals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">individuals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Samples and individuals cannot be used at the same time&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_type</span> <span class="o">=</span> <span class="s2">&quot;node&quot;</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">individuals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">output_type</span> <span class="o">=</span> <span class="s2">&quot;individual&quot;</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">individuals</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">time_windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tree_sequence_low</span><span class="p">,</span> <span class="n">tree_sequence_high</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">time_windows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">time_windows</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">),</span> <span class="s2">&quot;The second argument should be larger.&quot;</span>
            <span class="n">tree_sequence_low</span><span class="p">,</span> <span class="n">tree_sequence_high</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">decapitate</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">decapitate</span><span class="p">(</span><span class="n">time_windows</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">)</span>

        <span class="n">drop_windows</span> <span class="o">=</span> <span class="n">windows</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_windows</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span>
        <span class="n">num_windows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">num_windows</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have at least one window.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_components</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Number of components must be less than or equal to &quot;</span>
                <span class="s2">&quot;the number of samples (or individuals, if specified).&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">num_oversamples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">range_sketch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both num_oversamples and range_sketch.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">range_sketch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num_oversamples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">num_oversamples</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">dim</span> <span class="o">-</span> <span class="n">num_components</span><span class="p">)</span>

            <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>
            <span class="n">range_sketch</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_windows</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">num_components</span> <span class="o">+</span> <span class="n">num_oversamples</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">drop_windows</span><span class="p">:</span>
                <span class="n">range_sketch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">range_sketch</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">range_sketch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num_components</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;range_sketch must have at least as many columns as num_components&quot;</span>
                <span class="p">)</span>
            <span class="n">num_oversamples</span> <span class="o">=</span> <span class="n">range_sketch</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">num_components</span>

        <span class="n">num_vectors</span> <span class="o">=</span> <span class="n">num_components</span> <span class="o">+</span> <span class="n">num_oversamples</span>
        <span class="k">if</span> <span class="n">num_vectors</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Number of columns in range_sketch &quot;</span>
                <span class="s2">&quot;(num_components + num_oversamples) must be less&quot;</span>
                <span class="s2">&quot; than or equal to the number of samples&quot;</span>
                <span class="s2">&quot; (or individuals, if specified).&quot;</span>
            <span class="p">)</span>
        <span class="n">rs_exp_dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_windows</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">num_vectors</span><span class="p">)</span>
        <span class="n">rs_obs_dims</span> <span class="o">=</span> <span class="n">range_sketch</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">rs_obs_dims</span> <span class="o">!=</span> <span class="n">rs_exp_dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">drop_windows</span><span class="p">:</span>
                <span class="n">rs_obs_dims</span> <span class="o">=</span> <span class="n">rs_obs_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">rs_exp_dims</span> <span class="o">=</span> <span class="n">rs_exp_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Incorrect shape of range_sketch:&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; expected </span><span class="si">{</span><span class="n">rs_exp_dims</span><span class="si">}</span><span class="s2">; got </span><span class="si">{</span><span class="n">rs_obs_dims</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_rand_pow_range_finder</span><span class="p">(</span>
            <span class="n">operator</span><span class="p">,</span>
            <span class="n">operator_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">num_vectors</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">Q</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Algorithm 9 in https://arxiv.org/pdf/2002.01387</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">num_vectors</span> <span class="o">&gt;=</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">),</span> <span class="s2">&quot;num_vectors should not be smaller than rank&quot;</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
                <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">Q</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">Q</span> <span class="o">=</span> <span class="n">operator</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">Q</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">Q</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_rand_svd</span><span class="p">(</span>
            <span class="n">operator</span><span class="p">,</span>
            <span class="n">operator_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">rank</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">num_vectors</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">range_sketch</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Algorithm 8 in https://arxiv.org/pdf/2002.01387</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="n">num_vectors</span> <span class="o">&gt;=</span> <span class="n">rank</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">_rand_pow_range_finder</span><span class="p">(</span>
                <span class="n">operator</span><span class="p">,</span>
                <span class="n">operator_dim</span><span class="p">,</span>
                <span class="n">rank</span><span class="o">=</span><span class="n">num_vectors</span><span class="p">,</span>
                <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span>
                <span class="n">num_vectors</span><span class="o">=</span><span class="n">num_vectors</span><span class="p">,</span>
                <span class="n">Q</span><span class="o">=</span><span class="n">range_sketch</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">operator</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">U_hat</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">@</span> <span class="n">U_hat</span>

            <span class="n">error_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span>
                <span class="mi">1</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">operator_dim</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">rank</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))),</span>
                <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">error_bound</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">rank</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">error_factor</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">U</span><span class="p">[:,</span> <span class="p">:</span><span class="n">rank</span><span class="p">],</span> <span class="n">D</span><span class="p">[:</span><span class="n">rank</span><span class="p">],</span> <span class="n">Q</span><span class="p">,</span> <span class="n">error_bound</span>

        <span class="n">_f_high</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">tree_sequence_high</span><span class="o">.</span><span class="n">_genetic_relatedness_vector_node</span>
            <span class="k">if</span> <span class="n">output_type</span> <span class="o">==</span> <span class="s2">&quot;node&quot;</span>
            <span class="k">else</span> <span class="n">tree_sequence_high</span><span class="o">.</span><span class="n">_genetic_relatedness_vector_individual</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">time_windows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_f_low</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">tree_sequence_low</span><span class="o">.</span><span class="n">_genetic_relatedness_vector_node</span>
                <span class="k">if</span> <span class="n">output_type</span> <span class="o">==</span> <span class="s2">&quot;node&quot;</span>
                <span class="k">else</span> <span class="n">tree_sequence_low</span><span class="o">.</span><span class="n">_genetic_relatedness_vector_individual</span>
            <span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">samples</span> <span class="k">if</span> <span class="n">output_type</span> <span class="o">==</span> <span class="s2">&quot;node&quot;</span> <span class="k">else</span> <span class="n">individuals</span>

        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_windows</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">num_components</span><span class="p">))</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_windows</span><span class="p">,</span> <span class="n">num_components</span><span class="p">))</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_windows</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">num_vectors</span><span class="p">))</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">num_windows</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_windows</span><span class="p">):</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">_G</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="p">):</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">_f_high</span><span class="p">(</span>
                    <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
                    <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                    <span class="n">centre</span><span class="o">=</span><span class="n">centre</span><span class="p">,</span>
                    <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">time_windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">high</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">low</span> <span class="o">=</span> <span class="n">_f_low</span><span class="p">(</span>
                        <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
                        <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span>
                        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                        <span class="n">centre</span><span class="o">=</span><span class="n">centre</span><span class="p">,</span>
                        <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="n">high</span> <span class="o">-</span> <span class="n">low</span>

            <span class="n">U</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_rand_svd</span><span class="p">(</span>
                <span class="n">operator</span><span class="o">=</span><span class="n">_G</span><span class="p">,</span>
                <span class="n">operator_dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
                <span class="n">rank</span><span class="o">=</span><span class="n">num_components</span><span class="p">,</span>
                <span class="n">depth</span><span class="o">=</span><span class="n">num_iterations</span><span class="p">,</span>
                <span class="n">num_vectors</span><span class="o">=</span><span class="n">num_vectors</span><span class="p">,</span>
                <span class="n">range_sketch</span><span class="o">=</span><span class="n">range_sketch</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">drop_windows</span><span class="p">:</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">pca_result</span> <span class="o">=</span> <span class="n">PCAResult</span><span class="p">(</span><span class="n">factors</span><span class="o">=</span><span class="n">U</span><span class="p">,</span> <span class="n">eigenvalues</span><span class="o">=</span><span class="n">D</span><span class="p">,</span> <span class="n">range_sketch</span><span class="o">=</span><span class="n">Q</span><span class="p">,</span> <span class="n">error_bound</span><span class="o">=</span><span class="n">E</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pca_result</span></div>


<div class="viewcode-block" id="TreeSequence.trait_covariance">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.trait_covariance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trait_covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the mean squared covariances between each of the columns of ``W``</span>
<span class="sd">        (the &quot;phenotypes&quot;) and inheritance along the tree sequence.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        Operates on all samples in the tree sequence.</span>

<span class="sd">        Concretely, if `g` is a binary vector that indicates inheritance from an allele,</span>
<span class="sd">        branch, or node and `w` is a column of W, normalised to have mean zero,</span>
<span class="sd">        then the covariance of `g` and `w` is :math:`\\sum_i g_i w_i`, the sum of the</span>
<span class="sd">        weights corresponding to entries of `g` that are `1`. Since weights sum to</span>
<span class="sd">        zero, this is also equal to the sum of weights whose entries of `g` are 0.</span>
<span class="sd">        So, :math:`cov(g,w)^2 = ((\\sum_i g_i w_i)^2 + (\\sum_i (1-g_i) w_i)^2)/2`.</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            The sum of squared covariances between presence/absence of each allele and</span>
<span class="sd">            phenotypes, divided by length of the window (if ``span_normalise=True``).</span>
<span class="sd">            This is computed as sum_a (sum(w[a])^2 / 2), where</span>
<span class="sd">            w is a column of W with the average subtracted off,</span>
<span class="sd">            and w[a] is the sum of all entries of w corresponding to samples</span>
<span class="sd">            carrying allele &quot;a&quot;, and the first sum is over all alleles.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The sum of squared covariances between the split induced by each branch and</span>
<span class="sd">            phenotypes, multiplied by branch length, averaged across trees in</span>
<span class="sd">            the window. This is computed as above: a branch with total weight</span>
<span class="sd">            w[b] below b contributes (branch length) * w[b]^2 to the total</span>
<span class="sd">            value for a tree. (Since the sum of w is zero, the total weight</span>
<span class="sd">            below b and not below b are equal, canceling the factor of 2</span>
<span class="sd">            above.)</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the squared covariance between the property of</span>
<span class="sd">            inheriting from this node and phenotypes, computed as in &quot;branch&quot;.</span>

<span class="sd">        :param numpy.ndarray W: An array of values with one row for each sample and one</span>
<span class="sd">            column for each &quot;phenotype&quot;.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If windows=None and W is a single column, a numpy scalar is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;First trait dimension must be equal to number of samples.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">trait_covariance</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.trait_correlation">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.trait_correlation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trait_correlation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the mean squared correlations between each of the columns of ``W``</span>
<span class="sd">        (the &quot;phenotypes&quot;) and inheritance along the tree sequence.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        Operates on all samples in the tree sequence.</span>

<span class="sd">        This is computed as squared covariance in</span>
<span class="sd">        :meth:`trait_covariance &lt;.TreeSequence.trait_covariance&gt;`,</span>
<span class="sd">        but divided by :math:`p (1-p)`, where `p` is the proportion of samples</span>
<span class="sd">        inheriting from the allele, branch, or node in question.</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            The sum of squared correlations between presence/absence of each allele and</span>
<span class="sd">            phenotypes, divided by length of the window (if ``span_normalise=True``).</span>
<span class="sd">            This is computed as the</span>
<span class="sd">            :meth:`trait_covariance &lt;.TreeSequence.trait_covariance&gt;`</span>
<span class="sd">            divided by the variance of the relevant column of W</span>
<span class="sd">            and by :math:`p * (1 - p)`, where :math:`p` is the allele frequency.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The sum of squared correlations between the split induced by each branch and</span>
<span class="sd">            phenotypes, multiplied by branch length, averaged across trees in</span>
<span class="sd">            the window. This is computed as the</span>
<span class="sd">            :meth:`trait_covariance &lt;.TreeSequence.trait_covariance&gt;`,</span>
<span class="sd">            divided by the variance of the column of w</span>
<span class="sd">            and by :math:`p * (1 - p)`, where :math:`p` is the proportion of</span>
<span class="sd">            the samples lying below the branch.</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the squared correlation between the property of</span>
<span class="sd">            inheriting from this node and phenotypes, computed as in &quot;branch&quot;.</span>

<span class="sd">        Note that above we divide by the **sample** variance, which for a</span>
<span class="sd">        vector x of length n is ``np.var(x) * n / (n-1)``.</span>

<span class="sd">        :param numpy.ndarray W: An array of values with one row for each sample and one</span>
<span class="sd">            column for each &quot;phenotype&quot;. Each column must have positive standard</span>
<span class="sd">            deviation.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If windows=None and W is a single column, a numpy scalar is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;First trait dimension must be equal to number of samples.&quot;</span>
            <span class="p">)</span>
        <span class="n">sds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Weight columns must have positive variance&quot;</span><span class="p">,</span> <span class="s2">&quot;to compute correlation.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">trait_correlation</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.trait_regression">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.trait_regression">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trait_regression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated synonym for</span>
<span class="sd">        :meth:`trait_linear_model &lt;.TreeSequence.trait_linear_model&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;This is deprecated: please use trait_linear_model( ) instead.&quot;</span><span class="p">,</span>
            <span class="ne">FutureWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trait_linear_model</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.trait_linear_model">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.trait_linear_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trait_linear_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">W</span><span class="p">,</span>
        <span class="n">Z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the relationship between trait and genotype after accounting for</span>
<span class="sd">        covariates.  Concretely, for each trait w (i.e., each column of W),</span>
<span class="sd">        this does a least-squares fit of the linear model :math:`w \\sim g + Z`,</span>
<span class="sd">        where :math:`g` is inheritance in the tree sequence (e.g., genotype)</span>
<span class="sd">        and the columns of :math:`Z` are covariates, and returns the squared</span>
<span class="sd">        coefficient of :math:`g` in this linear model.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        Operates on all samples in the tree sequence.</span>

<span class="sd">        To do this, if `g` is a binary vector that indicates inheritance from an allele,</span>
<span class="sd">        branch, or node and `w` is a column of W, there are :math:`k` columns of</span>
<span class="sd">        :math:`Z`, and the :math:`k+2`-vector :math:`b` minimises</span>
<span class="sd">        :math:`\\sum_i (w_i - b_0 - b_1 g_i - b_2 z_{2,i} - ... b_{k+2} z_{k+2,i})^2`</span>
<span class="sd">        then this returns the number :math:`b_1^2`. If :math:`g` lies in the linear span</span>
<span class="sd">        of the columns of :math:`Z`, then :math:`b_1` is set to 0. To fit the</span>
<span class="sd">        linear model without covariates (only the intercept), set `Z = None`.</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            Computes the sum of :math:`b_1^2/2` for each allele in the window,</span>
<span class="sd">            as above with :math:`g` indicating presence/absence of the allele,</span>
<span class="sd">            then divided by the length of the window if ``span_normalise=True``.</span>
<span class="sd">            (For biallelic loci, this number is the same for both alleles, and so summing</span>
<span class="sd">            over each cancels the factor of two.)</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The squared coefficient :math:`b_1^2`, computed for the split induced by each</span>
<span class="sd">            branch (i.e., with :math:`g` indicating inheritance from that branch),</span>
<span class="sd">            multiplied by branch length and tree span, summed over all trees</span>
<span class="sd">            in the window, and divided by the length of the window if</span>
<span class="sd">            ``span_normalise=True``.</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the squared coefficient :math:`b_1^2`, computed for</span>
<span class="sd">            the property of inheriting from this node, as in &quot;branch&quot;.</span>

<span class="sd">        :param numpy.ndarray W: An array of values with one row for each sample and one</span>
<span class="sd">            column for each &quot;phenotype&quot;.</span>
<span class="sd">        :param numpy.ndarray Z: An array of values with one row for each sample and one</span>
<span class="sd">            column for each &quot;covariate&quot;, or `None`. Columns of `Z` must be linearly</span>
<span class="sd">            independent.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If windows=None and W is a single column, a numpy scalar is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">W</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;First trait dimension must be equal to number of samples.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">Z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tZ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">Z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">tZ</span><span class="p">)</span> <span class="o">==</span> <span class="n">tZ</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="n">tZ</span>
        <span class="k">if</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;First dimension of Z must equal the number of samples.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Matrix of covariates is computationally singular.&quot;</span><span class="p">)</span>
        <span class="c1"># numpy returns a lower-triangular cholesky</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">K</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__run_windowed_stat</span><span class="p">(</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">trait_linear_model</span><span class="p">,</span>
            <span class="n">W</span><span class="p">,</span>
            <span class="n">Z</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.segregating_sites">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.segregating_sites">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">segregating_sites</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the density of segregating sites for each of the sets of nodes</span>
<span class="sd">        from ``sample_sets``, and related quantities.</span>
<span class="sd">        Please see the :ref:`one-way statistics &lt;sec_stats_sample_sets_one_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` argument is interpreted</span>
<span class="sd">        and how it interacts with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`, :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``. For a sample set ``A``, computes:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            The sum over sites of [the number of alleles found in ``A`` at each site</span>
<span class="sd">            minus one], per unit of chromosome length.</span>
<span class="sd">            If all sites have at most two alleles in ``A``,</span>
<span class="sd">            this is the density of segregating/polymorphic sites in ``A``</span>
<span class="sd">            (since the &quot;minus one&quot; reduces the sum for monoallelic sites).</span>
<span class="sd">            For sites with more than two alleles, the sum is increased by</span>
<span class="sd">            one for each additional allele segregating in ``A``.</span>
<span class="sd">            To get the **number** of segregating alleles in ``A``,</span>
<span class="sd">            use ``span_normalise=False``.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The total length of all branches in the tree subtended by the samples in</span>
<span class="sd">            ``A``, averaged across the window.</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            The proportion of the window on which the node is ancestral to some,</span>
<span class="sd">            but not all, of the samples in ``A``.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If there is one sample set and windows=None, a numpy scalar is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__one_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">segregating_sites</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.allele_frequency_spectrum">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.allele_frequency_spectrum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">allele_frequency_spectrum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time_windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">polarised</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the allele frequency spectrum (AFS) in windows across the genome for</span>
<span class="sd">        with respect to the specified ``sample_sets``.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`sample sets &lt;sec_stats_sample_sets&gt;`,</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        :ref:`polarised &lt;sec_stats_polarisation&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        and see :ref:`sec_tutorial_afs` for examples of how to use this method.</span>

<span class="sd">        Similar to other windowed stats, the first dimension in the returned array</span>
<span class="sd">        corresponds to windows, such that ``result[i]`` is the AFS in the ith</span>
<span class="sd">        window. The AFS in each window is a k-dimensional numpy array, where k is</span>
<span class="sd">        the number of input sample sets, such that ``result[i, j0, j1, ...]`` is the</span>
<span class="sd">        value associated with frequency ``j0`` in ``sample_sets[0]``, ``j1`` in</span>
<span class="sd">        ``sample_sets[1]``, etc, in window ``i``. From here, we will assume that</span>
<span class="sd">        ``afs`` corresponds to the result in a single window, i.e.,</span>
<span class="sd">        ``afs = result[i]``.</span>

<span class="sd">        If a single sample set is specified, the allele frequency spectrum within</span>
<span class="sd">        this set is returned, such that ``afs[j]`` is the value associated with</span>
<span class="sd">        frequency ``j``. Thus, singletons are counted in ``afs[1]``, doubletons in</span>
<span class="sd">        ``afs[2]``, and so on. The zeroth entry counts alleles or branches not</span>
<span class="sd">        seen in the samples but that are polymorphic among the rest of the samples</span>
<span class="sd">        of the tree sequence; likewise, the last entry counts alleles fixed in</span>
<span class="sd">        the sample set but polymorphic in the entire set of samples. Please see</span>
<span class="sd">        the :ref:`sec_tutorial_afs_zeroth_entry` for an illustration.</span>

<span class="sd">        .. warning:: Please note that singletons are **not** counted in the initial</span>
<span class="sd">            entry in each AFS array (i.e., ``afs[0]``), but in ``afs[1]``.</span>

<span class="sd">        If ``sample_sets`` is None (the default), the allele frequency spectrum</span>
<span class="sd">        for all samples in the tree sequence is returned. For convenience, if</span>
<span class="sd">        there is only a single sample set, the outer list may be omitted (so that,</span>
<span class="sd">        unlike other statistics, ``sample_sets=[0,1,2]`` is equivalent to</span>
<span class="sd">        ``sample_sets=[[0,1,2]]``).</span>

<span class="sd">        If more than one sample set is specified, the **joint** allele frequency</span>
<span class="sd">        spectrum within windows is returned. For example, if we set</span>
<span class="sd">        ``sample_sets = [S0, S1]``, then afs[1, 2] counts the number of sites that</span>
<span class="sd">        are singletons within S0 and doubletons in S1. The dimensions of the</span>
<span class="sd">        output array will be ``[num_windows] + [1 + len(S) for S in sample_sets]``.</span>

<span class="sd">        If ``polarised`` is False (the default) the AFS will be *folded*, so that</span>
<span class="sd">        the counts do not depend on knowing which allele is ancestral. If folded,</span>
<span class="sd">        the frequency spectrum for a single sample set ``S`` has ``afs[j] = 0`` for</span>
<span class="sd">        all ``j &gt; len(S) / 2``, so that alleles at frequency ``j`` and ``len(S) - j``</span>
<span class="sd">        both add to the same entry. If there is more than one sample set, the</span>
<span class="sd">        returned array is &quot;lower triangular&quot; in a similar way. For more details,</span>
<span class="sd">        especially about handling of multiallelic sites, see :ref:`sec_stats_notes_afs`.</span>

<span class="sd">        What is computed depends on ``mode``:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            The number of alleles at a given frequency within the specified sample</span>
<span class="sd">            sets for each window, per unit of sequence length. To obtain the total</span>
<span class="sd">            number of alleles, set ``span_normalise`` to False.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The total length of branches in the trees subtended by subsets of the</span>
<span class="sd">            specified sample sets, per unit of sequence length. To obtain the</span>
<span class="sd">            total, set ``span_normalise`` to False.</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            Not supported for this method (raises a ValueError).</span>

<span class="sd">        For example, suppose that `S0` is a list of 5 sample IDs, and `S1` is</span>
<span class="sd">        a list of 3 other sample IDs. Then `afs = ts.allele_frequency_spectrum([S0, S1],</span>
<span class="sd">        mode=&quot;site&quot;, span_normalise=False)` will be a 5x3 numpy array, and if</span>
<span class="sd">        there are six alleles that are present in only one sample of `S0` but</span>
<span class="sd">        two samples of `S1`, then `afs[1,2]` will be equal to 6.  Similarly,</span>
<span class="sd">        `branch_afs = ts.allele_frequency_spectrum([S0, S1], mode=&quot;branch&quot;,</span>
<span class="sd">        span_normalise=False)` will also be a 5x3 array, and `branch_afs[1,2]`</span>
<span class="sd">        will be the total area (i.e., length times span) of all branches that</span>
<span class="sd">        are above exactly one sample of `S0` and two samples of `S1`.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of samples to compute the joint allele frequency.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between windows</span>
<span class="sd">            along the genome.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A (k + 1) dimensional numpy array, where k is the number of sample</span>
<span class="sd">            sets specified.</span>
<span class="sd">            If there is one sample set and windows=None, a 1 dimensional array is</span>
<span class="sd">            returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># this also happens in __one_way_sample_set_stat, but we need to do</span>
            <span class="c1"># slightly different pre-processing here to allow for the case that</span>
            <span class="c1"># sample sets is a single list of IDs (for most stats, this would mean</span>
            <span class="c1"># dropping a dimension, but not for the AFS)</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sets</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span><span class="n">sample_sets</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__one_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">allele_frequency_spectrum</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">time_windows</span><span class="o">=</span><span class="n">time_windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.Tajimas_D">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.Tajimas_D">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Tajimas_D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes Tajima&#39;s D of sets of nodes from ``sample_sets`` in windows.</span>
<span class="sd">        Please see the :ref:`one-way statistics &lt;sec_stats_sample_sets_one_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` argument is interpreted</span>
<span class="sd">        and how it interacts with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`, :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        Operates on ``k = 1`` sample sets at a</span>
<span class="sd">        time. For a sample set ``X`` of ``n`` nodes, if and ``T`` is the mean</span>
<span class="sd">        number of pairwise differing sites in ``X`` and ``S`` is the number of</span>
<span class="sd">        sites segregating in ``X`` (computed with :meth:`diversity</span>
<span class="sd">        &lt;.TreeSequence.diversity&gt;` and :meth:`segregating sites</span>
<span class="sd">        &lt;.TreeSequence.segregating_sites&gt;`, respectively, both not span</span>
<span class="sd">        normalised), then Tajima&#39;s D is</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            D = (T - S / h) / sqrt(a * S + (b / c) * S * (S - 1))</span>
<span class="sd">            h = 1 + 1 / 2 + ... + 1 / (n - 1)</span>
<span class="sd">            g = 1 + 1 / 2**2 + ... + 1 / (n - 1) ** 2</span>
<span class="sd">            a = (n + 1) / (3 * (n - 1) * h) - 1 / h**2</span>
<span class="sd">            b = 2 * (n**2 + n + 3) / (9 * n * (n - 1)) - (n + 2) / (h * n) + g / h**2</span>
<span class="sd">            c = h**2 + g</span>

<span class="sd">        What is computed for diversity and segregating sites depends on ``mode``;</span>
<span class="sd">        see those functions for more details.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If there is one sample set and windows=None, a numpy scalar is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO this should be done in C as we&#39;ll want to support this method there.</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">tjd_func</span><span class="p">(</span><span class="n">sample_set_sizes</span><span class="p">,</span> <span class="n">flattened</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">sample_set_sizes</span>
            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="o">.</span><span class="n">diversity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">flattened</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="o">.</span><span class="n">segregating_sites</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">flattened</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span><span class="p">))</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">n</span><span class="p">])</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nn</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="n">n</span><span class="p">])</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">h</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">b</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">9</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">g</span> <span class="o">/</span> <span class="n">h</span><span class="o">**</span><span class="mi">2</span>
                <span class="p">)</span>
                <span class="n">D</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">S</span> <span class="o">/</span> <span class="n">h</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">S</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">/</span> <span class="p">(</span><span class="n">h</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">g</span><span class="p">))</span> <span class="o">*</span> <span class="n">S</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">D</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__one_way_sample_set_stat</span><span class="p">(</span>
            <span class="n">tjd_func</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.Fst">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.Fst">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Fst</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes &quot;windowed&quot; Fst between pairs of sets of nodes from ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 2`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        For sample sets ``X`` and ``Y``, if ``d(X, Y)`` is the</span>
<span class="sd">        :meth:`divergence &lt;.TreeSequence.divergence&gt;`</span>
<span class="sd">        between ``X`` and ``Y``, and ``d(X)`` is the</span>
<span class="sd">        :meth:`diversity &lt;.TreeSequence.diversity&gt;` of ``X``, then what is</span>
<span class="sd">        computed is</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            Fst = 1 - 2 * (d(X) + d(Y)) / (d(X) + 2 * d(X, Y) + d(Y))</span>

<span class="sd">        What is computed for diversity and divergence depends on ``mode``;</span>
<span class="sd">        see those functions for more details.</span>

<span class="sd">        For ``mode=&#39;site&#39;``, this definition of Fst appears as equation (6) in</span>
<span class="sd">        `Slatkin (1991) &lt;https://doi.org/10.1017/S0016672300029827&gt;`_, and</span>
<span class="sd">        is also found as equation (9) in</span>
<span class="sd">        `Nei (1973) &lt;https://doi.org/10.1073/pnas.70.12.3321&gt;`_.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 2-tuples.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If there is one pair of sample sets and windows=None, a numpy scalar is</span>
<span class="sd">            returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO this should really be implemented in C (presumably C programmers will want</span>
        <span class="c1"># to compute Fst too), but in the mean time implementing using the low-level</span>
        <span class="c1"># calls has two advantages: (a) we automatically change dimensions like the other</span>
        <span class="c1"># two-way stats and (b) it&#39;s a bit more efficient because we&#39;re not messing</span>
        <span class="c1"># around with indexes and samples sets twice.</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">fst_func</span><span class="p">(</span>
            <span class="n">sample_set_sizes</span><span class="p">,</span>
            <span class="n">flattened</span><span class="p">,</span>
            <span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="p">,</span>
            <span class="n">polarised</span><span class="p">,</span>
            <span class="n">centre</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="c1"># note: this is kinda hacky - polarised and centre are not used here -</span>
            <span class="c1"># but this seems necessary to use our __k_way_sample_set_stat framework</span>
            <span class="n">divergences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">divergence</span><span class="p">(</span>
                <span class="n">sample_set_sizes</span><span class="p">,</span>
                <span class="n">flattened</span><span class="p">,</span>
                <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
                <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
                <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
                <span class="n">centre</span><span class="o">=</span><span class="n">centre</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">diversities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">diversity</span><span class="p">(</span>
                <span class="n">sample_set_sizes</span><span class="p">,</span>
                <span class="n">flattened</span><span class="p">,</span>
                <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
                <span class="n">polarised</span><span class="o">=</span><span class="n">polarised</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">orig_shape</span> <span class="o">=</span> <span class="n">divergences</span><span class="o">.</span><span class="n">shape</span>
            <span class="c1"># &quot;node&quot; statistics produce a 3D array</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">divergences</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">divergences</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">divergences</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">divergences</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">diversities</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">diversities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">diversities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">fst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">divergences</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">fst</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">divergences</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indexes</span><span class="p">):</span>
                <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">diversities</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">u</span><span class="p">]</span>
                    <span class="o">+</span> <span class="n">diversities</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">v</span><span class="p">]</span>
                    <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">divergences</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                    <span class="n">fst</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span>
                        <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">diversities</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">diversities</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">v</span><span class="p">])</span> <span class="o">/</span> <span class="n">denom</span>
                    <span class="p">)</span>
            <span class="n">fst</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">orig_shape</span>
            <span class="k">return</span> <span class="n">fst</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="n">fst_func</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.Y3">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.Y3">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Y3</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the &#39;Y&#39; statistic between triples of sets of nodes from ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 3`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``. Each is an average across every</span>
<span class="sd">        combination of trios of samples ``(a, b, c)``, one chosen from each sample set:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            The average density of sites at which ``a`` differs from ``b`` and</span>
<span class="sd">            ``c``, per unit of chromosome length.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The average length of all branches that separate ``a`` from ``b``</span>
<span class="sd">            and ``c`` (in units of time).</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the average proportion of the window on which ``a``</span>
<span class="sd">            inherits from that node but ``b`` and ``c`` do not, or vice-versa.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 3-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If there is one triple of sample sets and windows=None, a numpy scalar is</span>
<span class="sd">            returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">Y3</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.Y2">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.Y2">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Y2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the &#39;Y2&#39; statistic between pairs of sets of nodes from ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 2`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``. Each is computed exactly as</span>
<span class="sd">        ``Y3``, except that the average is across every possible trio of samples</span>
<span class="sd">        ``(a, b1, b2)``, where ``a`` is chosen from the first sample set, and</span>
<span class="sd">        ``b1, b2`` are chosen (without replacement) from the second sample set.</span>
<span class="sd">        See :meth:`Y3 &lt;.TreeSequence.Y3&gt;` for more details.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If there is one pair of sample sets and windows=None, a numpy scalar is</span>
<span class="sd">            returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">Y2</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.Y1">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.Y1">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Y1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the &#39;Y1&#39; statistic within each of the sets of nodes given by</span>
<span class="sd">        ``sample_sets``.</span>
<span class="sd">        Please see the :ref:`one-way statistics &lt;sec_stats_sample_sets_one_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` argument is interpreted</span>
<span class="sd">        and how it interacts with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`, :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>
<span class="sd">        Operates on ``k = 1`` sample set at a time.</span>

<span class="sd">        What is computed depends on ``mode``. Each is computed exactly as</span>
<span class="sd">        ``Y3``, except that the average is across every possible trio of samples</span>
<span class="sd">        samples ``(a1, a2, a3)`` all chosen without replacement from the same</span>
<span class="sd">        sample set. See :meth:`Y3 &lt;.TreeSequence.Y3&gt;` for more details.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If there is one sample set and windows=None, a numpy scalar is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__one_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">Y1</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.f4">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.f4">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">f4</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes Patterson&#39;s f4 statistic between four groups of nodes from</span>
<span class="sd">        ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 4`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``. Each is an average across every possible</span>
<span class="sd">        combination of four samples ``(a, b; c, d)``, one chosen from each sample set:</span>

<span class="sd">        &quot;site&quot;</span>
<span class="sd">            The average density of sites at which ``a`` and ``c`` agree but</span>
<span class="sd">            differs from ``b`` and ``d``, minus the average density of sites at</span>
<span class="sd">            which ``a`` and ``d`` agree but differs from ``b`` and ``c``, per</span>
<span class="sd">            unit of chromosome length.</span>

<span class="sd">        &quot;branch&quot;</span>
<span class="sd">            The average length of all branches that separate ``a`` and ``c``</span>
<span class="sd">            from ``b`` and ``d``, minus the average length of all branches that</span>
<span class="sd">            separate ``a`` and ``d`` from ``b`` and ``c`` (in units of time).</span>

<span class="sd">        &quot;node&quot;</span>
<span class="sd">            For each node, the average proportion of the window on which ``a`` and ``c``</span>
<span class="sd">            inherit from that node but ``b`` and ``d`` do not, or vice-versa,</span>
<span class="sd">            minus the average proportion of the window on which ``a`` and ``d``</span>
<span class="sd">            inherit from that node but ``b`` and ``c`` do not, or vice-versa.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 4-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If there are four sample sets and windows=None, a numpy scalar is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">f4</span><span class="p">,</span>
            <span class="mi">4</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.f3">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.f3">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">f3</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes Patterson&#39;s f3 statistic between three groups of nodes from</span>
<span class="sd">        ``sample_sets``.</span>
<span class="sd">        Note that the order of the arguments of f3 differs across the literature:</span>
<span class="sd">        here, ``f3([A, B, C])`` for sample sets ``A``, ``B``, and ``C``</span>
<span class="sd">        will estimate</span>
<span class="sd">        :math:`f_3(A; B, C) = \mathbb{E}[(p_A - p_B) (p_A - p_C)]`,</span>
<span class="sd">        where :math:`p_A` is the allele frequency in ``A``.</span>
<span class="sd">        When used as a test for admixture, the putatively admixed population</span>
<span class="sd">        is usually placed as population ``A`` (see</span>
<span class="sd">        `Peter (2016) &lt;https://doi.org/10.1534/genetics.115.183913&gt;`_</span>
<span class="sd">        for more discussion).</span>

<span class="sd">        Operates on ``k = 3`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``. Each works exactly as</span>
<span class="sd">        :meth:`f4 &lt;.TreeSequence.f4&gt;`, except the average is across every possible</span>
<span class="sd">        combination of four samples ``(a1, b; a2, c)`` where `a1` and `a2` have both</span>
<span class="sd">        been chosen (without replacement) from the first sample set. See</span>
<span class="sd">        :meth:`f4 &lt;.TreeSequence.f4&gt;` for more details.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 3-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If there are three sample sets and windows=None, a numpy scalar is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">f3</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.f2">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.f2">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">f2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes Patterson&#39;s f2 statistic between two groups of nodes from</span>
<span class="sd">        ``sample_sets``.</span>
<span class="sd">        Operates on ``k = 2`` sample sets at a time; please see the</span>
<span class="sd">        :ref:`multi-way statistics &lt;sec_stats_sample_sets_multi_way&gt;`</span>
<span class="sd">        section for details on how the ``sample_sets`` and ``indexes`` arguments are</span>
<span class="sd">        interpreted and how they interact with the dimensions of the output array.</span>
<span class="sd">        See the :ref:`statistics interface &lt;sec_stats_interface&gt;` section for details on</span>
<span class="sd">        :ref:`windows &lt;sec_stats_windows&gt;`,</span>
<span class="sd">        :ref:`mode &lt;sec_stats_mode&gt;`,</span>
<span class="sd">        :ref:`span normalise &lt;sec_stats_span_normalise&gt;`,</span>
<span class="sd">        and :ref:`return value &lt;sec_stats_output_format&gt;`.</span>

<span class="sd">        What is computed depends on ``mode``. Each works exactly as</span>
<span class="sd">        :meth:`f4 &lt;.TreeSequence.f4&gt;`, except the average is across every possible</span>
<span class="sd">        combination of four samples ``(a1, b1; a2, b2)`` where `a1` and `a2` have</span>
<span class="sd">        both been chosen (without replacement) from the first sample set, and ``b1``</span>
<span class="sd">        and ``b2`` have both been chosen (without replacement) from the second</span>
<span class="sd">        sample set. See :meth:`f4 &lt;.TreeSequence.f4&gt;` for more details.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the windows</span>
<span class="sd">            to compute the statistic in.</span>
<span class="sd">        :param str mode: A string giving the &quot;type&quot; of the statistic to be computed</span>
<span class="sd">            (defaults to &quot;site&quot;).</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of the</span>
<span class="sd">            window (defaults to True).</span>
<span class="sd">        :return: A ndarray with shape equal to (num windows, num statistics).</span>
<span class="sd">            If there is one pair of sample sets and windows=None, a numpy scalar is</span>
<span class="sd">            returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_sample_set_stat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">f2</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
            <span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.mean_descendants">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.mean_descendants">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mean_descendants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes for every node the mean number of samples in each of the</span>
<span class="sd">        `sample_sets` that descend from that node, averaged over the</span>
<span class="sd">        portions of the genome for which the node is ancestral to *any* sample.</span>
<span class="sd">        The output is an array, `C[node, j]`, which reports the total span of</span>
<span class="sd">        all genomes in `sample_sets[j]` that inherit from `node`, divided by</span>
<span class="sd">        the total span of the genome on which `node` is an ancestor to any</span>
<span class="sd">        sample in the tree sequence.</span>

<span class="sd">        .. warning:: The interface for this method is preliminary and may be subject to</span>
<span class="sd">            backwards incompatible changes in the near future. The long-term stable</span>
<span class="sd">            API for this method will be consistent with other :ref:`sec_stats`.</span>
<span class="sd">            In particular, the normalization by proportion of the genome that `node`</span>
<span class="sd">            is an ancestor to anyone may not be the default behaviour in the future.</span>

<span class="sd">        :param list sample_sets: A list of lists of node IDs.</span>
<span class="sd">        :return: An array with dimensions (number of nodes in the tree sequence,</span>
<span class="sd">            number of reference sets)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">mean_descendants</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.genealogical_nearest_neighbours">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.genealogical_nearest_neighbours">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">genealogical_nearest_neighbours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">focal</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the genealogical nearest neighbours (GNN) proportions for the given</span>
<span class="sd">        focal nodes, with reference to two or more sets of interest, averaged over all</span>
<span class="sd">        trees in the tree sequence.</span>

<span class="sd">        The GNN proportions for a focal node in a single tree are given by first finding</span>
<span class="sd">        the most recent common ancestral node :math:`a` between the focal node and any</span>
<span class="sd">        other node present in the reference sets. The GNN proportion for a specific</span>
<span class="sd">        reference set, :math:`S` is the number of nodes in :math:`S` that descend from</span>
<span class="sd">        :math:`a`, as a proportion of the total number of descendant nodes in any of the</span>
<span class="sd">        reference sets.</span>

<span class="sd">        For example, consider a case with 2 sample sets, :math:`S_1` and :math:`S_2`.</span>
<span class="sd">        For a given tree, :math:`a` is the node that includes at least one descendant in</span>
<span class="sd">        :math:`S_1` or :math:`S_2` (not including the focal node). If the descendants of</span>
<span class="sd">        :math:`a` include some nodes in :math:`S_1` but no nodes in :math:`S_2`, then the</span>
<span class="sd">        GNN proportions for that tree will be 100% :math:`S_1` and 0% :math:`S_2`, or</span>
<span class="sd">        :math:`[1.0, 0.0]`.</span>

<span class="sd">        For a given focal node, the GNN proportions returned by this function are an</span>
<span class="sd">        average of the GNNs for each tree, weighted by the genomic distance spanned by</span>
<span class="sd">        that tree.</span>

<span class="sd">        For an precise mathematical definition of GNN, see https://doi.org/10.1101/458067</span>

<span class="sd">        .. note::</span>
<span class="sd">            The reference sets need not include all the samples, hence the most</span>
<span class="sd">            recent common ancestral node of the reference sets, :math:`a`, need not be</span>
<span class="sd">            the immediate ancestor of the focal node. If the reference sets only comprise</span>
<span class="sd">            sequences from relatively distant individuals, the GNN statistic may end up</span>
<span class="sd">            as a measure of comparatively distant ancestry, even for tree sequences that</span>
<span class="sd">            contain many closely related individuals.</span>

<span class="sd">        .. warning:: The interface for this method is preliminary and may be subject to</span>
<span class="sd">            backwards incompatible changes in the near future. The long-term stable</span>
<span class="sd">            API for this method will be consistent with other :ref:`sec_stats`.</span>

<span class="sd">        :param list focal: A list of :math:`n` nodes whose GNNs should be calculated.</span>
<span class="sd">        :param list sample_sets: A list of :math:`m` lists of node IDs.</span>
<span class="sd">        :return: An :math:`n`  by :math:`m` array of focal nodes by GNN proportions.</span>
<span class="sd">            Every focal node corresponds to a row. The numbers in each</span>
<span class="sd">            row corresponding to the GNN proportion for each of the passed-in reference</span>
<span class="sd">            sets. Rows therefore sum to one.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO add windows=None option: https://github.com/tskit-dev/tskit/issues/193</span>
        <span class="k">if</span> <span class="n">num_threads</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">genealogical_nearest_neighbours</span><span class="p">(</span>
                <span class="n">focal</span><span class="p">,</span> <span class="n">sample_sets</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">worker</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">genealogical_nearest_neighbours</span><span class="p">,</span>
                <span class="n">reference_sets</span><span class="o">=</span><span class="n">sample_sets</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">focal</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">focal</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="n">splits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">focal</span><span class="p">,</span> <span class="n">num_threads</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">arrays</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">splits</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">arrays</span><span class="p">))</span></div>


<div class="viewcode-block" id="TreeSequence.kc_distance">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.kc_distance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">kc_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">lambda_</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the average :meth:`Tree.kc_distance` between pairs of trees along</span>
<span class="sd">        the sequence whose intervals overlap. The average is weighted by the</span>
<span class="sd">        fraction of the sequence on which each pair of trees overlap.</span>

<span class="sd">        :param TreeSequence other: The other tree sequence to compare to.</span>
<span class="sd">        :param float lambda_: The KC metric lambda parameter determining the</span>
<span class="sd">            relative weight of topology and branch length.</span>
<span class="sd">        :return: The computed KC distance between this tree sequence and other.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">get_kc_distance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.count_topologies">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.count_topologies">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">count_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a generator that produces the same distribution of topologies as</span>
<span class="sd">        :meth:`Tree.count_topologies` but sequentially for every tree in a tree</span>
<span class="sd">        sequence. For use on a tree sequence this method is much faster than</span>
<span class="sd">        computing the result independently per tree.</span>

<span class="sd">        .. warning:: The interface for this method is preliminary and may be subject to</span>
<span class="sd">            backwards incompatible changes in the near future.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with.</span>
<span class="sd">        :rtype: iter(:class:`tskit.TopologyCounter`)</span>
<span class="sd">        :raises ValueError: If nodes in ``sample_sets`` are invalid or are</span>
<span class="sd">            internal samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">(</span><span class="n">population</span><span class="o">=</span><span class="n">pop</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">populations</span><span class="p">()</span>
            <span class="p">]</span>

        <span class="k">yield from</span> <span class="n">combinatorics</span><span class="o">.</span><span class="n">treeseq_count_topologies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.ibd_segments">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.ibd_segments">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ibd_segments</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">within</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">between</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">min_span</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">store_pairs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">store_segments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds pairs of samples that are identical by descent (IBD) and returns</span>
<span class="sd">        the result as an :class:`.IdentitySegments` instance. The information</span>
<span class="sd">        stored in this object is controlled by the ``store_pairs`` and</span>
<span class="sd">        ``store_segments`` parameters. By default only total counts and other</span>
<span class="sd">        statistics of the IBD segments are stored (i.e.,</span>
<span class="sd">        ``store_pairs=False``), since storing pairs and segments has a</span>
<span class="sd">        substantial CPU and memory overhead. Please see the</span>
<span class="sd">        :ref:`sec_identity` section for more details on how to access the</span>
<span class="sd">        information stored in the :class:`.IdentitySegments`.</span>

<span class="sd">        If ``within`` is specified, only IBD segments for pairs of nodes within</span>
<span class="sd">        that set will be recorded. If ``between`` is specified, only IBD</span>
<span class="sd">        segments from pairs that are in one or other of the specified sample</span>
<span class="sd">        sets will be reported. Note that ``within`` and ``between`` are</span>
<span class="sd">        mutually exclusive.</span>

<span class="sd">        A pair of nodes ``(u, v)`` has an IBD segment with a left and right</span>
<span class="sd">        coordinate ``[left, right)`` and ancestral node ``a`` iff the most</span>
<span class="sd">        recent common ancestor of the segment ``[left, right)`` in nodes ``u``</span>
<span class="sd">        and ``v`` is ``a``, and the segment has been inherited along the same</span>
<span class="sd">        genealogical path (ie. it has not been broken by recombination). The</span>
<span class="sd">        segments returned are the longest possible ones.</span>

<span class="sd">        Note that this definition is purely genealogical --- allelic states</span>
<span class="sd">        *are not* considered here. If used without time or length thresholds, the</span>
<span class="sd">        segments returned for a given pair will partition the span of the contig</span>
<span class="sd">        represented by the tree sequence.</span>

<span class="sd">        :param list within: A list of node IDs defining set of nodes that</span>
<span class="sd">            we find IBD segments for. If not specified, this defaults to</span>
<span class="sd">            all samples in the tree sequence.</span>
<span class="sd">        :param list[list] between: A list of lists of sample node IDs. Given</span>
<span class="sd">            two sample sets A and B, only IBD segments will be returned such</span>
<span class="sd">            that one of the samples is an element of A and the other is</span>
<span class="sd">            an element of B. Cannot be specified with ``within``.</span>
<span class="sd">        :param float max_time: Only segments inherited from common</span>
<span class="sd">            ancestors whose node times are more recent than the specified time</span>
<span class="sd">            will be returned. Specifying a maximum time is strongly recommended when</span>
<span class="sd">            working with large tree sequences.</span>
<span class="sd">        :param float min_span: Only segments in which the difference between</span>
<span class="sd">            the right and left genome coordinates (i.e., the span of the</span>
<span class="sd">            segment) is greater than this value will be included. (Default=0)</span>
<span class="sd">        :param bool store_pairs: If True store information separately for each</span>
<span class="sd">            pair of samples ``(a, b)`` that are found to be IBD. Otherwise</span>
<span class="sd">            store summary information about all sample pairs. (Default=False)</span>
<span class="sd">        :param bool store_segments: If True store each IBD segment</span>
<span class="sd">            ``(left, right, c)`` and associate it with the corresponding</span>
<span class="sd">            sample pair ``(a, b)``. If True, implies ``store_pairs``.</span>
<span class="sd">            (Default=False).</span>
<span class="sd">        :return: An :class:`.IdentitySegments` object containing the recorded</span>
<span class="sd">            IBD information.</span>
<span class="sd">        :rtype: IdentitySegments</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dump_tables</span><span class="p">()</span><span class="o">.</span><span class="n">ibd_segments</span><span class="p">(</span>
            <span class="n">within</span><span class="o">=</span><span class="n">within</span><span class="p">,</span>
            <span class="n">between</span><span class="o">=</span><span class="n">between</span><span class="p">,</span>
            <span class="n">max_time</span><span class="o">=</span><span class="n">max_time</span><span class="p">,</span>
            <span class="n">min_span</span><span class="o">=</span><span class="n">min_span</span><span class="p">,</span>
            <span class="n">store_segments</span><span class="o">=</span><span class="n">store_segments</span><span class="p">,</span>
            <span class="n">store_pairs</span><span class="o">=</span><span class="n">store_pairs</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TreeSequence.pair_coalescence_counts">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.pair_coalescence_counts">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pair_coalescence_counts</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">span_normalise</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pair_normalise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">time_windows</span><span class="o">=</span><span class="s2">&quot;nodes&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the number of coalescing sample pairs per node, summed over</span>
<span class="sd">        trees and weighted by tree span.</span>

<span class="sd">        The number of coalescing pairs may be calculated within or between the</span>
<span class="sd">        non-overlapping lists of samples contained in `sample_sets`. In the</span>
<span class="sd">        latter case, pairs are counted if they have exactly one member in each</span>
<span class="sd">        of two sample sets. If `sample_sets` is omitted, a single set</span>
<span class="sd">        containing all samples is assumed.</span>

<span class="sd">        The argument `indexes` may be used to specify which pairs of sample</span>
<span class="sd">        sets to compute the statistic between, and in what order. If</span>
<span class="sd">        `indexes=None`, then `indexes` is assumed to equal `[(0,0)]` for a</span>
<span class="sd">        single sample set and `[(0,1)]` for two sample sets. For more than two</span>
<span class="sd">        sample sets, `indexes` must be explicitly passed.</span>

<span class="sd">        The argument `time_windows` may be used to count coalescence</span>
<span class="sd">        events within time intervals (if an array of breakpoints is supplied)</span>
<span class="sd">        rather than for individual nodes (the default).</span>

<span class="sd">        The output array has dimension `(windows, indexes, nodes)` with</span>
<span class="sd">        dimensions dropped when the corresponding argument is set to None.</span>

<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with, or None.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the</span>
<span class="sd">            sequence windows to compute the statistic in, or None.</span>
<span class="sd">        :param bool span_normalise: Whether to divide the result by the span of</span>
<span class="sd">            non-missing sequence in the window (defaults to True).</span>
<span class="sd">        :param bool pair_normalise: Whether to divide the result by the total</span>
<span class="sd">            number of pairs for a given index (defaults to False).</span>
<span class="sd">        :param time_windows: Either a string &quot;nodes&quot; or an increasing</span>
<span class="sd">            list of breakpoints between time intervals.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">())]</span>

        <span class="n">drop_middle_dimension</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">drop_middle_dimension</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Must specify indexes if there are more than two sample sets&quot;</span>
                <span class="p">)</span>
        <span class="n">num_indexes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>

        <span class="n">drop_left_dimension</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">drop_left_dimension</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">])</span>
        <span class="n">num_windows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">time_windows</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">time_windows</span> <span class="o">==</span> <span class="s2">&quot;nodes&quot;</span><span class="p">:</span>
            <span class="n">num_time_windows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_nodes</span>
            <span class="n">node_bin_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_time_windows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_units</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TIME_UNITS_UNCALIBRATED</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Time windows require calibrated node times&quot;</span><span class="p">)</span>
            <span class="n">num_time_windows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_windows</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">node_bin_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_time</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">node_bin_map</span><span class="p">[</span><span class="n">node_bin_map</span> <span class="o">==</span> <span class="n">num_time_windows</span><span class="p">]</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span>
            <span class="n">node_bin_map</span> <span class="o">=</span> <span class="n">node_bin_map</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">num_bins</span> <span class="o">=</span> <span class="n">node_bin_map</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">sample_set_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">coalescing_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_windows</span><span class="p">,</span> <span class="n">num_indexes</span><span class="p">,</span> <span class="n">num_time_windows</span><span class="p">))</span>
        <span class="n">coalescing_pairs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">num_bins</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="o">.</span><span class="n">pair_coalescence_counts</span><span class="p">(</span>
                <span class="n">sample_sets</span><span class="o">=</span><span class="n">sample_sets</span><span class="p">,</span>
                <span class="n">sample_set_sizes</span><span class="o">=</span><span class="n">sample_set_sizes</span><span class="p">,</span>
                <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
                <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
                <span class="n">node_bin_map</span><span class="o">=</span><span class="n">node_bin_map</span><span class="p">,</span>
                <span class="n">span_normalise</span><span class="o">=</span><span class="n">span_normalise</span><span class="p">,</span>
                <span class="n">pair_normalise</span><span class="o">=</span><span class="n">pair_normalise</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">drop_middle_dimension</span><span class="p">:</span>
            <span class="n">coalescing_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">coalescing_pairs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_left_dimension</span><span class="p">:</span>
            <span class="n">coalescing_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">coalescing_pairs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coalescing_pairs</span></div>


<div class="viewcode-block" id="TreeSequence.pair_coalescence_quantiles">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.pair_coalescence_quantiles">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pair_coalescence_quantiles</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">quantiles</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate quantiles of pair coalescence times by inverting the empirical</span>
<span class="sd">        CDF. This is equivalent to the &quot;inverted_cdf&quot; method of</span>
<span class="sd">        `numpy.quantile` applied to node times, with weights proportional to</span>
<span class="sd">        the number of coalescing pairs per node (averaged over trees, see</span>
<span class="sd">        `TreeSequence.pair_coalescence_counts`).</span>

<span class="sd">        Quantiles of pair coalescence times may be calculated within or</span>
<span class="sd">        between the non-overlapping lists of samples contained in `sample_sets`. In</span>
<span class="sd">        the latter case, pairs are counted if they have exactly one member in each</span>
<span class="sd">        of two sample sets. If `sample_sets` is omitted, a single set containing</span>
<span class="sd">        all samples is assumed.</span>

<span class="sd">        The argument `indexes` may be used to specify which pairs of sample sets to</span>
<span class="sd">        compute coalescences between, and in what order. If `indexes=None`, then</span>
<span class="sd">        `indexes` is assumed to equal `[(0,0)]` for a single sample set and</span>
<span class="sd">        `[(0,1)]` for two sample sets. For more than two sample sets, `indexes`</span>
<span class="sd">        must be explicitly passed.</span>

<span class="sd">        The output array has dimension `(windows, indexes, quantiles)` with</span>
<span class="sd">        dimensions dropped when the corresponding argument is set to None.</span>

<span class="sd">        :param quantiles: A list of increasing breakpoints between [0, 1].</span>
<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with, or None.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the</span>
<span class="sd">            sequence windows to compute the statistic in, or None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">())]</span>

        <span class="n">drop_middle_dimension</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">drop_middle_dimension</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Must specify indexes if there are more than two sample sets&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_units</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TIME_UNITS_UNCALIBRATED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pair coalescence quantiles require calibrated node times&quot;</span><span class="p">)</span>

        <span class="n">drop_left_dimension</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">drop_left_dimension</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">])</span>

        <span class="n">sample_set_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">node_bin_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_time</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">node_bin_map</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">node_bin_map</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">coalescence_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="o">.</span><span class="n">pair_coalescence_quantiles</span><span class="p">(</span>
            <span class="n">sample_sets</span><span class="o">=</span><span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">sample_set_sizes</span><span class="o">=</span><span class="n">sample_set_sizes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">node_bin_map</span><span class="o">=</span><span class="n">node_bin_map</span><span class="p">,</span>
            <span class="n">quantiles</span><span class="o">=</span><span class="n">quantiles</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">drop_middle_dimension</span><span class="p">:</span>
            <span class="n">coalescence_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">coalescence_times</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_left_dimension</span><span class="p">:</span>
            <span class="n">coalescence_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">coalescence_times</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coalescence_times</span></div>


<div class="viewcode-block" id="TreeSequence.pair_coalescence_rates">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.pair_coalescence_rates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pair_coalescence_rates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">time_windows</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">windows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate the rate at which pairs of samples coalesce within time</span>
<span class="sd">        windows, using the empirical cumulative distribution function (ecdf) of</span>
<span class="sd">        pair coalescence times.  Assuming that pair coalescence events follow a</span>
<span class="sd">        nonhomogeneous Poisson process, the empirical rate for a time window</span>
<span class="sd">        :math:`[a, b)` where :math:`ecdf(b) &lt; 1` is,</span>

<span class="sd">        ..math:</span>

<span class="sd">            log(1 - \\frac{ecdf(b) - ecdf(a)}{1 - ecdf(a)}) / (a - b)</span>

<span class="sd">        If the last coalescence event is within :math:`[a, b)`, so that</span>
<span class="sd">        :math:`ecdf(b) = 1`, then an estimate of the empirical rate is</span>

<span class="sd">        ..math:</span>

<span class="sd">            (\\mathbb{E}[t | t &gt; a] - a)^{-1}</span>

<span class="sd">        where :math:`\\mathbb{E}[t | t &lt; a]` is the average pair coalescence time</span>
<span class="sd">        conditional on coalescence after the start of the last epoch.</span>

<span class="sd">        The first breakpoint in `time_windows` must start at the age of the</span>
<span class="sd">        samples, and the last must end at infinity. In the output array, any</span>
<span class="sd">        time windows where all pairs have coalesced by start of the window will</span>
<span class="sd">        contain `NaN` values.</span>

<span class="sd">        Pair coalescence rates may be calculated within or between the</span>
<span class="sd">        non-overlapping lists of samples contained in `sample_sets`. In the</span>
<span class="sd">        latter case, pairs are counted if they have exactly one member in each</span>
<span class="sd">        of two sample sets. If `sample_sets` is omitted, a single group</span>
<span class="sd">        containing all samples is assumed.</span>

<span class="sd">        The argument `indexes` may be used to specify which pairs of sample</span>
<span class="sd">        sets to compute the statistic between, and in what order. If</span>
<span class="sd">        `indexes=None`, then `indexes` is assumed to equal `[(0,0)]` for a</span>
<span class="sd">        single sample set and `[(0,1)]` for two sample sets. For more than two</span>
<span class="sd">        sample sets, `indexes` must be explicitly passed.</span>

<span class="sd">        The output array has dimension `(windows, indexes, time_windows)` with</span>
<span class="sd">        dimensions dropped when the corresponding argument is set to None.</span>

<span class="sd">        :param time_windows: An increasing list of breakpoints between time</span>
<span class="sd">            intervals, starting at the age of the samples and ending at</span>
<span class="sd">            infinity.</span>
<span class="sd">        :param list sample_sets: A list of lists of Node IDs, specifying the</span>
<span class="sd">            groups of nodes to compute the statistic with, or None.</span>
<span class="sd">        :param list indexes: A list of 2-tuples, or None.</span>
<span class="sd">        :param list windows: An increasing list of breakpoints between the</span>
<span class="sd">            sequence windows to compute the statistic in, or None.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sample_sets</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sample_sets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">())]</span>

        <span class="n">drop_middle_dimension</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">drop_middle_dimension</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Must specify indexes if there are more than two sample sets&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_units</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">TIME_UNITS_UNCALIBRATED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pair coalescence rates require calibrated node times&quot;</span><span class="p">)</span>

        <span class="n">drop_left_dimension</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">windows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">drop_left_dimension</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">windows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">])</span>

        <span class="n">sample_set_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sample_sets</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
        <span class="n">sample_sets</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_np_int_cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">sample_sets</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">node_bin_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_time</span><span class="p">,</span> <span class="n">time_windows</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">node_bin_map</span><span class="p">[</span><span class="n">node_bin_map</span> <span class="o">==</span> <span class="n">time_windows</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span>
        <span class="n">node_bin_map</span> <span class="o">=</span> <span class="n">node_bin_map</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">coalescence_rates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ll_tree_sequence</span><span class="o">.</span><span class="n">pair_coalescence_rates</span><span class="p">(</span>
            <span class="n">sample_sets</span><span class="o">=</span><span class="n">sample_sets</span><span class="p">,</span>
            <span class="n">sample_set_sizes</span><span class="o">=</span><span class="n">sample_set_sizes</span><span class="p">,</span>
            <span class="n">windows</span><span class="o">=</span><span class="n">windows</span><span class="p">,</span>
            <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">node_bin_map</span><span class="o">=</span><span class="n">node_bin_map</span><span class="p">,</span>
            <span class="n">time_windows</span><span class="o">=</span><span class="n">time_windows</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">drop_middle_dimension</span><span class="p">:</span>
            <span class="n">coalescence_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">coalescence_rates</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_left_dimension</span><span class="p">:</span>
            <span class="n">coalescence_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">coalescence_rates</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coalescence_rates</span></div>


<div class="viewcode-block" id="TreeSequence.impute_unknown_mutations_time">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.impute_unknown_mutations_time">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">impute_unknown_mutations_time</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an array of mutation times, where any unknown times are</span>
<span class="sd">        imputed from the times of associated nodes. Not to be confused with</span>
<span class="sd">        :meth:`TableCollection.compute_mutation_times`, which modifies the</span>
<span class="sd">        ``time`` column of the mutations table in place.</span>

<span class="sd">        :param str method: The method used to impute the unknown mutation times.</span>
<span class="sd">            Currently only &quot;min&quot; is supported, which uses the time of the node</span>
<span class="sd">            below the mutation as the mutation time. The &quot;min&quot; method can also</span>
<span class="sd">            be specified by ``method=None`` (Default: ``None``).</span>
<span class="sd">        :return: An array of length equal to the number of mutations in the</span>
<span class="sd">            tree sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">allowed_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;min&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_methods</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Mutations time imputation method must be chosen from </span><span class="si">{</span><span class="n">allowed_methods</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
            <span class="n">mutations_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutations_time</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">unknown</span> <span class="o">=</span> <span class="n">tskit</span><span class="o">.</span><span class="n">is_unknown_time</span><span class="p">(</span><span class="n">mutations_time</span><span class="p">)</span>
            <span class="n">mutations_time</span><span class="p">[</span><span class="n">unknown</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes_time</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mutations_node</span><span class="p">[</span><span class="n">unknown</span><span class="p">]]</span>
            <span class="k">return</span> <span class="n">mutations_time</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">ld_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_sets</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sites</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;site&quot;</span><span class="p">,</span>
        <span class="n">stat</span><span class="o">=</span><span class="s2">&quot;r2&quot;</span><span class="p">,</span>
        <span class="n">indexes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">one_way_stats</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">D_matrix</span><span class="p">,</span>
            <span class="s2">&quot;D2&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">D2_matrix</span><span class="p">,</span>
            <span class="s2">&quot;r2&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">r2_matrix</span><span class="p">,</span>
            <span class="s2">&quot;D_prime&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">D_prime_matrix</span><span class="p">,</span>
            <span class="s2">&quot;r&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">r_matrix</span><span class="p">,</span>
            <span class="s2">&quot;Dz&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">Dz_matrix</span><span class="p">,</span>
            <span class="s2">&quot;pi2&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">pi2_matrix</span><span class="p">,</span>
            <span class="s2">&quot;Dz_unbiased&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">Dz_unbiased_matrix</span><span class="p">,</span>
            <span class="s2">&quot;D2_unbiased&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">D2_unbiased_matrix</span><span class="p">,</span>
            <span class="s2">&quot;pi2_unbiased&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">pi2_unbiased_matrix</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">two_way_stats</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;D2&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">D2_ij_matrix</span><span class="p">,</span>
            <span class="s2">&quot;D2_unbiased&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">D2_ij_unbiased_matrix</span><span class="p">,</span>
            <span class="s2">&quot;r2&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ll_tree_sequence</span><span class="o">.</span><span class="n">r2_ij_matrix</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">one_way_stats</span> <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">two_way_stats</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">stat_func</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="n">stat</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown two-locus statistic &#39;</span><span class="si">{</span><span class="n">stat</span><span class="si">}</span><span class="s2">&#39;, we support: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__k_way_two_locus_sample_set_stat</span><span class="p">(</span>
                <span class="n">stat_func</span><span class="p">,</span>
                <span class="mi">2</span><span class="p">,</span>
                <span class="n">sample_sets</span><span class="p">,</span>
                <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
                <span class="n">sites</span><span class="o">=</span><span class="n">sites</span><span class="p">,</span>
                <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__two_locus_sample_set_stat</span><span class="p">(</span>
            <span class="n">stat_func</span><span class="p">,</span> <span class="n">sample_sets</span><span class="p">,</span> <span class="n">sites</span><span class="o">=</span><span class="n">sites</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TreeSequence.sample_nodes_by_ploidy">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.sample_nodes_by_ploidy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sample_nodes_by_ploidy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ploidy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an 2D array of node IDs, where each row has length `ploidy`.</span>
<span class="sd">        This is useful when individuals are not defined in the tree sequence</span>
<span class="sd">        so `TreeSequence.individuals_nodes` cannot be used. The samples are</span>
<span class="sd">        placed in the array in the order which they are found in the node</span>
<span class="sd">        table. The number of sample nodes must be a multiple of ploidy.</span>

<span class="sd">        :param int ploidy: The number of samples per individual.</span>
<span class="sd">        :return: A 2D array of node IDs, where each row has length `ploidy`.</span>
<span class="sd">        :rtype: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ploidy</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ploidy</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ploidy</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Ploidy must be a positive integer&quot;</span><span class="p">)</span>
        <span class="n">sample_node_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes_flags</span> <span class="o">&amp;</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span><span class="p">)</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_node_ids</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_samples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No sample nodes in tree sequence&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_samples</span> <span class="o">%</span> <span class="n">ploidy</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Number of sample nodes </span><span class="si">{</span><span class="n">num_samples</span><span class="si">}</span><span class="s2"> is not a multiple &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;of ploidy </span><span class="si">{</span><span class="n">ploidy</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">num_samples_per_individual</span> <span class="o">=</span> <span class="n">num_samples</span> <span class="o">//</span> <span class="n">ploidy</span>
        <span class="n">sample_node_ids</span> <span class="o">=</span> <span class="n">sample_node_ids</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">num_samples_per_individual</span><span class="p">,</span> <span class="n">ploidy</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">sample_node_ids</span></div>


<div class="viewcode-block" id="TreeSequence.map_to_vcf_model">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.map_to_vcf_model">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">map_to_vcf_model</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">individuals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ploidy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">name_metadata_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">individual_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">include_non_sample_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">position_transform</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">contig_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">isolated_as_missing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maps the sample nodes in this tree sequence to a representation suitable for</span>
<span class="sd">        VCF output, using the individuals if present.</span>

<span class="sd">        Creates a VcfModelMapping object that contains a nodes-to-individual</span>
<span class="sd">        mapping as a 2D array of (individuals, nodes), the individual names and VCF</span>
<span class="sd">        compatible site positions and contig length. The</span>
<span class="sd">        mapping is created by first checking if the tree sequence contains individuals.</span>
<span class="sd">        If it does, the mapping is created using the individuals in the tree sequence.</span>
<span class="sd">        By default only the sample nodes of the individuals are included in the mapping,</span>
<span class="sd">        unless ``include_non_sample_nodes`` is set to True, in which case all nodes</span>
<span class="sd">        belonging to the individuals are included. Any individuals without any nodes</span>
<span class="sd">        will have no nodes in their row of the mapping, being essentially of zero ploidy.</span>
<span class="sd">        If no individuals are present, the mapping is created using only the sample nodes</span>
<span class="sd">        and the specified ploidy.</span>

<span class="sd">        As the tskit data model allows non-integer positions, site positions and contig</span>
<span class="sd">        length are transformed to integer values suitable for VCF output. The</span>
<span class="sd">        transformation is done using the ``position_transform`` function, which must</span>
<span class="sd">        return an integer numpy array the same dimension as the input. By default,</span>
<span class="sd">        this is set to ``numpy.round()`` which will round values to the nearest integer.</span>

<span class="sd">        If neither ``name_metadata_key`` nor ``individual_names`` is specified, the</span>
<span class="sd">        individual names are set to ``&quot;tsk_{individual_id}&quot;`` for each individual. If</span>
<span class="sd">        no individuals are present, the individual names are set to ``&quot;tsk_{i}&quot;`` with</span>
<span class="sd">        ``0 &lt;= i &lt; num_sample_nodes/ploidy``.</span>

<span class="sd">        A warning is emitted if any sample nodes do not have an individual ID.</span>

<span class="sd">        :param list individuals: Specific individual IDs to include in the VCF. If not</span>
<span class="sd">            specified and the tree sequence contains individuals, all individuals are</span>
<span class="sd">            included that are associated with least one sample node (or at least one of</span>
<span class="sd">            any node if ``include_non_sample_nodes`` is True), and the mapping arrays</span>
<span class="sd">            will be in ascending order of the ID of the individual in the tree sequence.</span>
<span class="sd">        :param int ploidy: The ploidy, or number of nodes per individual. Only used when</span>
<span class="sd">            the tree sequence does not contain individuals. Cannot be used if the tree</span>
<span class="sd">            sequence contains individuals. Defaults to 1 if not specified.</span>
<span class="sd">        :param str name_metadata_key: The key in the individual metadata to use</span>
<span class="sd">            for individual names. Cannot be specified simultaneously with</span>
<span class="sd">            individual_names.</span>
<span class="sd">        :param list individual_names: The names to use for each individual. Cannot</span>
<span class="sd">            be specified simultaneously with name_metadata_key.</span>
<span class="sd">        :param bool include_non_sample_nodes: If True, include all nodes belonging to</span>
<span class="sd">            the individuals in the mapping. If False, only include sample nodes.</span>
<span class="sd">            Defaults to False.</span>
<span class="sd">        :param position_transform: A callable that transforms the</span>
<span class="sd">            site position values into integer valued coordinates suitable for</span>
<span class="sd">            VCF. The function takes a single positional parameter x and must</span>
<span class="sd">            return an integer numpy array the same dimension as x. By default,</span>
<span class="sd">            this is set to ``numpy.round()`` which will round values to the</span>
<span class="sd">            nearest integer. If the string &quot;legacy&quot; is provided here, the</span>
<span class="sd">            pre 0.2.0 legacy behaviour of rounding values to the nearest integer</span>
<span class="sd">            (starting from 1) and avoiding the output of identical positions</span>
<span class="sd">            by incrementing is used.</span>
<span class="sd">            See the :ref:`sec_export_vcf_modifying_coordinates` for examples</span>
<span class="sd">            and more information.</span>
<span class="sd">        :param str contig_id: The ID of the contig to use in the VCF output.</span>
<span class="sd">            Defaults to &quot;1&quot; if not specified.</span>
<span class="sd">        :param bool isolated_as_missing: If True, isolated samples without mutations</span>
<span class="sd">            will be considered as missing data in the VCF output. If False, these samples</span>
<span class="sd">            will have the ancestral state in the VCF output.</span>
<span class="sd">            Default: True.</span>
<span class="sd">        :return: A VcfModelMapping containing the node-to-individual mapping,</span>
<span class="sd">            individual names, transformed positions, and transformed contig length.</span>
<span class="sd">        :raises ValueError: If both name_metadata_key and individual_names are specified,</span>
<span class="sd">            if ploidy is specified when individuals are present, if an invalid individual</span>
<span class="sd">            ID is specified, if a specified individual has no nodes, or if the number of</span>
<span class="sd">            individuals doesn&#39;t match the number of names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">include_non_sample_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">include_non_sample_nodes</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">contig_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">contig_id</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>

        <span class="k">if</span> <span class="n">isolated_as_missing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isolated_as_missing</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">name_metadata_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">individual_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify both name_metadata_key and individual_names&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ploidy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify ploidy when individuals are present in the tree sequence&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">include_non_sample_nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot include non-sample nodes when individuals are not present in &quot;</span>
                <span class="s2">&quot;the tree sequence&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_individual</span> <span class="o">==</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NULL</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_flags</span> <span class="o">&amp;</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;At least one sample node does not have an individual ID.&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">individuals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ploidy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ploidy</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">individuals_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_nodes_by_ploidy</span><span class="p">(</span><span class="n">ploidy</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">individual_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">individual_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;tsk_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">individuals_nodes</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">individuals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">individuals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">individuals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No individuals specified&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">individuals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">individuals</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_individuals</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid individual ID&quot;</span><span class="p">)</span>

            <span class="n">individuals_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_nodes</span><span class="p">[</span><span class="n">individuals</span><span class="p">]</span>
            <span class="n">non_sample_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes_flags</span><span class="p">[</span><span class="n">individuals_nodes</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">tskit</span><span class="o">.</span><span class="n">NODE_IS_SAMPLE</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">non_sample_nodes</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">include_non_sample_nodes</span><span class="p">:</span>
                <span class="n">individuals_nodes</span><span class="p">[</span><span class="n">non_sample_nodes</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">rows_to_reorder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">non_sample_nodes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rows_to_reorder</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="n">individuals_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">individuals_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">row</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="n">row</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="n">individual_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name_metadata_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">individual_names</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">individual</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="n">name_metadata_key</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">individuals</span>
                    <span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">individual_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;tsk_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">individuals</span><span class="p">]</span>

        <span class="n">individual_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">individual_names</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">individuals_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">individual_names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The number of individuals does not match the number of names&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">legacy_position_transform</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Transforms positions in the tree sequence into VCF coordinates under</span>
<span class="sd">            the pre 0.2.0 legacy rule.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">last_pos</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">transformed</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">last_pos</span><span class="p">:</span>
                    <span class="n">pos</span> <span class="o">=</span> <span class="n">last_pos</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">transformed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
                <span class="n">last_pos</span> <span class="o">=</span> <span class="n">pos</span>
            <span class="k">return</span> <span class="n">transformed</span>

        <span class="k">if</span> <span class="n">position_transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">position_transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span>
        <span class="k">elif</span> <span class="n">position_transform</span> <span class="o">==</span> <span class="s2">&quot;legacy&quot;</span><span class="p">:</span>
            <span class="n">position_transform</span> <span class="o">=</span> <span class="n">legacy_position_transform</span>
        <span class="n">transformed_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">position_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sites_position</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">transformed_positions</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sites</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Position transform must return an array of the same length&quot;</span>
            <span class="p">)</span>
        <span class="n">contig_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">position_transform</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">])[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">VcfModelMapping</span><span class="p">(</span>
            <span class="n">individuals_nodes</span><span class="p">,</span>
            <span class="n">individual_names</span><span class="p">,</span>
            <span class="n">transformed_positions</span><span class="p">,</span>
            <span class="n">contig_length</span><span class="p">,</span>
            <span class="n">contig_id</span><span class="p">,</span>
            <span class="n">isolated_as_missing</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="c1">############################################</span>
    <span class="c1">#</span>
    <span class="c1"># Deprecated APIs. These are either already unsupported, or will be unsupported in a</span>
    <span class="c1"># later release.</span>
    <span class="c1">#</span>
    <span class="c1">############################################</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_pairwise_diversity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Deprecated alias for self.pairwise_diversity</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairwise_diversity</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

<div class="viewcode-block" id="TreeSequence.pairwise_diversity">
<a class="viewcode-back" href="../../python-api.html#tskit.TreeSequence.pairwise_diversity">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pairwise_diversity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the pairwise nucleotide site diversity, the average number of sites</span>
<span class="sd">        that differ between a every possible pair of distinct samples.  If `samples` is</span>
<span class="sd">        specified, calculate the diversity within this set.</span>

<span class="sd">         .. deprecated:: 0.2.0</span>
<span class="sd">             please use :meth:`.diversity` instead. Since version 0.2.0 the error</span>
<span class="sd">             semantics have also changed slightly. It is no longer an error</span>
<span class="sd">             when there is one sample and a tskit.LibraryError is raised</span>
<span class="sd">             when non-sample IDs are provided rather than a ValueError. It is</span>
<span class="sd">             also no longer an error to compute pairwise diversity at sites</span>
<span class="sd">             with multiple mutations.</span>

<span class="sd">        :param list samples: The set of samples within which we calculate</span>
<span class="sd">            the diversity. If None, calculate diversity within the entire sample.</span>
<span class="sd">        :return: The pairwise nucleotide site diversity.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">samples</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">diversity</span><span class="p">(</span>
                <span class="p">[</span><span class="n">samples</span><span class="p">],</span> <span class="n">windows</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">],</span> <span class="n">span_normalise</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">get_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated. Use ts.node(u).time</span>
        <span class="k">if</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">u</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_nodes</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ID out of bounds&quot;</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">time</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_population</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
        <span class="c1"># Deprecated. Use ts.node(u).population</span>
        <span class="k">if</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">u</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_num_nodes</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ID out of bounds&quot;</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">population</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">records</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Deprecated. Use either ts.edges() or ts.edgesets().</span>
        <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">time</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">population</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edgesets</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">CoalescenceRecord</span><span class="p">(</span>
                <span class="n">e</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">parent</span><span class="p">],</span> <span class="n">pop</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">parent</span><span class="p">]</span>
            <span class="p">)</span>

    <span class="c1"># Unsupported old methods.</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_num_records</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;This method is no longer supported. Please use the &quot;</span>
            <span class="s2">&quot;TreeSequence.num_edges if possible to work with edges rather &quot;</span>
            <span class="s2">&quot;than coalescence records. If not, please use len(list(ts.edgesets())) &quot;</span>
            <span class="s2">&quot;which should return the number of coalescence records, as previously &quot;</span>
            <span class="s2">&quot;defined. Please open an issue on GitHub if this is &quot;</span>
            <span class="s2">&quot;important for your workflow.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">diffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;This method is no longer supported. Please use the &quot;</span>
            <span class="s2">&quot;TreeSequence.edge_diffs() method instead&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">newick_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">breakpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ne</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;This method is no longer supported. Please use the Tree.newick&quot;</span>
            <span class="s2">&quot; method instead&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_nexus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;This method is no longer supported since 0.4.0. Please use the as_nexus &quot;</span>
            <span class="s2">&quot;or write_nexus methods instead&quot;</span>
        <span class="p">)</span></div>



<span class="c1"># TODO move to &quot;text_formats.py&quot;</span>
<span class="k">def</span><span class="w"> </span><span class="nf">write_ms</span><span class="p">(</span>
    <span class="n">tree_sequence</span><span class="p">,</span>
    <span class="n">output</span><span class="p">,</span>
    <span class="n">print_trees</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">num_replicates</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">write_header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Write ``ms`` formatted output from the genotypes of a tree sequence</span>
<span class="sd">    or an iterator over tree sequences. Usage:</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">        import tskit as ts</span>

<span class="sd">        tree_sequence = msprime.simulate(</span>
<span class="sd">            sample_size=sample_size,</span>
<span class="sd">            Ne=Ne,</span>
<span class="sd">            length=length,</span>
<span class="sd">            mutation_rate=mutation_rate,</span>
<span class="sd">            recombination_rate=recombination_rate,</span>
<span class="sd">            random_seed=random_seed,</span>
<span class="sd">            num_replicates=num_replicates,</span>
<span class="sd">        )</span>
<span class="sd">        with open(&quot;output.ms&quot;, &quot;w&quot;) as ms_file:</span>
<span class="sd">            ts.write_ms(tree_sequence, ms_file)</span>

<span class="sd">    :param ts tree_sequence: The tree sequence (or iterator over tree sequences) to</span>
<span class="sd">        write to ms file</span>
<span class="sd">    :param io.IOBase output: The file-like object to write the ms-style output</span>
<span class="sd">    :param bool print_trees: Boolean parameter to write out newick format trees</span>
<span class="sd">        to output [optional]</span>
<span class="sd">    :param int precision: Numerical precision with which to write the ms</span>
<span class="sd">        output [optional]</span>
<span class="sd">    :param bool write_header: Boolean parameter to write out the header. [optional]</span>
<span class="sd">    :param int num_replicates: Number of replicates simulated [required if</span>
<span class="sd">        num_replicates used in simulation]</span>

<span class="sd">    The first line of this ms-style output file written has two arguments which</span>
<span class="sd">    are sample size and number of replicates. The second line has a 0 as a substitute</span>
<span class="sd">    for the random seed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree_sequence</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">):</span>
        <span class="n">tree_sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree_sequence</span><span class="p">]</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">tree_seq</span> <span class="ow">in</span> <span class="n">tree_sequence</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">write_header</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">write_header</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;ms </span><span class="si">{</span><span class="n">tree_seq</span><span class="o">.</span><span class="n">sample_size</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">num_replicates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;//&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">print_trees</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Print out the trees in ms-format from the specified tree sequence.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree_seq</span><span class="o">.</span><span class="n">trees</span><span class="p">())</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">tree_seq</span><span class="o">.</span><span class="n">trees</span><span class="p">())</span>
                <span class="n">newick</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">newick</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">newick</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">tree_seq</span><span class="o">.</span><span class="n">trees</span><span class="p">():</span>
                    <span class="n">newick</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">newick</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">tree</span><span class="o">.</span><span class="n">span</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">precision</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span> <span class="n">newick</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">tree_seq</span><span class="o">.</span><span class="n">get_num_sites</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;segsites:&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;positions: &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
                <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">variant</span><span class="o">.</span><span class="n">position</span> <span class="o">/</span> <span class="p">(</span><span class="n">tree_seq</span><span class="o">.</span><span class="n">sequence_length</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">variant</span> <span class="ow">in</span> <span class="n">tree_seq</span><span class="o">.</span><span class="n">variants</span><span class="p">()</span>
                <span class="p">]</span>
                <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">position</span><span class="si">:</span><span class="s2">.</span><span class="si">{</span><span class="n">precision</span><span class="si">}</span><span class="s2">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">end</span><span class="o">=</span><span class="s2">&quot; &quot;</span><span class="p">,</span>
                        <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

                <span class="n">genotypes</span> <span class="o">=</span> <span class="n">tree_seq</span><span class="o">.</span><span class="n">genotype_matrix</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tree_seq</span><span class="o">.</span><span class="n">num_samples</span><span class="p">):</span>
                    <span class="n">tmp_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">genotypes</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">tmp_str</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">({</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span><span class="p">}):</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">tmp_str</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;This tree sequence contains non-biallelic&quot;</span>
                            <span class="s2">&quot;SNPs and is incompatible with the ms format!&quot;</span>
                        <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>


<div class="viewcode-block" id="PCAResult">
<a class="viewcode-back" href="../../python-api.html#tskit.PCAResult">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PCAResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The result of a call to TreeSequence.pca() capturing the output values</span>
<span class="sd">    and algorithm convergence details.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">factors</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The principal component factors (or scores).</span>
<span class="sd">    Columns are orthogonal, with one entry per sample</span>
<span class="sd">    or individual (see :meth:`pca &lt;.TreeSequence.pca&gt;`).</span>
<span class="sd">    This is the same as the loadings because the GRM is symmetric.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eigenvalues</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Eigenvalues of the genetic relatedness matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">range_sketch</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Range sketch matrix. Can be used as an input for</span>
<span class="sd">    :meth:`pca &lt;.TreeSequence.pca&gt;` option to further improve precision.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">error_bound</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An estimate of the error resulting from the randomized algorithm (experimental).</span>
<span class="sd">    Eigenvalues should be correct to within (roughly) this additive factor,</span>
<span class="sd">    and factors should be correct to within (roughly) this factor divided by the</span>
<span class="sd">    next-largest eigenvalue in the Euclidean norm. These estimates are obtained from</span>
<span class="sd">    a bound on the expected L2 operator norm between the true GRM and its</span>
<span class="sd">    low-dimensional approximation, from equation 1.11 in</span>
<span class="sd">    https://arxiv.org/pdf/0909.4061 .</span>
<span class="sd">    &quot;&quot;&quot;</span></div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Tskit Developers
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
       Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>